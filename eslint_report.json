[{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/file-system.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/globalSetup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/google_web_search.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/ide-client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/list_directory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/mcp_server_cyclic_schema.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/read_many_files.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/replace.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/run_shell_command.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/save_memory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/shell-service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/simple-mcp-server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/stdin-context.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/test-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/test-mcp-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/integration-tests/write_file.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp/add.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp/add.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp/list.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp/list.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp/remove.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/commands/mcp/remove.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/auth.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/config.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1201,1204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1201,1204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1268,1271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1268,1271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1334,1337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1334,1337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { homedir } from 'node:os';\nimport yargs from 'yargs/yargs';\nimport { hideBin } from 'yargs/helpers';\nimport process from 'node:process';\nimport { mcpCommand } from '../commands/mcp.js';\nimport {\n  Config,\n  loadServerHierarchicalMemory,\n  setGeminiMdFilename as setServerGeminiMdFilename,\n  getCurrentGeminiMdFilename,\n  ApprovalMode,\n  DEFAULT_GEMINI_MODEL,\n  DEFAULT_GEMINI_EMBEDDING_MODEL,\n  DEFAULT_MEMORY_FILE_FILTERING_OPTIONS,\n  FileDiscoveryService,\n  TelemetryTarget,\n  FileFilteringOptions,\n  ShellTool,\n  EditTool,\n  WriteFileTool,\n  MCPServerConfig,\n} from '@google/gemini-cli-core';\nimport { Settings } from './settings.js';\n\nimport { Extension, annotateActiveExtensions } from './extension.js';\nimport { getCliVersion } from '../utils/version.js';\nimport { loadSandboxConfig } from './sandboxConfig.js';\nimport { resolvePath } from '../utils/resolvePath.js';\n\nimport { isWorkspaceTrusted } from './trustedFolders.js';\n\n// Simple console logger for now - replace with actual logger if available\nconst logger = {\n   \n  debug: (...args: any[]) => console.debug('[DEBUG]', ...args),\n   \n  warn: (...args: any[]) => console.warn('[WARN]', ...args),\n   \n  error: (...args: any[]) => console.error('[ERROR]', ...args),\n};\n\nexport interface CliArgs {\n  model: string | undefined;\n  sandbox: boolean | string | undefined;\n  sandboxImage: string | undefined;\n  debug: boolean | undefined;\n  prompt: string | undefined;\n  promptInteractive: string | undefined;\n  allFiles: boolean | undefined;\n  all_files: boolean | undefined;\n  showMemoryUsage: boolean | undefined;\n  show_memory_usage: boolean | undefined;\n  yolo: boolean | undefined;\n  approvalMode: string | undefined;\n  telemetry: boolean | undefined;\n  checkpointing: boolean | undefined;\n  telemetryTarget: string | undefined;\n  telemetryOtlpEndpoint: string | undefined;\n  telemetryOtlpProtocol: string | undefined;\n  telemetryLogPrompts: boolean | undefined;\n  telemetryOutfile: string | undefined;\n  allowedMcpServerNames: string[] | undefined;\n  experimentalAcp: boolean | undefined;\n  extensions: string[] | undefined;\n  listExtensions: boolean | undefined;\n  proxy: string | undefined;\n  includeDirectories: string[] | undefined;\n  screenReader: boolean | undefined;\n}\n\nexport async function parseArguments(): Promise<CliArgs> {\n  const yargsInstance = yargs(hideBin(process.argv))\n    .locale('en')\n    .scriptName('gemini')\n    .usage(\n      'Usage: gemini [options] [command]\\n\\nGemini CLI - Launch an interactive CLI, use -p/--prompt for non-interactive mode',\n    )\n    .command('$0', 'Launch Gemini CLI', (yargsInstance) =>\n      yargsInstance\n        .option('model', {\n          alias: 'm',\n          type: 'string',\n          description: `Model`,\n          default: process.env['GEMINI_MODEL'],\n        })\n        .option('prompt', {\n          alias: 'p',\n          type: 'string',\n          description: 'Prompt. Appended to input on stdin (if any).',\n        })\n        .option('prompt-interactive', {\n          alias: 'i',\n          type: 'string',\n          description:\n            'Execute the provided prompt and continue in interactive mode',\n        })\n        .option('sandbox', {\n          alias: 's',\n          type: 'boolean',\n          description: 'Run in sandbox?',\n        })\n        .option('sandbox-image', {\n          type: 'string',\n          description: 'Sandbox image URI.',\n        })\n        .option('debug', {\n          alias: 'd',\n          type: 'boolean',\n          description: 'Run in debug mode?',\n          default: false,\n        })\n        .option('all-files', {\n          alias: ['a'],\n          type: 'boolean',\n          description: 'Include ALL files in context?',\n          default: false,\n        })\n        .option('all_files', {\n          type: 'boolean',\n          description: 'Include ALL files in context?',\n          default: false,\n        })\n        .deprecateOption(\n          'all_files',\n          'Use --all-files instead. We will be removing --all_files in the coming weeks.',\n        )\n        .option('show-memory-usage', {\n          type: 'boolean',\n          description: 'Show memory usage in status bar',\n          default: false,\n        })\n        .option('show_memory_usage', {\n          type: 'boolean',\n          description: 'Show memory usage in status bar',\n          default: false,\n        })\n        .deprecateOption(\n          'show_memory_usage',\n          'Use --show-memory-usage instead. We will be removing --show_memory_usage in the coming weeks.',\n        )\n        .option('yolo', {\n          alias: 'y',\n          type: 'boolean',\n          description:\n            'Automatically accept all actions (aka YOLO mode, see https://www.youtube.com/watch?v=xvFZjo5PgG0 for more details)?',\n          default: false,\n        })\n        .option('approval-mode', {\n          type: 'string',\n          choices: ['default', 'auto_edit', 'yolo'],\n          description:\n            'Set the approval mode: default (prompt for approval), auto_edit (auto-approve edit tools), yolo (auto-approve all tools)',\n        })\n        .option('telemetry', {\n          type: 'boolean',\n          description:\n            'Enable telemetry? This flag specifically controls if telemetry is sent. Other --telemetry-* flags set specific values but do not enable telemetry on their own.',\n        })\n        .option('telemetry-target', {\n          type: 'string',\n          choices: ['local', 'gcp'],\n          description:\n            'Set the telemetry target (local or gcp). Overrides settings files.',\n        })\n        .option('telemetry-otlp-endpoint', {\n          type: 'string',\n          description:\n            'Set the OTLP endpoint for telemetry. Overrides environment variables and settings files.',\n        })\n        .option('telemetry-otlp-protocol', {\n          type: 'string',\n          choices: ['grpc', 'http'],\n          description:\n            'Set the OTLP protocol for telemetry (grpc or http). Overrides settings files.',\n        })\n        .option('telemetry-log-prompts', {\n          type: 'boolean',\n          description:\n            'Enable or disable logging of user prompts for telemetry. Overrides settings files.',\n        })\n        .option('telemetry-outfile', {\n          type: 'string',\n          description: 'Redirect all telemetry output to the specified file.',\n        })\n        .option('checkpointing', {\n          alias: 'c',\n          type: 'boolean',\n          description: 'Enables checkpointing of file edits',\n          default: false,\n        })\n        .option('experimental-acp', {\n          type: 'boolean',\n          description: 'Starts the agent in ACP mode',\n        })\n        .option('allowed-mcp-server-names', {\n          type: 'array',\n          string: true,\n          description: 'Allowed MCP server names',\n        })\n        .option('extensions', {\n          alias: 'e',\n          type: 'array',\n          string: true,\n          description:\n            'A list of extensions to use. If not provided, all extensions are used.',\n        })\n        .option('list-extensions', {\n          alias: 'l',\n          type: 'boolean',\n          description: 'List all available extensions and exit.',\n        })\n        .option('proxy', {\n          type: 'string',\n          description:\n            'Proxy for gemini client, like schema://user:password@host:port',\n        })\n        .option('include-directories', {\n          type: 'array',\n          string: true,\n          description:\n            'Additional directories to include in the workspace (comma-separated or multiple --include-directories)',\n          coerce: (dirs: string[]) =>\n            // Handle comma-separated values\n            dirs.flatMap((dir) => dir.split(',').map((d) => d.trim())),\n        })\n        .option('screen-reader', {\n          type: 'boolean',\n          description: 'Enable screen reader mode for accessibility.',\n          default: false,\n        })\n\n        .check((argv) => {\n          if (argv.prompt && argv['promptInteractive']) {\n            throw new Error(\n              'Cannot use both --prompt (-p) and --prompt-interactive (-i) together',\n            );\n          }\n          if (argv.yolo && argv['approvalMode']) {\n            throw new Error(\n              'Cannot use both --yolo (-y) and --approval-mode together. Use --approval-mode=yolo instead.',\n            );\n          }\n          return true;\n        }),\n    )\n    // Register MCP subcommands\n    .command(mcpCommand)\n    .version(await getCliVersion()) // This will enable the --version flag based on package.json\n    .alias('v', 'version')\n    .help()\n    .alias('h', 'help')\n    .strict()\n    .demandCommand(0, 0); // Allow base command to run with no subcommands\n\n  yargsInstance.wrap(yargsInstance.terminalWidth());\n  const result = await yargsInstance.parse();\n\n  // Handle case where MCP subcommands are executed - they should exit the process\n  // and not return to main CLI logic\n  if (result._.length > 0 && result._[0] === 'mcp') {\n    // MCP commands handle their own execution and process exit\n    process.exit(0);\n  }\n\n  // The import format is now only controlled by settings.memoryImportFormat\n  // We no longer accept it as a CLI argument\n  return result as unknown as CliArgs;\n}\n\n// This function is now a thin wrapper around the server's implementation.\n// It's kept in the CLI for now as App.tsx directly calls it for memory refresh.\n// TODO: Consider if App.tsx should get memory via a server call or if Config should refresh itself.\nexport async function loadHierarchicalGeminiMemory(\n  currentWorkingDirectory: string,\n  includeDirectoriesToReadGemini: readonly string[] = [],\n  debugMode: boolean,\n  fileService: FileDiscoveryService,\n  settings: Settings,\n  extensionContextFilePaths: string[] = [],\n  memoryImportFormat: 'flat' | 'tree' = 'tree',\n  fileFilteringOptions?: FileFilteringOptions,\n): Promise<{ memoryContent: string; fileCount: number }> {\n  // FIX: Use real, canonical paths for a reliable comparison to handle symlinks.\n  const realCwd = fs.realpathSync(path.resolve(currentWorkingDirectory));\n  const realHome = fs.realpathSync(path.resolve(homedir()));\n  const isHomeDirectory = realCwd === realHome;\n\n  // If it is the home directory, pass an empty string to the core memory\n  // function to signal that it should skip the workspace search.\n  const effectiveCwd = isHomeDirectory ? '' : currentWorkingDirectory;\n\n  if (debugMode) {\n    logger.debug(\n      `CLI: Delegating hierarchical memory load to server for CWD: ${currentWorkingDirectory} (memoryImportFormat: ${memoryImportFormat})`,\n    );\n  }\n\n  // Directly call the server function with the corrected path.\n  return loadServerHierarchicalMemory(\n    effectiveCwd,\n    includeDirectoriesToReadGemini,\n    debugMode,\n    fileService,\n    extensionContextFilePaths,\n    memoryImportFormat,\n    fileFilteringOptions,\n    settings.memoryDiscoveryMaxDirs,\n  );\n}\n\nexport async function loadCliConfig(\n  settings: Settings,\n  extensions: Extension[],\n  sessionId: string,\n  argv: CliArgs,\n  cwd: string = process.cwd(),\n): Promise<Config> {\n  const debugMode =\n    argv.debug ||\n    [process.env['DEBUG'], process.env['DEBUG_MODE']].some(\n      (v) => v === 'true' || v === '1',\n    ) ||\n    false;\n  const memoryImportFormat = settings.memoryImportFormat || 'tree';\n\n  const ideMode = settings.ideMode ?? false;\n\n  const folderTrustFeature = settings.folderTrustFeature ?? false;\n  const folderTrustSetting = settings.folderTrust ?? true;\n  const folderTrust = folderTrustFeature && folderTrustSetting;\n  const trustedFolder = isWorkspaceTrusted(settings);\n\n  const allExtensions = annotateActiveExtensions(\n    extensions,\n    argv.extensions || [],\n  );\n\n  const activeExtensions = extensions.filter(\n    (_, i) => allExtensions[i].isActive,\n  );\n\n  // Set the context filename in the server's memoryTool module BEFORE loading memory\n  // TODO(b/343434939): This is a bit of a hack. The contextFileName should ideally be passed\n  // directly to the Config constructor in core, and have core handle setGeminiMdFilename.\n  // However, loadHierarchicalGeminiMemory is called *before* createServerConfig.\n  if (settings.contextFileName) {\n    setServerGeminiMdFilename(settings.contextFileName);\n  } else {\n    // Reset to default if not provided in settings.\n    setServerGeminiMdFilename(getCurrentGeminiMdFilename());\n  }\n\n  const extensionContextFilePaths = activeExtensions.flatMap(\n    (e) => e.contextFiles,\n  );\n\n  const fileService = new FileDiscoveryService(cwd);\n\n  const fileFiltering = {\n    ...DEFAULT_MEMORY_FILE_FILTERING_OPTIONS,\n    ...settings.fileFiltering,\n  };\n\n  const includeDirectories = (settings.includeDirectories || [])\n    .map(resolvePath)\n    .concat((argv.includeDirectories || []).map(resolvePath));\n\n  // Call the (now wrapper) loadHierarchicalGeminiMemory which calls the server's version\n  const { memoryContent, fileCount } = await loadHierarchicalGeminiMemory(\n    cwd,\n    settings.loadMemoryFromIncludeDirectories ? includeDirectories : [],\n    debugMode,\n    fileService,\n    settings,\n    extensionContextFilePaths,\n    memoryImportFormat,\n    fileFiltering,\n  );\n\n  let mcpServers = mergeMcpServers(settings, activeExtensions);\n  const question = argv.promptInteractive || argv.prompt || '';\n\n  // Determine approval mode with backward compatibility\n  let approvalMode: ApprovalMode;\n  if (argv.approvalMode) {\n    // New --approval-mode flag takes precedence\n    switch (argv.approvalMode) {\n      case 'yolo':\n        approvalMode = ApprovalMode.YOLO;\n        break;\n      case 'auto_edit':\n        approvalMode = ApprovalMode.AUTO_EDIT;\n        break;\n      case 'default':\n        approvalMode = ApprovalMode.DEFAULT;\n        break;\n      default:\n        throw new Error(\n          `Invalid approval mode: ${argv.approvalMode}. Valid values are: yolo, auto_edit, default`,\n        );\n    }\n  } else {\n    // Fallback to legacy --yolo flag behavior\n    approvalMode =\n      argv.yolo || false ? ApprovalMode.YOLO : ApprovalMode.DEFAULT;\n  }\n\n  const interactive =\n    !!argv.promptInteractive || (process.stdin.isTTY && question.length === 0);\n  // In non-interactive mode, exclude tools that require a prompt.\n  const extraExcludes: string[] = [];\n  if (!interactive && !argv.experimentalAcp) {\n    switch (approvalMode) {\n      case ApprovalMode.DEFAULT:\n        // In default non-interactive mode, all tools that require approval are excluded.\n        extraExcludes.push(ShellTool.Name, EditTool.Name, WriteFileTool.Name);\n        break;\n      case ApprovalMode.AUTO_EDIT:\n        // In auto-edit non-interactive mode, only tools that still require a prompt are excluded.\n        extraExcludes.push(ShellTool.Name);\n        break;\n      case ApprovalMode.YOLO:\n        // No extra excludes for YOLO mode.\n        break;\n      default:\n        // This should never happen due to validation earlier, but satisfies the linter\n        break;\n    }\n  }\n\n  const excludeTools = mergeExcludeTools(\n    settings,\n    activeExtensions,\n    extraExcludes.length > 0 ? extraExcludes : undefined,\n  );\n  const blockedMcpServers: Array<{ name: string; extensionName: string }> = [];\n\n  if (!argv.allowedMcpServerNames) {\n    if (settings.allowMCPServers) {\n      mcpServers = allowedMcpServers(\n        mcpServers,\n        settings.allowMCPServers,\n        blockedMcpServers,\n      );\n    }\n\n    if (settings.excludeMCPServers) {\n      const excludedNames = new Set(settings.excludeMCPServers.filter(Boolean));\n      if (excludedNames.size > 0) {\n        mcpServers = Object.fromEntries(\n          Object.entries(mcpServers).filter(([key]) => !excludedNames.has(key)),\n        );\n      }\n    }\n  }\n\n  if (argv.allowedMcpServerNames) {\n    mcpServers = allowedMcpServers(\n      mcpServers,\n      argv.allowedMcpServerNames,\n      blockedMcpServers,\n    );\n  }\n\n  const sandboxConfig = await loadSandboxConfig(settings, argv);\n\n  // The screen reader argument takes precedence over the accessibility setting.\n  const screenReader =\n    argv.screenReader ?? settings.accessibility?.screenReader ?? false;\n  return new Config({\n    sessionId,\n    embeddingModel: DEFAULT_GEMINI_EMBEDDING_MODEL,\n    sandbox: sandboxConfig,\n    targetDir: cwd,\n    includeDirectories,\n    loadMemoryFromIncludeDirectories:\n      settings.loadMemoryFromIncludeDirectories || false,\n    debugMode,\n    question,\n    fullContext: argv.allFiles || argv.all_files || false,\n    coreTools: settings.coreTools || undefined,\n    excludeTools,\n    toolDiscoveryCommand: settings.toolDiscoveryCommand,\n    toolCallCommand: settings.toolCallCommand,\n    mcpServerCommand: settings.mcpServerCommand,\n    mcpServers,\n    userMemory: memoryContent,\n    geminiMdFileCount: fileCount,\n    approvalMode,\n    showMemoryUsage:\n      argv.showMemoryUsage ||\n      argv.show_memory_usage ||\n      settings.showMemoryUsage ||\n      false,\n    accessibility: {\n      ...settings.accessibility,\n      screenReader,\n    },\n    telemetry: {\n      enabled: argv.telemetry ?? settings.telemetry?.enabled,\n      target: (argv.telemetryTarget ??\n        settings.telemetry?.target) as TelemetryTarget,\n      otlpEndpoint:\n        argv.telemetryOtlpEndpoint ??\n        process.env['OTEL_EXPORTER_OTLP_ENDPOINT'] ??\n        settings.telemetry?.otlpEndpoint,\n      otlpProtocol: (['grpc', 'http'] as const).find(\n        (p) =>\n          p ===\n          (argv.telemetryOtlpProtocol ?? settings.telemetry?.otlpProtocol),\n      ),\n      logPrompts: argv.telemetryLogPrompts ?? settings.telemetry?.logPrompts,\n      outfile: argv.telemetryOutfile ?? settings.telemetry?.outfile,\n    },\n    usageStatisticsEnabled: settings.usageStatisticsEnabled ?? true,\n    // Git-aware file filtering settings\n    fileFiltering: {\n      respectGitIgnore: settings.fileFiltering?.respectGitIgnore,\n      respectGeminiIgnore: settings.fileFiltering?.respectGeminiIgnore,\n      enableRecursiveFileSearch:\n        settings.fileFiltering?.enableRecursiveFileSearch,\n    },\n    checkpointing: argv.checkpointing || settings.checkpointing?.enabled,\n    proxy:\n      argv.proxy ||\n      process.env['HTTPS_PROXY'] ||\n      process.env['https_proxy'] ||\n      process.env['HTTP_PROXY'] ||\n      process.env['http_proxy'],\n    cwd,\n    fileDiscoveryService: fileService,\n    bugCommand: settings.bugCommand,\n    model: argv.model || settings.model || DEFAULT_GEMINI_MODEL,\n    extensionContextFilePaths,\n    maxSessionTurns: settings.maxSessionTurns ?? -1,\n    experimentalZedIntegration: argv.experimentalAcp || false,\n    listExtensions: argv.listExtensions || false,\n    extensions: allExtensions,\n    blockedMcpServers,\n    noBrowser: !!process.env['NO_BROWSER'],\n    summarizeToolOutput: settings.summarizeToolOutput,\n    ideMode,\n    chatCompression: settings.chatCompression,\n    folderTrustFeature,\n    folderTrust,\n    interactive,\n    trustedFolder,\n    useRipgrep: settings.useRipgrep,\n    shouldUseNodePtyShell: settings.shouldUseNodePtyShell,\n    skipNextSpeakerCheck: settings.skipNextSpeakerCheck,\n    enablePromptCompletion: settings.enablePromptCompletion ?? false,\n  });\n}\n\nfunction allowedMcpServers(\n  mcpServers: { [x: string]: MCPServerConfig },\n  allowMCPServers: string[],\n  blockedMcpServers: Array<{ name: string; extensionName: string }>,\n) {\n  const allowedNames = new Set(allowMCPServers.filter(Boolean));\n  if (allowedNames.size > 0) {\n    mcpServers = Object.fromEntries(\n      Object.entries(mcpServers).filter(([key, server]) => {\n        const isAllowed = allowedNames.has(key);\n        if (!isAllowed) {\n          blockedMcpServers.push({\n            name: key,\n            extensionName: server.extensionName || '',\n          });\n        }\n        return isAllowed;\n      }),\n    );\n  } else {\n    blockedMcpServers.push(\n      ...Object.entries(mcpServers).map(([key, server]) => ({\n        name: key,\n        extensionName: server.extensionName || '',\n      })),\n    );\n    mcpServers = {};\n  }\n  return mcpServers;\n}\n\nfunction mergeMcpServers(settings: Settings, extensions: Extension[]) {\n  const mcpServers = { ...(settings.mcpServers || {}) };\n  for (const extension of extensions) {\n    Object.entries(extension.config.mcpServers || {}).forEach(\n      ([key, server]) => {\n        if (mcpServers[key]) {\n          logger.warn(\n            `Skipping extension MCP config for server with key \"${key}\" as it already exists.`,\n          );\n          return;\n        }\n        mcpServers[key] = {\n          ...server,\n          extensionName: extension.config.name,\n        };\n      },\n    );\n  }\n  return mcpServers;\n}\n\nfunction mergeExcludeTools(\n  settings: Settings,\n  extensions: Extension[],\n  extraExcludes?: string[] | undefined,\n): string[] {\n  const allExcludeTools = new Set([\n    ...(settings.excludeTools || []),\n    ...(extraExcludes || []),\n  ]);\n  for (const extension of extensions) {\n    for (const tool of extension.config.excludeTools || []) {\n      allExcludeTools.add(tool);\n    }\n  }\n  return [...allExcludeTools];\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/extension.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/extension.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/keyBindings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/keyBindings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/sandboxConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/settings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/settings.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'folderTrust' is assigned a value but never used. Allowed unused vars must match /^_+/u.","line":84,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":84,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/settingsSchema.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/settingsSchema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/trustedFolders.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/config/trustedFolders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/gemini.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/gemini.tsx","messages":[],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":386,"column":7,"nodeType":"Literal","messageId":"unexpected","endLine":386,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/generated/git-commit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/nonInteractiveCli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/nonInteractiveCli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/patches/is-in-ci.ts","messages":[],"suppressedMessages":[{"ruleId":"import/no-default-export","severity":1,"message":"Prefer named exports.","line":17,"column":8,"nodeType":"ExportDefaultDeclaration","endLine":17,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/BuiltinCommandLoader.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/BuiltinCommandLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/CommandService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/CommandService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/FileCommandLoader.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/FileCommandLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/McpPromptLoader.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/McpPromptLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/prompt-processors/argumentProcessor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/prompt-processors/argumentProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/prompt-processors/shellProcessor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/prompt-processors/shellProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/prompt-processors/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/services/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/test-utils/customMatchers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[602,605],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[602,605],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1488,1491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1488,1491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x1b.","line":20,"column":27,"nodeType":"Literal","messageId":"unexpected","endLine":20,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/// <reference types=\"vitest/globals\" />\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Assertion, expect } from 'vitest';\nimport type { TextBuffer } from '../ui/components/shared/text-buffer.js';\n\n// RegExp to detect invalid characters: backspace, and ANSI escape codes\n// eslint-disable-next-line no-control-regex\nconst invalidCharsRegex = /[\\b\\x1b]/;\n\nfunction toHaveOnlyValidCharacters(this: Assertion, buffer: TextBuffer) {\n   \n  const { isNot } = this as any;\n  let pass = true;\n  const invalidLines: Array<{ line: number; content: string }> = [];\n\n  for (let i = 0; i < buffer.lines.length; i++) {\n    const line = buffer.lines[i];\n    if (line.includes('\\n')) {\n      pass = false;\n      invalidLines.push({ line: i, content: line });\n      break; // Fail fast on newlines\n    }\n    if (invalidCharsRegex.test(line)) {\n      pass = false;\n      invalidLines.push({ line: i, content: line });\n    }\n  }\n\n  return {\n    pass,\n    message: () =>\n      `Expected buffer ${isNot ? 'not ' : ''}to have only valid characters, but found invalid characters in lines:\\n${invalidLines\n        .map((l) => `  [${l.line}]: \"${l.content}\"`) /* This line was changed */\n        .join('\\n')}`,\n    actual: buffer.lines,\n    expected: 'Lines with no line breaks, backspaces, or escape codes.',\n  };\n}\n\nexpect.extend({\n  toHaveOnlyValidCharacters,\n   \n} as any);\n\n// Extend Vitest's `expect` interface with the custom matcher's type definition.\ndeclare module 'vitest' {\n  interface Assertion<T> {\n    toHaveOnlyValidCharacters(): T;\n  }\n  interface AsymmetricMatchersContaining {\n    toHaveOnlyValidCharacters(): void;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/test-utils/mockCommandContext.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/test-utils/mockCommandContext.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1351,1354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1351,1354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1652,1655],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1652,1655],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2314,2317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2314,2317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2327,2330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2327,2330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":85,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2333,2336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2333,2336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { vi } from 'vitest';\nimport { CommandContext } from '../ui/commands/types.js';\nimport { LoadedSettings } from '../config/settings.js';\nimport { GitService } from '@google/gemini-cli-core';\nimport { SessionStatsState } from '../ui/contexts/SessionContext.js';\n\n// A utility type to make all properties of an object, and its nested objects, partial.\ntype DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>;\n    }\n  : T;\n\n/**\n * Creates a deep, fully-typed mock of the CommandContext for use in tests.\n * All functions are pre-mocked with `vi.fn()`.\n *\n * @param overrides - A deep partial object to override any default mock values.\n * @returns A complete, mocked CommandContext object.\n */\nexport const createMockCommandContext = (\n  overrides: DeepPartial<CommandContext> = {},\n): CommandContext => {\n  const defaultMocks: CommandContext = {\n    invocation: {\n      raw: '',\n      name: '',\n      args: '',\n    },\n    services: {\n      config: null,\n      settings: { merged: {} } as LoadedSettings,\n      git: undefined as GitService | undefined,\n      logger: {\n        log: vi.fn(),\n        logMessage: vi.fn(),\n        saveCheckpoint: vi.fn(),\n        loadCheckpoint: vi.fn().mockResolvedValue([]),\n         \n      } as any, // Cast because Logger is a class.\n    },\n    ui: {\n      addItem: vi.fn(),\n      clear: vi.fn(),\n      setDebugMessage: vi.fn(),\n      pendingItem: null,\n      setPendingItem: vi.fn(),\n      loadHistory: vi.fn(),\n      toggleCorgiMode: vi.fn(),\n      toggleVimEnabled: vi.fn(),\n       \n    } as any,\n    session: {\n      sessionShellAllowlist: new Set<string>(),\n      stats: {\n        sessionId: 'test-session',\n        sessionStartTime: new Date(),\n        lastPromptTokenCount: 0,\n        metrics: {\n          models: {},\n          tools: {\n            totalCalls: 0,\n            totalSuccess: 0,\n            totalFail: 0,\n            totalDurationMs: 0,\n            totalDecisions: { accept: 0, reject: 0, modify: 0, auto_accept: 0 },\n            byName: {},\n          },\n          files: {\n            totalLinesAdded: 0,\n            totalLinesRemoved: 0,\n          },\n        },\n      } as SessionStatsState,\n    },\n  };\n\n   \n  const merge = (target: any, source: any): any => {\n    const output = { ...target };\n\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        const sourceValue = source[key];\n        const targetValue = output[key];\n\n        if (\n          // We only want to recursivlty merge plain objects\n          Object.prototype.toString.call(sourceValue) === '[object Object]' &&\n          Object.prototype.toString.call(targetValue) === '[object Object]'\n        ) {\n          output[key] = merge(targetValue, sourceValue);\n        } else {\n          // If not, we do a direct assignment. This preserves Date objects and others.\n          output[key] = sourceValue;\n        }\n      }\n    }\n    return output;\n  };\n\n  return merge(defaultMocks, overrides);\n};\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/test-utils/render.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/App.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12562,12565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12562,12565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":365,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":365,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12586,12589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12586,12589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":366,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12639,12642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12639,12642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":367,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12685,12688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12685,12688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1015,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1015,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32834,32837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32834,32837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1020,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1020,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32962,32965],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32962,32965],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1041,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1041,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33659,33662],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33659,33662],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1046,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1046,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33811,33814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33811,33814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1290,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1290,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[41305,41308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[41305,41308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1317,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1317,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42150,42153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42150,42153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1336,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1336,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[42736,42739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[42736,42739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1361,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1361,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43646,43649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43646,43649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1366,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1366,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[43791,43794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[43791,43794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1388,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1388,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44517,44520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44517,44520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1393,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1393,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[44651,44654],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[44651,44654],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1422,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1422,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[45609,45612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[45609,45612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1451,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1451,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[46560,46563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[46560,46563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1480,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1480,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[47560,47563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[47560,47563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1512,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1512,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[48674,48677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[48674,48677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach, Mock } from 'vitest';\nimport { renderWithProviders } from '../test-utils/render.js';\nimport { AppWrapper as App } from './App.js';\nimport {\n  Config as ServerConfig,\n  MCPServerConfig,\n  ApprovalMode,\n  ToolRegistry,\n  AccessibilitySettings,\n  SandboxConfig,\n  GeminiClient,\n  ideContext,\n  type AuthType,\n} from '@google/gemini-cli-core';\nimport { LoadedSettings, SettingsFile, Settings } from '../config/settings.js';\nimport process from 'node:process';\nimport { useGeminiStream } from './hooks/useGeminiStream.js';\nimport { useConsoleMessages } from './hooks/useConsoleMessages.js';\nimport { StreamingState, ConsoleMessageItem } from './types.js';\nimport { Tips } from './components/Tips.js';\nimport { checkForUpdates, UpdateObject } from './utils/updateCheck.js';\nimport { EventEmitter } from 'events';\nimport { updateEventEmitter } from '../utils/updateEventEmitter.js';\nimport * as auth from '../config/auth.js';\nimport * as useTerminalSize from './hooks/useTerminalSize.js';\n\n// Define a more complete mock server config based on actual Config\ninterface MockServerConfig {\n  apiKey: string;\n  model: string;\n  sandbox?: SandboxConfig;\n  targetDir: string;\n  debugMode: boolean;\n  question?: string;\n  fullContext: boolean;\n  coreTools?: string[];\n  toolDiscoveryCommand?: string;\n  toolCallCommand?: string;\n  mcpServerCommand?: string;\n  mcpServers?: Record<string, MCPServerConfig>; // Use imported MCPServerConfig\n  userAgent: string;\n  userMemory: string;\n  geminiMdFileCount: number;\n  approvalMode: ApprovalMode;\n  vertexai?: boolean;\n  showMemoryUsage?: boolean;\n  accessibility?: AccessibilitySettings;\n  embeddingModel: string;\n\n  getApiKey: Mock<() => string>;\n  getModel: Mock<() => string>;\n  getSandbox: Mock<() => SandboxConfig | undefined>;\n  getTargetDir: Mock<() => string>;\n  getToolRegistry: Mock<() => ToolRegistry>; // Use imported ToolRegistry type\n  getDebugMode: Mock<() => boolean>;\n  getQuestion: Mock<() => string | undefined>;\n  getFullContext: Mock<() => boolean>;\n  getCoreTools: Mock<() => string[] | undefined>;\n  getToolDiscoveryCommand: Mock<() => string | undefined>;\n  getToolCallCommand: Mock<() => string | undefined>;\n  getMcpServerCommand: Mock<() => string | undefined>;\n  getMcpServers: Mock<() => Record<string, MCPServerConfig> | undefined>;\n  getExtensions: Mock<\n    () => Array<{ name: string; version: string; isActive: boolean }>\n  >;\n  getBlockedMcpServers: Mock<\n    () => Array<{ name: string; extensionName: string }>\n  >;\n  getUserAgent: Mock<() => string>;\n  getUserMemory: Mock<() => string>;\n  setUserMemory: Mock<(newUserMemory: string) => void>;\n  getGeminiMdFileCount: Mock<() => number>;\n  setGeminiMdFileCount: Mock<(count: number) => void>;\n  getApprovalMode: Mock<() => ApprovalMode>;\n  setApprovalMode: Mock<(skip: ApprovalMode) => void>;\n  getVertexAI: Mock<() => boolean | undefined>;\n  getShowMemoryUsage: Mock<() => boolean>;\n  getAccessibility: Mock<() => AccessibilitySettings>;\n  getProjectRoot: Mock<() => string | undefined>;\n  getAllGeminiMdFilenames: Mock<() => string[]>;\n  getGeminiClient: Mock<() => GeminiClient | undefined>;\n  getUserTier: Mock<() => Promise<string | undefined>>;\n  getIdeClient: Mock<() => { getCurrentIde: Mock<() => string | undefined> }>;\n  getScreenReader: Mock<() => boolean>;\n  isTrustedFolder?: Mock<() => boolean>;\n  getWorkspaceContext?: Mock<() => { getDirectories: Mock<() => string[]> }>;\n}\n\n// Mock @google/gemini-cli-core and its Config class\nvi.mock('@google/gemini-cli-core', async (importOriginal) => {\n  const actualCore =\n    await importOriginal<typeof import('@google/gemini-cli-core')>();\n  const ConfigClassMock = vi\n    .fn()\n    .mockImplementation((optionsPassedToConstructor) => {\n      const opts = { ...optionsPassedToConstructor }; // Clone\n      // Basic mock structure, will be extended by the instance in tests\n      return {\n        apiKey: opts.apiKey || 'test-key',\n        model: opts.model || 'test-model-in-mock-factory',\n        sandbox: opts.sandbox,\n        targetDir: opts.targetDir || '/test/dir',\n        debugMode: opts.debugMode || false,\n        question: opts.question,\n        fullContext: opts.fullContext ?? false,\n        coreTools: opts.coreTools,\n        toolDiscoveryCommand: opts.toolDiscoveryCommand,\n        toolCallCommand: opts.toolCallCommand,\n        mcpServerCommand: opts.mcpServerCommand,\n        mcpServers: opts.mcpServers,\n        userAgent: opts.userAgent || 'test-agent',\n        userMemory: opts.userMemory || '',\n        geminiMdFileCount: opts.geminiMdFileCount || 0,\n        approvalMode: opts.approvalMode ?? ApprovalMode.DEFAULT,\n        vertexai: opts.vertexai,\n        showMemoryUsage: opts.showMemoryUsage ?? false,\n        accessibility: opts.accessibility ?? {},\n        embeddingModel: opts.embeddingModel || 'test-embedding-model',\n\n        getApiKey: vi.fn(() => opts.apiKey || 'test-key'),\n        getModel: vi.fn(() => opts.model || 'test-model-in-mock-factory'),\n        getSandbox: vi.fn(() => opts.sandbox),\n        getTargetDir: vi.fn(() => opts.targetDir || '/test/dir'),\n        getToolRegistry: vi.fn(() => ({}) as ToolRegistry), // Simple mock\n        getDebugMode: vi.fn(() => opts.debugMode || false),\n        getQuestion: vi.fn(() => opts.question),\n        getFullContext: vi.fn(() => opts.fullContext ?? false),\n        getCoreTools: vi.fn(() => opts.coreTools),\n        getToolDiscoveryCommand: vi.fn(() => opts.toolDiscoveryCommand),\n        getToolCallCommand: vi.fn(() => opts.toolCallCommand),\n        getMcpServerCommand: vi.fn(() => opts.mcpServerCommand),\n        getMcpServers: vi.fn(() => opts.mcpServers),\n        getPromptRegistry: vi.fn(),\n        getExtensions: vi.fn(() => []),\n        getBlockedMcpServers: vi.fn(() => []),\n        getUserAgent: vi.fn(() => opts.userAgent || 'test-agent'),\n        getUserMemory: vi.fn(() => opts.userMemory || ''),\n        setUserMemory: vi.fn(),\n        getGeminiMdFileCount: vi.fn(() => opts.geminiMdFileCount || 0),\n        setGeminiMdFileCount: vi.fn(),\n        getApprovalMode: vi.fn(() => opts.approvalMode ?? ApprovalMode.DEFAULT),\n        setApprovalMode: vi.fn(),\n        getVertexAI: vi.fn(() => opts.vertexai),\n        getShowMemoryUsage: vi.fn(() => opts.showMemoryUsage ?? false),\n        getAccessibility: vi.fn(() => opts.accessibility ?? {}),\n        getProjectRoot: vi.fn(() => opts.targetDir),\n        getEnablePromptCompletion: vi.fn(() => false),\n        getGeminiClient: vi.fn(() => ({\n          getUserTier: vi.fn(),\n        })),\n        getCheckpointingEnabled: vi.fn(() => opts.checkpointing ?? true),\n        getAllGeminiMdFilenames: vi.fn(() => ['GEMINI.md']),\n        setFlashFallbackHandler: vi.fn(),\n        getSessionId: vi.fn(() => 'test-session-id'),\n        getUserTier: vi.fn().mockResolvedValue(undefined),\n        getIdeMode: vi.fn(() => true),\n        getWorkspaceContext: vi.fn(() => ({\n          getDirectories: vi.fn(() => []),\n        })),\n        getIdeClient: vi.fn(() => ({\n          getCurrentIde: vi.fn(() => 'vscode'),\n          getDetectedIdeDisplayName: vi.fn(() => 'VSCode'),\n          addStatusChangeListener: vi.fn(),\n          removeStatusChangeListener: vi.fn(),\n          getConnectionStatus: vi.fn(() => 'connected'),\n        })),\n        isTrustedFolder: vi.fn(() => true),\n        getScreenReader: vi.fn(() => false),\n      };\n    });\n\n  const ideContextMock = {\n    getIdeContext: vi.fn(),\n    subscribeToIdeContext: vi.fn(() => vi.fn()), // subscribe returns an unsubscribe function\n  };\n\n  return {\n    ...actualCore,\n    Config: ConfigClassMock,\n    MCPServerConfig: actualCore.MCPServerConfig,\n    getAllGeminiMdFilenames: vi.fn(() => ['GEMINI.md']),\n    ideContext: ideContextMock,\n    isGitRepository: vi.fn(),\n  };\n});\n\n// Mock heavy dependencies or those with side effects\nvi.mock('./hooks/useGeminiStream', () => ({\n  useGeminiStream: vi.fn(() => ({\n    streamingState: 'Idle',\n    submitQuery: vi.fn(),\n    initError: null,\n    pendingHistoryItems: [],\n    thought: null,\n  })),\n}));\n\nvi.mock('./hooks/useAuthCommand', () => ({\n  useAuthCommand: vi.fn(() => ({\n    isAuthDialogOpen: false,\n    openAuthDialog: vi.fn(),\n    handleAuthSelect: vi.fn(),\n    handleAuthHighlight: vi.fn(),\n    isAuthenticating: false,\n    cancelAuthentication: vi.fn(),\n  })),\n}));\n\nvi.mock('./hooks/useFolderTrust', () => ({\n  useFolderTrust: vi.fn(() => ({\n    isFolderTrustDialogOpen: false,\n    handleFolderTrustSelect: vi.fn(),\n    isRestarting: false,\n  })),\n}));\n\nvi.mock('./hooks/useLogger', () => ({\n  useLogger: vi.fn(() => ({\n    getPreviousUserMessages: vi.fn().mockResolvedValue([]),\n  })),\n}));\n\nvi.mock('./hooks/useConsoleMessages.js', () => ({\n  useConsoleMessages: vi.fn(() => ({\n    consoleMessages: [],\n    handleNewMessage: vi.fn(),\n    clearConsoleMessages: vi.fn(),\n  })),\n}));\n\nvi.mock('../config/config.js', async (importOriginal) => {\n  const actual = await importOriginal();\n  return {\n    // @ts-expect-error - this is fine\n    ...actual,\n    loadHierarchicalGeminiMemory: vi\n      .fn()\n      .mockResolvedValue({ memoryContent: '', fileCount: 0 }),\n  };\n});\n\nvi.mock('./components/Tips.js', () => ({\n  Tips: vi.fn(() => null),\n}));\n\nvi.mock('./components/Header.js', () => ({\n  Header: vi.fn(() => null),\n}));\n\nvi.mock('./utils/updateCheck.js', () => ({\n  checkForUpdates: vi.fn(),\n}));\n\nvi.mock('../config/auth.js', () => ({\n  validateAuthMethod: vi.fn(),\n}));\n\nvi.mock('../hooks/useTerminalSize.js', () => ({\n  useTerminalSize: vi.fn(),\n}));\n\nconst mockedCheckForUpdates = vi.mocked(checkForUpdates);\nconst { isGitRepository: mockedIsGitRepository } = vi.mocked(\n  await import('@google/gemini-cli-core'),\n);\n\nvi.mock('node:child_process');\n\ndescribe('App UI', () => {\n  let mockConfig: MockServerConfig;\n  let mockSettings: LoadedSettings;\n  let mockVersion: string;\n  let currentUnmount: (() => void) | undefined;\n\n  const createMockSettings = (\n    settings: {\n      system?: Partial<Settings>;\n      user?: Partial<Settings>;\n      workspace?: Partial<Settings>;\n    } = {},\n  ): LoadedSettings => {\n    const systemSettingsFile: SettingsFile = {\n      path: '/system/settings.json',\n      settings: settings.system || {},\n    };\n    const userSettingsFile: SettingsFile = {\n      path: '/user/settings.json',\n      settings: settings.user || {},\n    };\n    const workspaceSettingsFile: SettingsFile = {\n      path: '/workspace/.gemini/settings.json',\n      settings: settings.workspace || {},\n    };\n    return new LoadedSettings(\n      systemSettingsFile,\n      userSettingsFile,\n      workspaceSettingsFile,\n      [],\n      true,\n    );\n  };\n\n  beforeEach(() => {\n    vi.spyOn(useTerminalSize, 'useTerminalSize').mockReturnValue({\n      columns: 120,\n      rows: 24,\n    });\n\n    const ServerConfigMocked = vi.mocked(ServerConfig, true);\n    mockConfig = new ServerConfigMocked({\n      embeddingModel: 'test-embedding-model',\n      sandbox: undefined,\n      targetDir: '/test/dir',\n      debugMode: false,\n      userMemory: '',\n      geminiMdFileCount: 0,\n      showMemoryUsage: false,\n      sessionId: 'test-session-id',\n      cwd: '/tmp',\n      model: 'model',\n    }) as unknown as MockServerConfig;\n    mockVersion = '0.0.0-test';\n\n    // Ensure the getShowMemoryUsage mock function is specifically set up if not covered by constructor mock\n    if (!mockConfig.getShowMemoryUsage) {\n      mockConfig.getShowMemoryUsage = vi.fn(() => false);\n    }\n    mockConfig.getShowMemoryUsage.mockReturnValue(false); // Default for most tests\n\n    // Ensure a theme is set so the theme dialog does not appear.\n    mockSettings = createMockSettings({ workspace: { theme: 'Default' } });\n\n    // Ensure getWorkspaceContext is available if not added by the constructor\n    if (!mockConfig.getWorkspaceContext) {\n      mockConfig.getWorkspaceContext = vi.fn(() => ({\n        getDirectories: vi.fn(() => ['/test/dir']),\n      }));\n    }\n    if (!mockConfig.isTrustedFolder) {\n      mockConfig.isTrustedFolder = vi.fn(() => true);\n    }\n    vi.mocked(ideContext.getIdeContext).mockReturnValue(undefined);\n  });\n\n  afterEach(() => {\n    if (currentUnmount) {\n      currentUnmount();\n      currentUnmount = undefined;\n    }\n    vi.clearAllMocks(); // Clear mocks after each test\n  });\n\n  describe('handleAutoUpdate', () => {\n    let spawnEmitter: EventEmitter;\n\n    beforeEach(async () => {\n      const { spawn } = await import('node:child_process');\n  spawnEmitter = new EventEmitter() as any;\n  (spawnEmitter as any).stdout = new EventEmitter();\n  (spawnEmitter as any).stderr = new EventEmitter();\n  (spawn as any).mockReturnValue(spawnEmitter);\n    });\n\n    afterEach(() => {\n  delete process.env['GEMINI_CLI_DISABLE_AUTOUPDATER'];\n    });\n\n    it('should not start the update process when running from git', async () => {\n      mockedIsGitRepository.mockResolvedValue(true);\n        const info: UpdateObject = {\n          update: {\n            name: '@google/gemini-cli',\n            latest: '1.1.0',\n            current: '1.0.0',\n            type: 'latest',\n          },\n          message: 'Gemini CLI update available!',\n        };\n      mockedCheckForUpdates.mockResolvedValue(info);\n      const { spawn } = await import('node:child_process');\n\n      const { unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      await new Promise((resolve) => setTimeout(resolve, 10));\n\n      expect(spawn).not.toHaveBeenCalled();\n    });\n\n    it('should show a success message when update succeeds', async () => {\n      mockedIsGitRepository.mockResolvedValue(false);\n        const info: UpdateObject = {\n          update: {\n            name: '@google/gemini-cli',\n            latest: '1.1.0',\n            current: '1.0.0',\n            type: 'latest',\n          },\n          message: 'Update available',\n        };\n      mockedCheckForUpdates.mockResolvedValue(info);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      updateEventEmitter.emit('update-success', info);\n\n      await new Promise((resolve) => setTimeout(resolve, 10));\n\n      expect(lastFrame()).toContain(\n        'Update successful! The new version will be used on your next run.',\n      );\n    });\n\n    it('should show an error message when update fails', async () => {\n      mockedIsGitRepository.mockResolvedValue(false);\n        const info: UpdateObject = {\n          update: {\n            name: '@google/gemini-cli',\n            latest: '1.1.0',\n            current: '1.0.0',\n            type: 'latest',\n          },\n          message: 'Update available',\n        };\n      mockedCheckForUpdates.mockResolvedValue(info);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      updateEventEmitter.emit('update-failed', info);\n\n      await new Promise((resolve) => setTimeout(resolve, 10));\n\n      expect(lastFrame()).toContain(\n        'Automatic update failed. Please try updating manually',\n      );\n    });\n\n    it('should show an error message when spawn fails', async () => {\n      mockedIsGitRepository.mockResolvedValue(false);\n        const info: UpdateObject = {\n          update: {\n            name: '@google/gemini-cli',\n            latest: '1.1.0',\n            current: '1.0.0',\n            type: 'latest',\n          },\n          message: 'Update available',\n        };\n      mockedCheckForUpdates.mockResolvedValue(info);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // We are testing the App's reaction to an `update-failed` event,\n      // which is what should be emitted when a spawn error occurs elsewhere.\n      updateEventEmitter.emit('update-failed', info);\n\n      await new Promise((resolve) => setTimeout(resolve, 10));\n\n      expect(lastFrame()).toContain(\n        'Automatic update failed. Please try updating manually',\n      );\n    });\n\n    it('should not auto-update if GEMINI_CLI_DISABLE_AUTOUPDATER is true', async () => {\n      mockedIsGitRepository.mockResolvedValue(false);\n    process.env['GEMINI_CLI_DISABLE_AUTOUPDATER'] = 'true';\n      const info: UpdateObject = {\n        update: {\n          name: '@google/gemini-cli',\n          latest: '1.1.0',\n          current: '1.0.0',\n          type: 'latest',\n        },\n        message: 'Update available',\n      };\n      mockedCheckForUpdates.mockResolvedValue(info);\n      const { spawn } = await import('node:child_process');\n\n      const { unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      await new Promise((resolve) => setTimeout(resolve, 10));\n\n      expect(spawn).not.toHaveBeenCalled();\n    });\n  });\n\n  it('should display active file when available', async () => {\n    vi.mocked(ideContext.getIdeContext).mockReturnValue({\n      workspaceState: {\n        openFiles: [\n          {\n            path: '/path/to/my-file.ts',\n            isActive: true,\n            selectedText: 'hello',\n            timestamp: 0,\n          },\n        ],\n      },\n    });\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('1 open file (ctrl+g to view)');\n  });\n\n  it('should not display any files when not available', async () => {\n    vi.mocked(ideContext.getIdeContext).mockReturnValue({\n      workspaceState: {\n        openFiles: [],\n      },\n    });\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).not.toContain('Open File');\n  });\n\n  it('should display active file and other open files', async () => {\n    vi.mocked(ideContext.getIdeContext).mockReturnValue({\n      workspaceState: {\n        openFiles: [\n          {\n            path: '/path/to/my-file.ts',\n            isActive: true,\n            selectedText: 'hello',\n            timestamp: 0,\n          },\n          {\n            path: '/path/to/another-file.ts',\n            isActive: false,\n            timestamp: 1,\n          },\n          {\n            path: '/path/to/third-file.ts',\n            isActive: false,\n            timestamp: 2,\n          },\n        ],\n      },\n    });\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('3 open files (ctrl+g to view)');\n  });\n\n  it('should display active file and other context', async () => {\n    vi.mocked(ideContext.getIdeContext).mockReturnValue({\n      workspaceState: {\n        openFiles: [\n          {\n            path: '/path/to/my-file.ts',\n            isActive: true,\n            selectedText: 'hello',\n            timestamp: 0,\n          },\n        ],\n      },\n    });\n    mockConfig.getGeminiMdFileCount.mockReturnValue(1);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue(['GEMINI.md']);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain(\n      'Using: 1 open file (ctrl+g to view) | 1 GEMINI.md file',\n    );\n  });\n\n  it('should display default \"GEMINI.md\" in footer when contextFileName is not set and count is 1', async () => {\n    mockConfig.getGeminiMdFileCount.mockReturnValue(1);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue(['GEMINI.md']);\n    // For this test, ensure showMemoryUsage is false or debugMode is false if it relies on that\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve(); // Wait for any async updates\n    expect(lastFrame()).toContain('Using: 1 GEMINI.md file');\n  });\n\n  it('should display default \"GEMINI.md\" with plural when contextFileName is not set and count is > 1', async () => {\n    mockConfig.getGeminiMdFileCount.mockReturnValue(2);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue([\n      'GEMINI.md',\n      'GEMINI.md',\n    ]);\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('Using: 2 GEMINI.md files');\n  });\n\n  it('should display custom contextFileName in footer when set and count is 1', async () => {\n    mockSettings = createMockSettings({\n      workspace: { contextFileName: 'AGENTS.md', theme: 'Default' },\n    });\n    mockConfig.getGeminiMdFileCount.mockReturnValue(1);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue(['AGENTS.md']);\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('Using: 1 AGENTS.md file');\n  });\n\n  it('should display a generic message when multiple context files with different names are provided', async () => {\n    mockSettings = createMockSettings({\n      workspace: {\n        contextFileName: ['AGENTS.md', 'CONTEXT.md'],\n        theme: 'Default',\n      },\n    });\n    mockConfig.getGeminiMdFileCount.mockReturnValue(2);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue([\n      'AGENTS.md',\n      'CONTEXT.md',\n    ]);\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('Using: 2 context files');\n  });\n\n  it('should display custom contextFileName with plural when set and count is > 1', async () => {\n    mockSettings = createMockSettings({\n      workspace: { contextFileName: 'MY_NOTES.TXT', theme: 'Default' },\n    });\n    mockConfig.getGeminiMdFileCount.mockReturnValue(3);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue([\n      'MY_NOTES.TXT',\n      'MY_NOTES.TXT',\n      'MY_NOTES.TXT',\n    ]);\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('Using: 3 MY_NOTES.TXT files');\n  });\n\n  it('should not display context file message if count is 0, even if contextFileName is set', async () => {\n    mockSettings = createMockSettings({\n      workspace: { contextFileName: 'ANY_FILE.MD', theme: 'Default' },\n    });\n    mockConfig.getGeminiMdFileCount.mockReturnValue(0);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue([]);\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).not.toContain('ANY_FILE.MD');\n  });\n\n  it('should display GEMINI.md and MCP server count when both are present', async () => {\n    mockConfig.getGeminiMdFileCount.mockReturnValue(2);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue([\n      'GEMINI.md',\n      'GEMINI.md',\n    ]);\n    mockConfig.getMcpServers.mockReturnValue({\n      server1: {} as MCPServerConfig,\n    });\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('1 MCP server');\n  });\n\n  it('should display only MCP server count when GEMINI.md count is 0', async () => {\n    mockConfig.getGeminiMdFileCount.mockReturnValue(0);\n    mockConfig.getAllGeminiMdFilenames.mockReturnValue([]);\n    mockConfig.getMcpServers.mockReturnValue({\n      server1: {} as MCPServerConfig,\n      server2: {} as MCPServerConfig,\n    });\n    mockConfig.getDebugMode.mockReturnValue(false);\n    mockConfig.getShowMemoryUsage.mockReturnValue(false);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(lastFrame()).toContain('Using: 2 MCP servers (ctrl+t to view)');\n  });\n\n  it('should display Tips component by default', async () => {\n    const { unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(vi.mocked(Tips)).toHaveBeenCalled();\n  });\n\n  it('should not display Tips component when hideTips is true', async () => {\n    mockSettings = createMockSettings({\n      workspace: {\n        hideTips: true,\n      },\n    });\n\n    const { unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(vi.mocked(Tips)).not.toHaveBeenCalled();\n  });\n\n  it('should display Header component by default', async () => {\n    const { Header } = await import('./components/Header.js');\n    const { unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(vi.mocked(Header)).toHaveBeenCalled();\n  });\n\n  it('should not display Header component when hideBanner is true', async () => {\n    const { Header } = await import('./components/Header.js');\n    mockSettings = createMockSettings({\n      user: { hideBanner: true },\n    });\n\n    const { unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(vi.mocked(Header)).not.toHaveBeenCalled();\n  });\n\n  it('should display Footer component by default', async () => {\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    // Footer should render - look for target directory which is always shown\n    expect(lastFrame()).toContain('/test/dir');\n  });\n\n  it('should not display Footer component when hideFooter is true', async () => {\n    mockSettings = createMockSettings({\n      user: { hideFooter: true },\n    });\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    // Footer should not render - target directory should not appear\n    expect(lastFrame()).not.toContain('/test/dir');\n  });\n\n  it('should show footer if system says show, but workspace and user settings say hide', async () => {\n    mockSettings = createMockSettings({\n      system: { hideFooter: false },\n      user: { hideFooter: true },\n      workspace: { hideFooter: true },\n    });\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    // Footer should render because system overrides - look for target directory\n    expect(lastFrame()).toContain('/test/dir');\n  });\n\n  it('should show tips if system says show, but workspace and user settings say hide', async () => {\n    mockSettings = createMockSettings({\n      system: { hideTips: false },\n      user: { hideTips: true },\n      workspace: { hideTips: true },\n    });\n\n    const { unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    await Promise.resolve();\n    expect(vi.mocked(Tips)).toHaveBeenCalled();\n  });\n\n  describe('when no theme is set', () => {\n    let originalNoColor: string | undefined;\n\n    beforeEach(() => {\n  originalNoColor = process.env['NO_COLOR'];\n      // Ensure no theme is set for these tests\n      mockSettings = createMockSettings({});\n      mockConfig.getDebugMode.mockReturnValue(false);\n      mockConfig.getShowMemoryUsage.mockReturnValue(false);\n    });\n\n    afterEach(() => {\n  process.env['NO_COLOR'] = originalNoColor as string | undefined;\n    });\n\n    it('should display theme dialog if NO_COLOR is not set', async () => {\n  delete process.env['NO_COLOR'];\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      expect(lastFrame()).toContain(\"I'm Feeling Lucky (esc to cancel\");\n    });\n\n    it('should display a message if NO_COLOR is set', async () => {\n  process.env['NO_COLOR'] = 'true';\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      expect(lastFrame()).toContain(\"I'm Feeling Lucky (esc to cancel\");\n      expect(lastFrame()).not.toContain('Select Theme');\n    });\n  });\n\n  it('should render the initial UI correctly', () => {\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    expect(lastFrame()).toMatchSnapshot();\n  });\n\n  it('should render correctly with the prompt input box', () => {\n  vi.mocked(useGeminiStream).mockReturnValue(({\n      streamingState: StreamingState.Idle,\n      submitQuery: (async () => {}) as any,\n      initError: null,\n      pendingHistoryItems: [],\n      thought: null,\n      cancelOngoingRequest: () => {},\n    }) as any);\n\n    const { lastFrame, unmount } = renderWithProviders(\n      <App\n        config={mockConfig as unknown as ServerConfig}\n        settings={mockSettings}\n        version={mockVersion}\n      />,\n    );\n    currentUnmount = unmount;\n    expect(lastFrame()).toMatchSnapshot();\n  });\n\n  describe('with initial prompt from --prompt-interactive', () => {\n    it('should submit the initial prompt automatically', async () => {\n      const mockSubmitQuery = vi.fn();\n\n      mockConfig.getQuestion = vi.fn(() => 'hello from prompt-interactive');\n\n    vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Idle,\n        submitQuery: (mockSubmitQuery as unknown) as (q: any) => Promise<void>,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      mockConfig.getGeminiClient.mockReturnValue({\n        isInitialized: vi.fn(() => true),\n        getUserTier: vi.fn(),\n      } as unknown as GeminiClient);\n\n      const { unmount, rerender } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // Force a re-render to trigger useEffect\n      rerender(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n\n      await new Promise((resolve) => setTimeout(resolve, 0));\n\n      expect(mockSubmitQuery).toHaveBeenCalledWith(\n        'hello from prompt-interactive',\n      );\n    });\n  });\n\n  describe('errorCount', () => {\n    it('should correctly sum the counts of error messages', async () => {\n      const mockConsoleMessages: ConsoleMessageItem[] = [\n        { type: 'error', content: 'First error', count: 1 },\n        { type: 'log', content: 'some log', count: 1 },\n        { type: 'error', content: 'Second error', count: 3 },\n        { type: 'warn', content: 'a warning', count: 1 },\n        { type: 'error', content: 'Third error', count: 1 },\n      ];\n\n      vi.mocked(useConsoleMessages).mockReturnValue({\n        consoleMessages: mockConsoleMessages,\n        handleNewMessage: vi.fn(),\n        clearConsoleMessages: vi.fn(),\n      });\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n      await Promise.resolve();\n\n      // Total error count should be 1 + 3 + 1 = 5\n      expect(lastFrame()).toContain('5 errors');\n    });\n  });\n\n  describe('auth validation', () => {\n    it('should call validateAuthMethod when useExternalAuth is false', async () => {\n      const validateAuthMethodSpy = vi.spyOn(auth, 'validateAuthMethod');\n      mockSettings = createMockSettings({\n        workspace: {\n          selectedAuthType: 'USE_GEMINI' as AuthType,\n          useExternalAuth: false,\n          theme: 'Default',\n        },\n      });\n\n      const { unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      expect(validateAuthMethodSpy).toHaveBeenCalledWith('USE_GEMINI');\n    });\n\n    it('should NOT call validateAuthMethod when useExternalAuth is true', async () => {\n      const validateAuthMethodSpy = vi.spyOn(auth, 'validateAuthMethod');\n      mockSettings = createMockSettings({\n        workspace: {\n          selectedAuthType: 'USE_GEMINI' as AuthType,\n          useExternalAuth: true,\n          theme: 'Default',\n        },\n      });\n\n      const { unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      expect(validateAuthMethodSpy).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('when in a narrow terminal', () => {\n    it('should render with a column layout', () => {\n      vi.spyOn(useTerminalSize, 'useTerminalSize').mockReturnValue({\n        columns: 60,\n        rows: 24,\n      });\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n      expect(lastFrame()).toMatchSnapshot();\n    });\n  });\n\n  describe('NO_COLOR smoke test', () => {\n    let originalNoColor: string | undefined;\n\n    beforeEach(() => {\n      originalNoColor = process.env['NO_COLOR'];\n    });\n\n    afterEach(() => {\n      process.env['NO_COLOR'] = originalNoColor as string | undefined;\n    });\n\n    it('should render without errors when NO_COLOR is set', async () => {\n  process.env['NO_COLOR'] = 'true';\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      expect(lastFrame()).toBeTruthy();\n      expect(lastFrame()).toContain('Type your message or @path/to/file');\n    });\n  });\n\n  describe('FolderTrustDialog', () => {\n    it('should display the folder trust dialog when isFolderTrustDialogOpen is true', async () => {\n      const { useFolderTrust } = await import('./hooks/useFolderTrust.js');\n      vi.mocked(useFolderTrust).mockReturnValue({\n        isTrusted: undefined,\n        isFolderTrustDialogOpen: true,\n        handleFolderTrustSelect: vi.fn(),\n        isRestarting: false,\n      });\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n      await Promise.resolve();\n      expect(lastFrame()).toContain('Do you trust this folder?');\n    });\n\n    it('should display the folder trust dialog when the feature is enabled but the folder is not trusted', async () => {\n      const { useFolderTrust } = await import('./hooks/useFolderTrust.js');\n      vi.mocked(useFolderTrust).mockReturnValue({\n        isTrusted: undefined,\n        isFolderTrustDialogOpen: true,\n        handleFolderTrustSelect: vi.fn(),\n        isRestarting: false,\n      });\n  mockConfig.isTrustedFolder?.mockReturnValue(false);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n      await Promise.resolve();\n      expect(lastFrame()).toContain('Do you trust this folder?');\n    });\n\n    it('should not display the folder trust dialog when the feature is disabled', async () => {\n      const { useFolderTrust } = await import('./hooks/useFolderTrust.js');\n      vi.mocked(useFolderTrust).mockReturnValue({\n        isTrusted: undefined,\n        isFolderTrustDialogOpen: false,\n        handleFolderTrustSelect: vi.fn(),\n        isRestarting: false,\n      });\n  mockConfig.isTrustedFolder?.mockReturnValue(false);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n      await Promise.resolve();\n      expect(lastFrame()).not.toContain('Do you trust this folder?');\n    });\n  });\n\n  describe('Message Queuing', () => {\n    let mockSubmitQuery: typeof vi.fn;\n\n    beforeEach(() => {\n      mockSubmitQuery = vi.fn();\n      vi.useFakeTimers();\n    });\n\n    afterEach(() => {\n      vi.useRealTimers();\n    });\n\n    it('should queue messages when handleFinalSubmit is called during streaming', () => {\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Responding,\n        submitQuery: mockSubmitQuery,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // The message should not be sent immediately during streaming\n      expect(mockSubmitQuery).not.toHaveBeenCalled();\n    });\n\n    it('should auto-send queued messages when transitioning from Responding to Idle', async () => {\n  const mockSubmitQueryFn = vi.fn();\n  void mockSubmitQueryFn;\n\n      // Start with Responding state\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Responding,\n        submitQuery: mockSubmitQueryFn,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { unmount, rerender } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // Simulate the hook returning Idle state (streaming completed)\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Idle,\n        submitQuery: mockSubmitQueryFn,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      // Rerender to trigger the useEffect with new state\n      rerender(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n\n      // The effect uses setTimeout(100ms) before sending\n      await vi.advanceTimersByTimeAsync(100);\n\n      // Note: In the actual implementation, messages would be queued first\n      // This test verifies the auto-send mechanism works when state transitions\n    });\n\n    it('should display queued messages with dimmed color', () => {\n      // This test would require being able to simulate handleFinalSubmit\n      // and then checking the rendered output for the queued messages\n      // with the  prefix and dimColor styling\n\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Responding,\n        submitQuery: mockSubmitQuery as any,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: 'Processing...',\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { unmount, lastFrame } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // The actual queued messages display is tested visually\n      // since we need to trigger handleFinalSubmit which is internal\n      const output = lastFrame();\n      expect(output).toBeDefined();\n    });\n\n    it('should clear message queue after sending', async () => {\n\n      // Start with idle to allow message queue to process\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Idle,\n        submitQuery: (async () => {}) as any,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { unmount, lastFrame } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // After sending, the queue should be cleared\n      // This is handled internally by setMessageQueue([]) in the useEffect\n      await vi.advanceTimersByTimeAsync(100);\n\n      // Verify the component renders without errors\n      expect(lastFrame()).toBeDefined();\n    });\n\n    it('should handle empty messages by filtering them out', () => {\n      // The handleFinalSubmit function trims and checks if length > 0\n      // before adding to queue, so empty messages are filtered\n\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Idle,\n        submitQuery: mockSubmitQuery,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n  }) as any);\n\n      const { unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // Empty or whitespace-only messages won't be added to queue\n      // This is enforced by the trimmedValue.length > 0 check\n      expect(mockSubmitQuery).not.toHaveBeenCalled();\n    });\n\n    it('should combine multiple queued messages with double newlines', async () => {\n      // This test verifies that when multiple messages are queued,\n      // they are combined with '\\n\\n' as the separator\n\n      const mockSubmitQueryFn = vi.fn();\n\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Idle,\n        submitQuery: mockSubmitQueryFn,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: null,\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { unmount, lastFrame } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      // The combining logic uses messageQueue.join('\\n\\n')\n      // This is tested by the implementation in the useEffect\n      await vi.advanceTimersByTimeAsync(100);\n\n      expect(lastFrame()).toBeDefined();\n    });\n\n    it('should limit displayed messages to MAX_DISPLAYED_QUEUED_MESSAGES', () => {\n      // This test verifies the display logic handles multiple messages correctly\n      // by checking that the MAX_DISPLAYED_QUEUED_MESSAGES constant is respected\n\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Responding,\n        submitQuery: mockSubmitQuery,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: 'Processing...',\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      const output = lastFrame();\n\n      // Verify the display logic exists and can handle multiple messages\n      // The actual queue behavior is tested in the useMessageQueue hook tests\n      expect(output).toBeDefined();\n\n      // Check that the component renders without errors when there are messages to display\n      expect(output).not.toContain('Error');\n    });\n\n    it('should render message queue display without errors', () => {\n      // Test that the message queue display logic renders correctly\n      // This verifies the UI changes for performance improvements work\n\n  vi.mocked(useGeminiStream).mockReturnValue(({\n        streamingState: StreamingState.Responding,\n        submitQuery: mockSubmitQuery,\n        initError: null,\n        pendingHistoryItems: [],\n        thought: 'Processing...',\n        cancelOngoingRequest: () => {},\n  }) as any);\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      const output = lastFrame();\n\n      // Verify component renders without errors\n      expect(output).toBeDefined();\n      expect(output).not.toContain('Error');\n\n      // Verify the component structure is intact (loading indicator should be present)\n      expect(output).toContain('esc to cancel');\n    });\n  });\n\n  describe('debug keystroke logging', () => {\n    let consoleLogSpy: ReturnType<typeof vi.spyOn>;\n\n    beforeEach(() => {\n      consoleLogSpy = vi.spyOn(console, 'log').mockImplementation(() => {});\n    });\n\n    afterEach(() => {\n      consoleLogSpy.mockRestore();\n    });\n\n    it('should pass debugKeystrokeLogging setting to KeypressProvider', () => {\n      const mockSettingsWithDebug = createMockSettings({\n        workspace: {\n          theme: 'Default',\n          debugKeystrokeLogging: true,\n        },\n      });\n\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettingsWithDebug}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      const output = lastFrame();\n\n      expect(output).toBeDefined();\n      expect(mockSettingsWithDebug.merged.debugKeystrokeLogging).toBe(true);\n    });\n\n    it('should use default false value when debugKeystrokeLogging is not set', () => {\n      const { lastFrame, unmount } = renderWithProviders(\n        <App\n          config={mockConfig as unknown as ServerConfig}\n          settings={mockSettings}\n          version={mockVersion}\n        />,\n      );\n      currentUnmount = unmount;\n\n      const output = lastFrame();\n\n      expect(output).toBeDefined();\n      expect(mockSettings.merged.debugKeystrokeLogging).toBeUndefined();\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/IdeIntegrationNudge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/colors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/aboutCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/aboutCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/authCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/authCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/bugCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/bugCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/chatCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/chatCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/clearCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/clearCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/compressCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/compressCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/copyCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/copyCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/corgiCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/corgiCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/directoryCommand.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/directoryCommand.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/docsCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/docsCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/editorCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/editorCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/extensionsCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/extensionsCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/helpCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/helpCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/ideCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/ideCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/initCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/initCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/mcpCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/mcpCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/memoryCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/memoryCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/mewCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/privacyCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/privacyCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/quitCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/quitCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/restoreCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/restoreCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/settingsCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/settingsCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/setupGithubCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/setupGithubCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/statsCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/statsCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/terminalSetupCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/terminalSetupCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/themeCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/themeCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/toolsCommand.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/toolsCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/commands/vimCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/AboutBox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/AsciiArt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/AuthDialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/AuthDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/AuthInProgress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/AutoAcceptIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ConsoleSummaryDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ContextSummaryDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ContextSummaryDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ContextUsageDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/DebugProfiler.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/DetailedMessagesDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/EditorSettingsDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/FolderTrustDialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/FolderTrustDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/Footer.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/Footer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/GeminiRespondingSpinner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/Header.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/Help.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/HistoryItemDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/HistoryItemDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/InputPrompt.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/InputPrompt.tsx","messages":[],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x1b.","line":758,"column":43,"nodeType":"Literal","messageId":"unexpected","endLine":758,"endColumn":60,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/LoadingIndicator.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/LoadingIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/MemoryUsageDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ModelStatsDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ModelStatsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/PrepareLabel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/SessionSummaryDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/SessionSummaryDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/SettingsDialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/SettingsDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ShellConfirmationDialog.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ShellConfirmationDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ShellModeIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ShowMoreLines.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/StatsDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/StatsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/SuggestionsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ThemeDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/Tips.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ToolStatsDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/ToolStatsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/UpdateNotification.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/CompressionMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/DiffRenderer.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/DiffRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/ErrorMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/GeminiMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/GeminiMessageContent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/InfoMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/ToolConfirmationMessage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/ToolConfirmationMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/ToolGroupMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/ToolMessage.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/ToolMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/UserMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/messages/UserShellMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/MaxSizedBox.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/MaxSizedBox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/RadioButtonSelect.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/RadioButtonSelect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/text-buffer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/text-buffer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/vim-buffer-actions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/components/shared/vim-buffer-actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/KeypressContext.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/KeypressContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/OverflowContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/SessionContext.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/SessionContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/SettingsContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/StreamingContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/contexts/VimModeContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/editors/editorSettingsManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/atCommandProcessor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/atCommandProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/shellCommandProcessor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/shellCommandProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/slashCommandProcessor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/slashCommandProcessor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useAtCompletion.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useAtCompletion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useAuthCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useAutoAcceptIndicator.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":121,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3944,3947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3944,3947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  describe,\n  it,\n  expect,\n  vi,\n  beforeEach,\n  type MockedFunction,\n  type Mock,\n} from 'vitest';\nimport { renderHook, act } from '@testing-library/react';\nimport { useAutoAcceptIndicator } from './useAutoAcceptIndicator.js';\n\nimport {\n  Config,\n  Config as ActualConfigType,\n  ApprovalMode,\n} from '@google/gemini-cli-core';\nimport { useKeypress, Key } from './useKeypress.js';\n\nvi.mock('./useKeypress.js');\n\nvi.mock('@google/gemini-cli-core', async () => {\n  const actualServerModule = (await vi.importActual(\n    '@google/gemini-cli-core',\n  )) as Record<string, unknown>;\n  return {\n    ...actualServerModule,\n    Config: vi.fn(),\n  };\n});\n\ninterface MockConfigInstanceShape {\n  getApprovalMode: Mock<() => ApprovalMode>;\n  setApprovalMode: Mock<(value: ApprovalMode) => void>;\n  getCoreTools: Mock<() => string[]>;\n  getToolDiscoveryCommand: Mock<() => string | undefined>;\n  getTargetDir: Mock<() => string>;\n  getApiKey: Mock<() => string>;\n  getModel: Mock<() => string>;\n  getSandbox: Mock<() => boolean | string>;\n  getDebugMode: Mock<() => boolean>;\n  getQuestion: Mock<() => string | undefined>;\n  getFullContext: Mock<() => boolean>;\n  getUserAgent: Mock<() => string>;\n  getUserMemory: Mock<() => string>;\n  getGeminiMdFileCount: Mock<() => number>;\n  getToolRegistry: Mock<() => { discoverTools: Mock<() => void> }>;\n}\n\ntype UseKeypressHandler = (key: Key) => void;\n\ndescribe('useAutoAcceptIndicator', () => {\n  let mockConfigInstance: MockConfigInstanceShape;\n  let capturedUseKeypressHandler: UseKeypressHandler;\n  let mockedUseKeypress: MockedFunction<typeof useKeypress>;\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n\n    (\n      Config as unknown as MockedFunction<() => MockConfigInstanceShape>\n    ).mockImplementation(() => {\n      const instanceGetApprovalModeMock = vi.fn();\n      const instanceSetApprovalModeMock = vi.fn();\n\n      const instance: MockConfigInstanceShape = {\n        getApprovalMode: instanceGetApprovalModeMock as Mock<\n          () => ApprovalMode\n        >,\n        setApprovalMode: instanceSetApprovalModeMock as Mock<\n          (value: ApprovalMode) => void\n        >,\n        getCoreTools: vi.fn().mockReturnValue([]) as Mock<() => string[]>,\n        getToolDiscoveryCommand: vi.fn().mockReturnValue(undefined) as Mock<\n          () => string | undefined\n        >,\n        getTargetDir: vi.fn().mockReturnValue('.') as Mock<() => string>,\n        getApiKey: vi.fn().mockReturnValue('test-api-key') as Mock<\n          () => string\n        >,\n        getModel: vi.fn().mockReturnValue('test-model') as Mock<() => string>,\n        getSandbox: vi.fn().mockReturnValue(false) as Mock<\n          () => boolean | string\n        >,\n        getDebugMode: vi.fn().mockReturnValue(false) as Mock<() => boolean>,\n        getQuestion: vi.fn().mockReturnValue(undefined) as Mock<\n          () => string | undefined\n        >,\n        getFullContext: vi.fn().mockReturnValue(false) as Mock<() => boolean>,\n        getUserAgent: vi.fn().mockReturnValue('test-user-agent') as Mock<\n          () => string\n        >,\n        getUserMemory: vi.fn().mockReturnValue('') as Mock<() => string>,\n        getGeminiMdFileCount: vi.fn().mockReturnValue(0) as Mock<() => number>,\n        getToolRegistry: vi\n          .fn()\n          .mockReturnValue({ discoverTools: vi.fn() }) as Mock<\n          () => { discoverTools: Mock<() => void> }\n        >,\n      };\n      instanceSetApprovalModeMock.mockImplementation((value: ApprovalMode) => {\n        instanceGetApprovalModeMock.mockReturnValue(value);\n      });\n      return instance;\n    });\n\n    mockedUseKeypress = useKeypress as MockedFunction<typeof useKeypress>;\n    mockedUseKeypress.mockImplementation(\n      (handler: UseKeypressHandler, _options) => {\n        capturedUseKeypressHandler = handler;\n      },\n    );\n\n     \n    mockConfigInstance = new (Config as any)() as MockConfigInstanceShape;\n  });\n\n  it('should initialize with ApprovalMode.AUTO_EDIT if config.getApprovalMode returns ApprovalMode.AUTO_EDIT', () => {\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.AUTO_EDIT);\n    const { result } = renderHook(() =>\n      useAutoAcceptIndicator({\n        config: mockConfigInstance as unknown as ActualConfigType,\n      }),\n    );\n    expect(result.current).toBe(ApprovalMode.AUTO_EDIT);\n    expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(1);\n  });\n\n  it('should initialize with ApprovalMode.DEFAULT if config.getApprovalMode returns ApprovalMode.DEFAULT', () => {\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);\n    const { result } = renderHook(() =>\n      useAutoAcceptIndicator({\n        config: mockConfigInstance as unknown as ActualConfigType,\n      }),\n    );\n    expect(result.current).toBe(ApprovalMode.DEFAULT);\n    expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(1);\n  });\n\n  it('should initialize with ApprovalMode.YOLO if config.getApprovalMode returns ApprovalMode.YOLO', () => {\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.YOLO);\n    const { result } = renderHook(() =>\n      useAutoAcceptIndicator({\n        config: mockConfigInstance as unknown as ActualConfigType,\n      }),\n    );\n    expect(result.current).toBe(ApprovalMode.YOLO);\n    expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(1);\n  });\n\n  it('should toggle the indicator and update config when Shift+Tab or Ctrl+Y is pressed', () => {\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);\n    const { result } = renderHook(() =>\n      useAutoAcceptIndicator({\n        config: mockConfigInstance as unknown as ActualConfigType,\n      }),\n    );\n    expect(result.current).toBe(ApprovalMode.DEFAULT);\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'tab',\n        shift: true,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(\n      ApprovalMode.AUTO_EDIT,\n    );\n    expect(result.current).toBe(ApprovalMode.AUTO_EDIT);\n\n    act(() => {\n      capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(\n      ApprovalMode.YOLO,\n    );\n    expect(result.current).toBe(ApprovalMode.YOLO);\n\n    act(() => {\n      capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(\n      ApprovalMode.DEFAULT,\n    );\n    expect(result.current).toBe(ApprovalMode.DEFAULT);\n\n    act(() => {\n      capturedUseKeypressHandler({ name: 'y', ctrl: true } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(\n      ApprovalMode.YOLO,\n    );\n    expect(result.current).toBe(ApprovalMode.YOLO);\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'tab',\n        shift: true,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(\n      ApprovalMode.AUTO_EDIT,\n    );\n    expect(result.current).toBe(ApprovalMode.AUTO_EDIT);\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'tab',\n        shift: true,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).toHaveBeenCalledWith(\n      ApprovalMode.DEFAULT,\n    );\n    expect(result.current).toBe(ApprovalMode.DEFAULT);\n  });\n\n  it('should not toggle if only one key or other keys combinations are pressed', () => {\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);\n    renderHook(() =>\n      useAutoAcceptIndicator({\n        config: mockConfigInstance as unknown as ActualConfigType,\n      }),\n    );\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'tab',\n        shift: false,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'unknown',\n        shift: true,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'a',\n        shift: false,\n        ctrl: false,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n\n    act(() => {\n      capturedUseKeypressHandler({ name: 'y', ctrl: false } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n\n    act(() => {\n      capturedUseKeypressHandler({ name: 'a', ctrl: true } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n\n    act(() => {\n      capturedUseKeypressHandler({ name: 'y', shift: true } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n\n    act(() => {\n      capturedUseKeypressHandler({\n        name: 'a',\n        ctrl: true,\n        shift: true,\n      } as Key);\n    });\n    expect(mockConfigInstance.setApprovalMode).not.toHaveBeenCalled();\n  });\n\n  it('should update indicator when config value changes externally (useEffect dependency)', () => {\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.DEFAULT);\n    const { result, rerender } = renderHook(\n      (props: { config: ActualConfigType }) => useAutoAcceptIndicator(props),\n      {\n        initialProps: {\n          config: mockConfigInstance as unknown as ActualConfigType,\n        },\n      },\n    );\n    expect(result.current).toBe(ApprovalMode.DEFAULT);\n\n    mockConfigInstance.getApprovalMode.mockReturnValue(ApprovalMode.AUTO_EDIT);\n\n    rerender({ config: mockConfigInstance as unknown as ActualConfigType });\n    expect(result.current).toBe(ApprovalMode.AUTO_EDIT);\n    expect(mockConfigInstance.getApprovalMode).toHaveBeenCalledTimes(3);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useAutoAcceptIndicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useBracketedPaste.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useCommandCompletion.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useCommandCompletion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useCompletion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useConsoleMessages.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useConsoleMessages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useEditorSettings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useEditorSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useFocus.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useFocus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useFolderTrust.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useFolderTrust.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useGeminiStream.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1322,1325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1322,1325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":54,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1336,1339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1336,1339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1758,1761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1758,1761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2168,2171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2168,2171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5217,5220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5217,5220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":230,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6642,6645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6642,6645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":248,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7257,7260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7257,7260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7751,7754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7751,7754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10229,10232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10229,10232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":369,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10809,10812],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10809,10812],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":572,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":572,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16775,16778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16775,16778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":601,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":601,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17598,17601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17598,17601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":700,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":700,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20503,20506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20503,20506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":800,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":800,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23452,23455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23452,23455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":969,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":969,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28478,28481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28478,28481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1126,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1126,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33658,33661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33658,33661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \nimport {\n  describe,\n  it,\n  expect,\n  vi,\n  beforeEach,\n  Mock,\n  MockInstance,\n} from 'vitest';\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport { useGeminiStream } from './useGeminiStream.js';\nimport { useKeypress } from './useKeypress.js';\nimport * as atCommandProcessor from './atCommandProcessor.js';\nimport {\n  useReactToolScheduler,\n  TrackedToolCall,\n  TrackedCompletedToolCall,\n  TrackedExecutingToolCall,\n  TrackedCancelledToolCall,\n} from './useReactToolScheduler.js';\nimport {\n  Config,\n  EditorType,\n  AuthType,\n  GeminiClient,\n  GeminiEventType as ServerGeminiEventType,\n  AnyToolInvocation,\n  ToolErrorType, // <-- Import ToolErrorType\n} from '@google/gemini-cli-core';\nimport { Part, PartListUnion } from '@google/genai';\nimport { UseHistoryManagerReturn } from './useHistoryManager.js';\nimport {\n  HistoryItem,\n  MessageType,\n  SlashCommandProcessorResult,\n  StreamingState,\n} from '../types.js';\nimport { LoadedSettings } from '../../config/settings.js';\n\n// --- MOCKS ---\nconst mockSendMessageStream = vi\n  .fn()\n  .mockReturnValue((async function* () {})());\nconst mockStartChat = vi.fn();\n\nconst MockedGeminiClientClass = vi.hoisted(() =>\n  vi.fn().mockImplementation(function (this: any, _config: any) {\n    // _config\n    this.startChat = mockStartChat;\n    this.sendMessageStream = mockSendMessageStream;\n    this.addHistory = vi.fn();\n  }),\n);\n\nconst MockedUserPromptEvent = vi.hoisted(() =>\n  vi.fn().mockImplementation(() => {}),\n);\nconst mockParseAndFormatApiError = vi.hoisted(() => vi.fn());\n\nvi.mock('@google/gemini-cli-core', async (importOriginal) => {\n  const actualCoreModule = (await importOriginal()) as any;\n  return {\n    ...actualCoreModule,\n    GitService: vi.fn(),\n    GeminiClient: MockedGeminiClientClass,\n    UserPromptEvent: MockedUserPromptEvent,\n    parseAndFormatApiError: mockParseAndFormatApiError,\n  };\n});\n\nconst mockUseReactToolScheduler = useReactToolScheduler as Mock;\nvi.mock('./useReactToolScheduler.js', async (importOriginal) => {\n  const actualSchedulerModule = (await importOriginal()) as any;\n  return {\n    ...(actualSchedulerModule || {}),\n    useReactToolScheduler: vi.fn(),\n  };\n});\n\nvi.mock('./useKeypress.js', () => ({\n  useKeypress: vi.fn(),\n}));\n\nvi.mock('./shellCommandProcessor.js', () => ({\n  useShellCommandProcessor: vi.fn().mockReturnValue({\n    handleShellCommand: vi.fn(),\n  }),\n}));\n\nvi.mock('./atCommandProcessor.js');\n\nvi.mock('../utils/markdownUtilities.js', () => ({\n  findLastSafeSplitPoint: vi.fn((s: string) => s.length),\n}));\n\nvi.mock('./useStateAndRef.js', () => ({\n  useStateAndRef: vi.fn((initial) => {\n    let val = initial;\n    const ref = { current: val };\n    const setVal = vi.fn((updater) => {\n      if (typeof updater === 'function') {\n        val = updater(val);\n      } else {\n        val = updater;\n      }\n      ref.current = val;\n    });\n    return [ref, setVal];\n  }),\n}));\n\nvi.mock('./useLogger.js', () => ({\n  useLogger: vi.fn().mockReturnValue({\n    logMessage: vi.fn().mockResolvedValue(undefined),\n  }),\n}));\n\nconst mockStartNewPrompt = vi.fn();\nconst mockAddUsage = vi.fn();\nvi.mock('../contexts/SessionContext.js', () => ({\n  useSessionStats: vi.fn(() => ({\n    startNewPrompt: mockStartNewPrompt,\n    addUsage: mockAddUsage,\n    getPromptCount: vi.fn(() => 5),\n  })),\n}));\n\nvi.mock('./slashCommandProcessor.js', () => ({\n  handleSlashCommand: vi.fn().mockReturnValue(false),\n}));\n\n// --- END MOCKS ---\n\n// --- Tests for useGeminiStream Hook ---\ndescribe('useGeminiStream', () => {\n  let mockAddItem: Mock;\n  let mockConfig: Config;\n  let mockOnDebugMessage: Mock;\n  let mockHandleSlashCommand: Mock;\n  let mockScheduleToolCalls: Mock;\n  let mockCancelAllToolCalls: Mock;\n  let mockMarkToolsAsSubmitted: Mock;\n  let handleAtCommandSpy: MockInstance;\n\n  beforeEach(() => {\n    vi.clearAllMocks(); // Clear mocks before each test\n\n    mockAddItem = vi.fn();\n    // Define the mock for getGeminiClient\n    const mockGetGeminiClient = vi.fn().mockImplementation(() => {\n      // MockedGeminiClientClass is defined in the module scope by the previous change.\n      // It will use the mockStartChat and mockSendMessageStream that are managed within beforeEach.\n      const clientInstance = new MockedGeminiClientClass(mockConfig);\n      return clientInstance;\n    });\n\n    const contentGeneratorConfig = {\n      model: 'test-model',\n      apiKey: 'test-key',\n      vertexai: false,\n      authType: AuthType.USE_GEMINI,\n    };\n\n    mockConfig = {\n      apiKey: 'test-api-key',\n      model: 'gemini-pro',\n      sandbox: false,\n      targetDir: '/test/dir',\n      debugMode: false,\n      question: undefined,\n      fullContext: false,\n      coreTools: [],\n      toolDiscoveryCommand: undefined,\n      toolCallCommand: undefined,\n      mcpServerCommand: undefined,\n      mcpServers: undefined,\n      userAgent: 'test-agent',\n      userMemory: '',\n      geminiMdFileCount: 0,\n      alwaysSkipModificationConfirmation: false,\n      vertexai: false,\n      showMemoryUsage: false,\n      contextFileName: undefined,\n      getToolRegistry: vi.fn(\n        () => ({ getToolSchemaList: vi.fn(() => []) }) as any,\n      ),\n      getProjectRoot: vi.fn(() => '/test/dir'),\n      getCheckpointingEnabled: vi.fn(() => false),\n      getGeminiClient: mockGetGeminiClient,\n      getUsageStatisticsEnabled: () => true,\n      getDebugMode: () => false,\n      addHistory: vi.fn(),\n      getSessionId() {\n        return 'test-session-id';\n      },\n      setQuotaErrorOccurred: vi.fn(),\n      getQuotaErrorOccurred: vi.fn(() => false),\n      getModel: vi.fn(() => 'gemini-2.5-pro'),\n      getContentGeneratorConfig: vi\n        .fn()\n        .mockReturnValue(contentGeneratorConfig),\n    } as unknown as Config;\n    mockOnDebugMessage = vi.fn();\n    mockHandleSlashCommand = vi.fn().mockResolvedValue(false);\n\n    // Mock return value for useReactToolScheduler\n    mockScheduleToolCalls = vi.fn();\n    mockCancelAllToolCalls = vi.fn();\n    mockMarkToolsAsSubmitted = vi.fn();\n\n    // Default mock for useReactToolScheduler to prevent toolCalls being undefined initially\n    mockUseReactToolScheduler.mockReturnValue([\n      [], // Default to empty array for toolCalls\n      mockScheduleToolCalls,\n      mockCancelAllToolCalls,\n      mockMarkToolsAsSubmitted,\n    ]);\n\n    // Reset mocks for GeminiClient instance methods (startChat and sendMessageStream)\n    // The GeminiClient constructor itself is mocked at the module level.\n    mockStartChat.mockClear().mockResolvedValue({\n      sendMessageStream: mockSendMessageStream,\n    } as unknown as any); // GeminiChat -> any\n    mockSendMessageStream\n      .mockClear()\n      .mockReturnValue((async function* () {})());\n    handleAtCommandSpy = vi.spyOn(atCommandProcessor, 'handleAtCommand');\n  });\n\n  const mockLoadedSettings: LoadedSettings = {\n    merged: { preferredEditor: 'vscode' },\n    user: { path: '/user/settings.json', settings: {} },\n    workspace: { path: '/workspace/.gemini/settings.json', settings: {} },\n    errors: [],\n    forScope: vi.fn(),\n    setValue: vi.fn(),\n  } as unknown as LoadedSettings;\n\n  const renderTestHook = (\n    initialToolCalls: TrackedToolCall[] = [],\n    geminiClient?: any,\n  ) => {\n    let currentToolCalls = initialToolCalls;\n    const setToolCalls = (newToolCalls: TrackedToolCall[]) => {\n      currentToolCalls = newToolCalls;\n    };\n\n    mockUseReactToolScheduler.mockImplementation(() => [\n      currentToolCalls,\n      mockScheduleToolCalls,\n      mockCancelAllToolCalls,\n      mockMarkToolsAsSubmitted,\n    ]);\n\n    const client = geminiClient || mockConfig.getGeminiClient();\n\n    const { result, rerender } = renderHook(\n      (props: {\n        client: any;\n        history: HistoryItem[];\n        addItem: UseHistoryManagerReturn['addItem'];\n        config: Config;\n        onDebugMessage: (message: string) => void;\n        handleSlashCommand: (\n          cmd: PartListUnion,\n        ) => Promise<SlashCommandProcessorResult | false>;\n        shellModeActive: boolean;\n        loadedSettings: LoadedSettings;\n        toolCalls?: TrackedToolCall[]; // Allow passing updated toolCalls\n      }) => {\n        // Update the mock's return value if new toolCalls are passed in props\n        if (props.toolCalls) {\n          setToolCalls(props.toolCalls);\n        }\n        return useGeminiStream(\n          props.client,\n          props.history,\n          props.addItem,\n          props.config,\n          props.onDebugMessage,\n          props.handleSlashCommand,\n          props.shellModeActive,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        );\n      },\n      {\n        initialProps: {\n          client,\n          history: [],\n          addItem: mockAddItem as unknown as UseHistoryManagerReturn['addItem'],\n          config: mockConfig,\n          onDebugMessage: mockOnDebugMessage,\n          handleSlashCommand: mockHandleSlashCommand as unknown as (\n            cmd: PartListUnion,\n          ) => Promise<SlashCommandProcessorResult | false>,\n          shellModeActive: false,\n          loadedSettings: mockLoadedSettings,\n          toolCalls: initialToolCalls,\n        },\n      },\n    );\n    return {\n      result,\n      rerender,\n      mockMarkToolsAsSubmitted,\n      mockSendMessageStream,\n      client,\n    };\n  };\n\n  it('should not submit tool responses if not all tool calls are completed', () => {\n    const toolCalls: TrackedToolCall[] = [\n      {\n        request: {\n          callId: 'call1',\n          name: 'tool1',\n          args: {},\n          isClientInitiated: false,\n          prompt_id: 'prompt-id-1',\n        },\n        status: 'success',\n        responseSubmittedToGemini: false,\n        response: {\n          callId: 'call1',\n          responseParts: [{ text: 'tool 1 response' }],\n          error: undefined,\n          errorType: undefined, // FIX: Added missing property\n          resultDisplay: 'Tool 1 success display',\n        },\n        tool: {\n          name: 'tool1',\n          displayName: 'tool1',\n          description: 'desc1',\n          build: vi.fn(),\n        } as any,\n        invocation: {\n          getDescription: () => `Mock description`,\n        } as unknown as AnyToolInvocation,\n        startTime: Date.now(),\n        endTime: Date.now(),\n      } as TrackedCompletedToolCall,\n      {\n        request: {\n          callId: 'call2',\n          name: 'tool2',\n          args: {},\n          prompt_id: 'prompt-id-1',\n        },\n        status: 'executing',\n        responseSubmittedToGemini: false,\n        tool: {\n          name: 'tool2',\n          displayName: 'tool2',\n          description: 'desc2',\n          build: vi.fn(),\n        } as any,\n        invocation: {\n          getDescription: () => `Mock description`,\n        } as unknown as AnyToolInvocation,\n        startTime: Date.now(),\n        liveOutput: '...',\n      } as TrackedExecutingToolCall,\n    ];\n\n    const { mockMarkToolsAsSubmitted, mockSendMessageStream } =\n      renderTestHook(toolCalls);\n\n    // Effect for submitting tool responses depends on toolCalls and isResponding\n    // isResponding is initially false, so the effect should run.\n\n    expect(mockMarkToolsAsSubmitted).not.toHaveBeenCalled();\n    expect(mockSendMessageStream).not.toHaveBeenCalled(); // submitQuery uses this\n  });\n\n  it('should submit tool responses when all tool calls are completed and ready', async () => {\n    const toolCall1ResponseParts: Part[] = [{ text: 'tool 1 final response' }];\n    const toolCall2ResponseParts: Part[] = [{ text: 'tool 2 final response' }];\n    const completedToolCalls: TrackedToolCall[] = [\n      {\n        request: {\n          callId: 'call1',\n          name: 'tool1',\n          args: {},\n          isClientInitiated: false,\n          prompt_id: 'prompt-id-2',\n        },\n        status: 'success',\n        responseSubmittedToGemini: false,\n        response: {\n          callId: 'call1',\n          responseParts: toolCall1ResponseParts,\n          errorType: undefined, // FIX: Added missing property\n        },\n        tool: {\n          displayName: 'MockTool',\n        },\n        invocation: {\n          getDescription: () => `Mock description`,\n        } as unknown as AnyToolInvocation,\n      } as TrackedCompletedToolCall,\n      {\n        request: {\n          callId: 'call2',\n          name: 'tool2',\n          args: {},\n          isClientInitiated: false,\n          prompt_id: 'prompt-id-2',\n        },\n        status: 'error',\n        responseSubmittedToGemini: false,\n        response: {\n          callId: 'call2',\n          responseParts: toolCall2ResponseParts,\n          errorType: ToolErrorType.UNHANDLED_EXCEPTION, // FIX: Added missing property\n        },\n      } as TrackedCompletedToolCall, // Treat error as a form of completion for submission\n    ];\n\n    // Capture the onComplete callback\n    let capturedOnComplete:\n      | ((completedTools: TrackedToolCall[]) => Promise<void>)\n      | null = null;\n\n    mockUseReactToolScheduler.mockImplementation((onComplete) => {\n      capturedOnComplete = onComplete;\n      return [[], mockScheduleToolCalls, mockMarkToolsAsSubmitted];\n    });\n\n    renderHook(() =>\n      useGeminiStream(\n        new MockedGeminiClientClass(mockConfig),\n        [],\n        mockAddItem,\n        mockConfig,\n        mockOnDebugMessage,\n        mockHandleSlashCommand,\n        false,\n        () => 'vscode' as EditorType,\n        () => {},\n        () => Promise.resolve(),\n        false,\n        () => {},\n        () => {},\n        () => {},\n      ),\n    );\n\n    // Trigger the onComplete callback with completed tools\n    await act(async () => {\n      if (capturedOnComplete) {\n        await capturedOnComplete(completedToolCalls);\n      }\n    });\n\n    await waitFor(() => {\n      expect(mockMarkToolsAsSubmitted).toHaveBeenCalledTimes(1);\n      expect(mockSendMessageStream).toHaveBeenCalledTimes(1);\n    });\n\n    const expectedMergedResponse = [\n      ...toolCall1ResponseParts,\n      ...toolCall2ResponseParts,\n    ];\n    expect(mockSendMessageStream).toHaveBeenCalledWith(\n      expectedMergedResponse,\n      expect.any(AbortSignal),\n      'prompt-id-2',\n    );\n  });\n\n  it('should handle all tool calls being cancelled', async () => {\n    const cancelledToolCalls: TrackedToolCall[] = [\n      {\n        request: {\n          callId: '1',\n          name: 'testTool',\n          args: {},\n          isClientInitiated: false,\n          prompt_id: 'prompt-id-3',\n        },\n        status: 'cancelled',\n        response: {\n          callId: '1',\n          responseParts: [{ text: 'cancelled' }],\n          errorType: undefined, // FIX: Added missing property\n        },\n        responseSubmittedToGemini: false,\n        tool: {\n          displayName: 'mock tool',\n        },\n        invocation: {\n          getDescription: () => `Mock description`,\n        } as unknown as AnyToolInvocation,\n      } as TrackedCancelledToolCall,\n    ];\n    const client = new MockedGeminiClientClass(mockConfig);\n\n    // Capture the onComplete callback\n    let capturedOnComplete:\n      | ((completedTools: TrackedToolCall[]) => Promise<void>)\n      | null = null;\n\n    mockUseReactToolScheduler.mockImplementation((onComplete) => {\n      capturedOnComplete = onComplete;\n      return [[], mockScheduleToolCalls, mockMarkToolsAsSubmitted];\n    });\n\n    renderHook(() =>\n      useGeminiStream(\n        client,\n        [],\n        mockAddItem,\n        mockConfig,\n        mockOnDebugMessage,\n        mockHandleSlashCommand,\n        false,\n        () => 'vscode' as EditorType,\n        () => {},\n        () => Promise.resolve(),\n        false,\n        () => {},\n        () => {},\n        () => {},\n      ),\n    );\n\n    // Trigger the onComplete callback with cancelled tools\n    await act(async () => {\n      if (capturedOnComplete) {\n        await capturedOnComplete(cancelledToolCalls);\n      }\n    });\n\n    await waitFor(() => {\n      expect(mockMarkToolsAsSubmitted).toHaveBeenCalledWith(['1']);\n      expect(client.addHistory).toHaveBeenCalledWith({\n        role: 'user',\n        parts: [{ text: 'cancelled' }],\n      });\n      // Ensure we do NOT call back to the API\n      expect(mockSendMessageStream).not.toHaveBeenCalled();\n    });\n  });\n\n  it('should group multiple cancelled tool call responses into a single history entry', async () => {\n    const cancelledToolCall1: TrackedCancelledToolCall = {\n      request: {\n        callId: 'cancel-1',\n        name: 'toolA',\n        args: {},\n        isClientInitiated: false,\n        prompt_id: 'prompt-id-7',\n      },\n      tool: {\n        name: 'toolA',\n        displayName: 'toolA',\n        description: 'descA',\n        build: vi.fn(),\n      } as any,\n      invocation: {\n        getDescription: () => `Mock description`,\n      } as unknown as AnyToolInvocation,\n      status: 'cancelled',\n      response: {\n        callId: 'cancel-1',\n        responseParts: [\n          { functionResponse: { name: 'toolA', id: 'cancel-1' } },\n        ],\n        resultDisplay: undefined,\n        error: undefined,\n        errorType: undefined, // FIX: Added missing property\n      },\n      responseSubmittedToGemini: false,\n    };\n    const cancelledToolCall2: TrackedCancelledToolCall = {\n      request: {\n        callId: 'cancel-2',\n        name: 'toolB',\n        args: {},\n        isClientInitiated: false,\n        prompt_id: 'prompt-id-8',\n      },\n      tool: {\n        name: 'toolB',\n        displayName: 'toolB',\n        description: 'descB',\n        build: vi.fn(),\n      } as any,\n      invocation: {\n        getDescription: () => `Mock description`,\n      } as unknown as AnyToolInvocation,\n      status: 'cancelled',\n      response: {\n        callId: 'cancel-2',\n        responseParts: [\n          { functionResponse: { name: 'toolB', id: 'cancel-2' } },\n        ],\n        resultDisplay: undefined,\n        error: undefined,\n        errorType: undefined, // FIX: Added missing property\n      },\n      responseSubmittedToGemini: false,\n    };\n    const allCancelledTools = [cancelledToolCall1, cancelledToolCall2];\n    const client = new MockedGeminiClientClass(mockConfig);\n\n    let capturedOnComplete:\n      | ((completedTools: TrackedToolCall[]) => Promise<void>)\n      | null = null;\n\n    mockUseReactToolScheduler.mockImplementation((onComplete) => {\n      capturedOnComplete = onComplete;\n      return [[], mockScheduleToolCalls, mockMarkToolsAsSubmitted];\n    });\n\n    renderHook(() =>\n      useGeminiStream(\n        client,\n        [],\n        mockAddItem,\n        mockConfig,\n        mockOnDebugMessage,\n        mockHandleSlashCommand,\n        false,\n        () => 'vscode' as EditorType,\n        () => {},\n        () => Promise.resolve(),\n        false,\n        () => {},\n        () => {},\n        () => {},\n      ),\n    );\n\n    // Trigger the onComplete callback with multiple cancelled tools\n    await act(async () => {\n      if (capturedOnComplete) {\n        await capturedOnComplete(allCancelledTools);\n      }\n    });\n\n    await waitFor(() => {\n      // The tools should be marked as submitted locally\n      expect(mockMarkToolsAsSubmitted).toHaveBeenCalledWith([\n        'cancel-1',\n        'cancel-2',\n      ]);\n\n      // Crucially, addHistory should be called only ONCE\n      expect(client.addHistory).toHaveBeenCalledTimes(1);\n\n      // And that single call should contain BOTH function responses\n      expect(client.addHistory).toHaveBeenCalledWith({\n        role: 'user',\n        parts: [\n          ...(cancelledToolCall1.response.responseParts as Part[]),\n          ...(cancelledToolCall2.response.responseParts as Part[]),\n        ],\n      });\n\n      // No message should be sent back to the API for a turn with only cancellations\n      expect(mockSendMessageStream).not.toHaveBeenCalled();\n    });\n  });\n\n  it('should not flicker streaming state to Idle between tool completion and submission', async () => {\n    const toolCallResponseParts: PartListUnion = [\n      { text: 'tool 1 final response' },\n    ];\n\n    const initialToolCalls: TrackedToolCall[] = [\n      {\n        request: {\n          callId: 'call1',\n          name: 'tool1',\n          args: {},\n          isClientInitiated: false,\n          prompt_id: 'prompt-id-4',\n        },\n        status: 'executing',\n        responseSubmittedToGemini: false,\n        tool: {\n          name: 'tool1',\n          displayName: 'tool1',\n          description: 'desc',\n          build: vi.fn(),\n        } as any,\n        invocation: {\n          getDescription: () => `Mock description`,\n        } as unknown as AnyToolInvocation,\n        startTime: Date.now(),\n      } as TrackedExecutingToolCall,\n    ];\n\n    const completedToolCalls: TrackedToolCall[] = [\n      {\n        ...(initialToolCalls[0] as TrackedExecutingToolCall),\n        status: 'success',\n        response: {\n          callId: 'call1',\n          responseParts: toolCallResponseParts,\n          error: undefined,\n          errorType: undefined, // FIX: Added missing property\n          resultDisplay: 'Tool 1 success display',\n        },\n        endTime: Date.now(),\n      } as TrackedCompletedToolCall,\n    ];\n\n    // Capture the onComplete callback\n    let capturedOnComplete:\n      | ((completedTools: TrackedToolCall[]) => Promise<void>)\n      | null = null;\n    let currentToolCalls = initialToolCalls;\n\n    mockUseReactToolScheduler.mockImplementation((onComplete) => {\n      capturedOnComplete = onComplete;\n      return [\n        currentToolCalls,\n        mockScheduleToolCalls,\n        mockMarkToolsAsSubmitted,\n      ];\n    });\n\n    const { result, rerender } = renderHook(() =>\n      useGeminiStream(\n        new MockedGeminiClientClass(mockConfig),\n        [],\n        mockAddItem,\n        mockConfig,\n        mockOnDebugMessage,\n        mockHandleSlashCommand,\n        false,\n        () => 'vscode' as EditorType,\n        () => {},\n        () => Promise.resolve(),\n        false,\n        () => {},\n        () => {},\n        () => {},\n      ),\n    );\n\n    // 1. Initial state should be Responding because a tool is executing.\n    expect(result.current.streamingState).toBe(StreamingState.Responding);\n\n    // 2. Update the tool calls to completed state and rerender\n    currentToolCalls = completedToolCalls;\n    mockUseReactToolScheduler.mockImplementation((onComplete) => {\n      capturedOnComplete = onComplete;\n      return [\n        completedToolCalls,\n        mockScheduleToolCalls,\n        mockMarkToolsAsSubmitted,\n      ];\n    });\n\n    act(() => {\n      rerender();\n    });\n\n    // 3. The state should *still* be Responding, not Idle.\n    // This is because the completed tool's response has not been submitted yet.\n    expect(result.current.streamingState).toBe(StreamingState.Responding);\n\n    // 4. Trigger the onComplete callback to simulate tool completion\n    await act(async () => {\n      if (capturedOnComplete) {\n        await capturedOnComplete(completedToolCalls);\n      }\n    });\n\n    // 5. Wait for submitQuery to be called\n    await waitFor(() => {\n      expect(mockSendMessageStream).toHaveBeenCalledWith(\n        toolCallResponseParts,\n        expect.any(AbortSignal),\n        'prompt-id-4',\n      );\n    });\n\n    // 6. After submission, the state should remain Responding until the stream completes.\n    expect(result.current.streamingState).toBe(StreamingState.Responding);\n  });\n\n  describe('User Cancellation', () => {\n    let keypressCallback: (key: any) => void;\n    const mockUseKeypress = useKeypress as Mock;\n\n    beforeEach(() => {\n      // Capture the callback passed to useKeypress\n      mockUseKeypress.mockImplementation((callback, options) => {\n        if (options.isActive) {\n          keypressCallback = callback;\n        } else {\n          keypressCallback = () => {};\n        }\n      });\n    });\n\n    const simulateEscapeKeyPress = () => {\n      act(() => {\n        keypressCallback({ name: 'escape' });\n      });\n    };\n\n    it('should cancel an in-progress stream when escape is pressed', async () => {\n      const mockStream = (async function* () {\n        yield { type: 'content', value: 'Part 1' };\n        // Keep the stream open\n        await new Promise(() => {});\n      })();\n      mockSendMessageStream.mockReturnValue(mockStream);\n\n      const { result } = renderTestHook();\n\n      // Start a query\n      await act(async () => {\n        result.current.submitQuery('test query');\n      });\n\n      // Wait for the first part of the response\n      await waitFor(() => {\n        expect(result.current.streamingState).toBe(StreamingState.Responding);\n      });\n\n      // Simulate escape key press\n      simulateEscapeKeyPress();\n\n      // Verify cancellation message is added\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          {\n            type: MessageType.INFO,\n            text: 'Request cancelled.',\n          },\n          expect.any(Number),\n        );\n      });\n\n      // Verify state is reset\n      expect(result.current.streamingState).toBe(StreamingState.Idle);\n    });\n\n    it('should call onCancelSubmit handler when escape is pressed', async () => {\n      const cancelSubmitSpy = vi.fn();\n      const mockStream = (async function* () {\n        yield { type: 'content', value: 'Part 1' };\n        // Keep the stream open\n        await new Promise(() => {});\n      })();\n      mockSendMessageStream.mockReturnValue(mockStream);\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          mockConfig.getGeminiClient(),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          cancelSubmitSpy,\n        ),\n      );\n\n      // Start a query\n      await act(async () => {\n        result.current.submitQuery('test query');\n      });\n\n      simulateEscapeKeyPress();\n\n      expect(cancelSubmitSpy).toHaveBeenCalled();\n    });\n\n    it('should not do anything if escape is pressed when not responding', () => {\n      const { result } = renderTestHook();\n\n      expect(result.current.streamingState).toBe(StreamingState.Idle);\n\n      // Simulate escape key press\n      simulateEscapeKeyPress();\n\n      // No change should happen, no cancellation message\n      expect(mockAddItem).not.toHaveBeenCalledWith(\n        expect.objectContaining({\n          text: 'Request cancelled.',\n        }),\n        expect.any(Number),\n      );\n    });\n\n    it('should prevent further processing after cancellation', async () => {\n      let continueStream: () => void;\n      const streamPromise = new Promise<void>((resolve) => {\n        continueStream = resolve;\n      });\n\n      const mockStream = (async function* () {\n        yield { type: 'content', value: 'Initial' };\n        await streamPromise; // Wait until we manually continue\n        yield { type: 'content', value: ' Canceled' };\n      })();\n      mockSendMessageStream.mockReturnValue(mockStream);\n\n      const { result } = renderTestHook();\n\n      await act(async () => {\n        result.current.submitQuery('long running query');\n      });\n\n      await waitFor(() => {\n        expect(result.current.streamingState).toBe(StreamingState.Responding);\n      });\n\n      // Cancel the request\n      simulateEscapeKeyPress();\n\n      // Allow the stream to continue\n      act(() => {\n        continueStream();\n      });\n\n      // Wait a bit to see if the second part is processed\n      await new Promise((resolve) => setTimeout(resolve, 50));\n\n      // The text should not have been updated with \" Canceled\"\n      const lastCall = mockAddItem.mock.calls.find(\n        (call) => call[0].type === 'gemini',\n      );\n      expect(lastCall?.[0].text).toBe('Initial');\n\n      // The final state should be idle after cancellation\n      expect(result.current.streamingState).toBe(StreamingState.Idle);\n    });\n\n    it('should not cancel if a tool call is in progress (not just responding)', async () => {\n      const toolCalls: TrackedToolCall[] = [\n        {\n          request: { callId: 'call1', name: 'tool1', args: {} },\n          status: 'executing',\n          responseSubmittedToGemini: false,\n          tool: {\n            name: 'tool1',\n            description: 'desc1',\n            build: vi.fn().mockImplementation((_) => ({\n              getDescription: () => `Mock description`,\n            })),\n          } as any,\n          invocation: {\n            getDescription: () => `Mock description`,\n          },\n          startTime: Date.now(),\n          liveOutput: '...',\n        } as TrackedExecutingToolCall,\n      ];\n\n      const abortSpy = vi.spyOn(AbortController.prototype, 'abort');\n      const { result } = renderTestHook(toolCalls);\n\n      // State is `Responding` because a tool is running\n      expect(result.current.streamingState).toBe(StreamingState.Responding);\n\n      // Try to cancel\n      simulateEscapeKeyPress();\n\n      // Nothing should happen because the state is not `Responding`\n      expect(abortSpy).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Slash Command Handling', () => {\n    it('should schedule a tool call when the command processor returns a schedule_tool action', async () => {\n      const clientToolRequest: SlashCommandProcessorResult = {\n        type: 'schedule_tool',\n        toolName: 'save_memory',\n        toolArgs: { fact: 'test fact' },\n      };\n      mockHandleSlashCommand.mockResolvedValue(clientToolRequest);\n\n      const { result } = renderTestHook();\n\n      await act(async () => {\n        await result.current.submitQuery('/memory add \"test fact\"');\n      });\n\n      await waitFor(() => {\n        expect(mockScheduleToolCalls).toHaveBeenCalledWith(\n          [\n            expect.objectContaining({\n              name: 'save_memory',\n              args: { fact: 'test fact' },\n              isClientInitiated: true,\n            }),\n          ],\n          expect.any(AbortSignal),\n        );\n        expect(mockSendMessageStream).not.toHaveBeenCalled();\n      });\n    });\n\n    it('should stop processing and not call Gemini when a command is handled without a tool call', async () => {\n      const uiOnlyCommandResult: SlashCommandProcessorResult = {\n        type: 'handled',\n      };\n      mockHandleSlashCommand.mockResolvedValue(uiOnlyCommandResult);\n\n      const { result } = renderTestHook();\n\n      await act(async () => {\n        await result.current.submitQuery('/help');\n      });\n\n      await waitFor(() => {\n        expect(mockHandleSlashCommand).toHaveBeenCalledWith('/help');\n        expect(mockScheduleToolCalls).not.toHaveBeenCalled();\n        expect(mockSendMessageStream).not.toHaveBeenCalled(); // No LLM call made\n      });\n    });\n\n    it('should call Gemini with prompt content when slash command returns a `submit_prompt` action', async () => {\n      const customCommandResult: SlashCommandProcessorResult = {\n        type: 'submit_prompt',\n        content: 'This is the actual prompt from the command file.',\n      };\n      mockHandleSlashCommand.mockResolvedValue(customCommandResult);\n\n      const { result, mockSendMessageStream: localMockSendMessageStream } =\n        renderTestHook();\n\n      await act(async () => {\n        await result.current.submitQuery('/my-custom-command');\n      });\n\n      await waitFor(() => {\n        expect(mockHandleSlashCommand).toHaveBeenCalledWith(\n          '/my-custom-command',\n        );\n\n        expect(localMockSendMessageStream).not.toHaveBeenCalledWith(\n          '/my-custom-command',\n          expect.anything(),\n          expect.anything(),\n        );\n\n        expect(localMockSendMessageStream).toHaveBeenCalledWith(\n          'This is the actual prompt from the command file.',\n          expect.any(AbortSignal),\n          expect.any(String),\n        );\n\n        expect(mockScheduleToolCalls).not.toHaveBeenCalled();\n      });\n    });\n\n    it('should correctly handle a submit_prompt action with empty content', async () => {\n      const emptyPromptResult: SlashCommandProcessorResult = {\n        type: 'submit_prompt',\n        content: '',\n      };\n      mockHandleSlashCommand.mockResolvedValue(emptyPromptResult);\n\n      const { result, mockSendMessageStream: localMockSendMessageStream } =\n        renderTestHook();\n\n      await act(async () => {\n        await result.current.submitQuery('/emptycmd');\n      });\n\n      await waitFor(() => {\n        expect(mockHandleSlashCommand).toHaveBeenCalledWith('/emptycmd');\n        expect(localMockSendMessageStream).toHaveBeenCalledWith(\n          '',\n          expect.any(AbortSignal),\n          expect.any(String),\n        );\n      });\n    });\n  });\n\n  describe('Memory Refresh on save_memory', () => {\n    it('should call performMemoryRefresh when a save_memory tool call completes successfully', async () => {\n      const mockPerformMemoryRefresh = vi.fn();\n      const completedToolCall: TrackedCompletedToolCall = {\n        request: {\n          callId: 'save-mem-call-1',\n          name: 'save_memory',\n          args: { fact: 'test' },\n          isClientInitiated: true,\n          prompt_id: 'prompt-id-6',\n        },\n        status: 'success',\n        responseSubmittedToGemini: false,\n        response: {\n          callId: 'save-mem-call-1',\n          responseParts: [{ text: 'Memory saved' }],\n          resultDisplay: 'Success: Memory saved',\n          error: undefined,\n          errorType: undefined, // FIX: Added missing property\n        },\n        tool: {\n          name: 'save_memory',\n          displayName: 'save_memory',\n          description: 'Saves memory',\n          build: vi.fn(),\n        } as any,\n        invocation: {\n          getDescription: () => `Mock description`,\n        } as unknown as AnyToolInvocation,\n      };\n\n      // Capture the onComplete callback\n      let capturedOnComplete:\n        | ((completedTools: TrackedToolCall[]) => Promise<void>)\n        | null = null;\n\n      mockUseReactToolScheduler.mockImplementation((onComplete) => {\n        capturedOnComplete = onComplete;\n        return [[], mockScheduleToolCalls, mockMarkToolsAsSubmitted];\n      });\n\n      renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          mockPerformMemoryRefresh,\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Trigger the onComplete callback with the completed save_memory tool\n      await act(async () => {\n        if (capturedOnComplete) {\n          await capturedOnComplete([completedToolCall]);\n        }\n      });\n\n      await waitFor(() => {\n        expect(mockPerformMemoryRefresh).toHaveBeenCalledTimes(1);\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should call parseAndFormatApiError with the correct authType on stream initialization failure', async () => {\n      // 1. Setup\n      const mockError = new Error('Rate limit exceeded');\n      const mockAuthType = AuthType.LOGIN_WITH_GOOGLE;\n      mockParseAndFormatApiError.mockClear();\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield { type: 'content', value: '' };\n          throw mockError;\n        })(),\n      );\n\n      const testConfig = {\n        ...mockConfig,\n        getContentGeneratorConfig: vi.fn(() => ({\n          authType: mockAuthType,\n        })),\n        getModel: vi.fn(() => 'gemini-2.5-pro'),\n      } as unknown as Config;\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(testConfig),\n          [],\n          mockAddItem,\n          testConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // 2. Action\n      await act(async () => {\n        await result.current.submitQuery('test query');\n      });\n\n      // 3. Assertion\n      await waitFor(() => {\n        expect(mockParseAndFormatApiError).toHaveBeenCalledWith(\n          'Rate limit exceeded',\n          mockAuthType,\n          undefined,\n          'gemini-2.5-pro',\n          'gemini-2.5-flash',\n        );\n      });\n    });\n  });\n\n  describe('handleFinishedEvent', () => {\n    it('should add info message for MAX_TOKENS finish reason', async () => {\n      // Setup mock to return a stream with MAX_TOKENS finish reason\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'This is a truncated response...',\n          };\n          yield { type: ServerGeminiEventType.Finished, value: 'MAX_TOKENS' };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Submit a query\n      await act(async () => {\n        await result.current.submitQuery('Generate long text');\n      });\n\n      // Check that the info message was added\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          {\n            type: 'info',\n            text: '  Response truncated due to token limits.',\n          },\n          expect.any(Number),\n        );\n      });\n    });\n\n    it('should not add message for STOP finish reason', async () => {\n      // Setup mock to return a stream with STOP finish reason\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'Complete response',\n          };\n          yield { type: ServerGeminiEventType.Finished, value: 'STOP' };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Submit a query\n      await act(async () => {\n        await result.current.submitQuery('Test normal completion');\n      });\n\n      // Wait a bit to ensure no message is added\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      // Check that no info message was added for STOP\n      const infoMessages = mockAddItem.mock.calls.filter(\n        (call) => call[0].type === 'info',\n      );\n      expect(infoMessages).toHaveLength(0);\n    });\n\n    it('should not add message for FINISH_REASON_UNSPECIFIED', async () => {\n      // Setup mock to return a stream with FINISH_REASON_UNSPECIFIED\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'Response with unspecified finish',\n          };\n          yield {\n            type: ServerGeminiEventType.Finished,\n            value: 'FINISH_REASON_UNSPECIFIED',\n          };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Submit a query\n      await act(async () => {\n        await result.current.submitQuery('Test unspecified finish');\n      });\n\n      // Wait a bit to ensure no message is added\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      // Check that no info message was added\n      const infoMessages = mockAddItem.mock.calls.filter(\n        (call) => call[0].type === 'info',\n      );\n      expect(infoMessages).toHaveLength(0);\n    });\n\n    it('should add appropriate messages for other finish reasons', async () => {\n      const testCases = [\n        {\n          reason: 'SAFETY',\n          message: '  Response stopped due to safety reasons.',\n        },\n        {\n          reason: 'RECITATION',\n          message: '  Response stopped due to recitation policy.',\n        },\n        {\n          reason: 'LANGUAGE',\n          message: '  Response stopped due to unsupported language.',\n        },\n        {\n          reason: 'BLOCKLIST',\n          message: '  Response stopped due to forbidden terms.',\n        },\n        {\n          reason: 'PROHIBITED_CONTENT',\n          message: '  Response stopped due to prohibited content.',\n        },\n        {\n          reason: 'SPII',\n          message:\n            '  Response stopped due to sensitive personally identifiable information.',\n        },\n        { reason: 'OTHER', message: '  Response stopped for other reasons.' },\n        {\n          reason: 'MALFORMED_FUNCTION_CALL',\n          message: '  Response stopped due to malformed function call.',\n        },\n        {\n          reason: 'IMAGE_SAFETY',\n          message: '  Response stopped due to image safety violations.',\n        },\n        {\n          reason: 'UNEXPECTED_TOOL_CALL',\n          message: '  Response stopped due to unexpected tool call.',\n        },\n      ];\n\n      for (const { reason, message } of testCases) {\n        // Reset mocks for each test case\n        mockAddItem.mockClear();\n        mockSendMessageStream.mockReturnValue(\n          (async function* () {\n            yield {\n              type: ServerGeminiEventType.Content,\n              value: `Response for ${reason}`,\n            };\n            yield { type: ServerGeminiEventType.Finished, value: reason };\n          })(),\n        );\n\n        const { result } = renderHook(() =>\n          useGeminiStream(\n            new MockedGeminiClientClass(mockConfig),\n            [],\n            mockAddItem,\n            mockConfig,\n            mockOnDebugMessage,\n            mockHandleSlashCommand,\n            false,\n            () => 'vscode' as EditorType,\n            () => {},\n            () => Promise.resolve(),\n            false,\n            () => {},\n            () => {},\n            () => {},\n          ),\n        );\n\n        await act(async () => {\n          await result.current.submitQuery(`Test ${reason}`);\n        });\n\n        await waitFor(() => {\n          expect(mockAddItem).toHaveBeenCalledWith(\n            {\n              type: 'info',\n              text: message,\n            },\n            expect.any(Number),\n          );\n        });\n      }\n    });\n  });\n\n  describe('Thought Reset', () => {\n    it('should reset thought to null when starting a new prompt', async () => {\n      // First, simulate a response with a thought\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Thought,\n            value: {\n              subject: 'Previous thought',\n              description: 'Old description',\n            },\n          };\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'Some response content',\n          };\n          yield { type: ServerGeminiEventType.Finished, value: 'STOP' };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Submit first query to set a thought\n      await act(async () => {\n        await result.current.submitQuery('First query');\n      });\n\n      // Wait for the first response to complete\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'gemini',\n            text: 'Some response content',\n          }),\n          expect.any(Number),\n        );\n      });\n\n      // Now simulate a new response without a thought\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'New response content',\n          };\n          yield { type: ServerGeminiEventType.Finished, value: 'STOP' };\n        })(),\n      );\n\n      // Submit second query - thought should be reset\n      await act(async () => {\n        await result.current.submitQuery('Second query');\n      });\n\n      // The thought should be reset to null when starting the new prompt\n      // We can verify this by checking that the LoadingIndicator would not show the previous thought\n      // The actual thought state is internal to the hook, but we can verify the behavior\n      // by ensuring the second response doesn't show the previous thought\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'gemini',\n            text: 'New response content',\n          }),\n          expect.any(Number),\n        );\n      });\n    });\n\n    it('should reset thought to null when user cancels', async () => {\n      // Mock a stream that yields a thought then gets cancelled\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Thought,\n            value: { subject: 'Some thought', description: 'Description' },\n          };\n          yield { type: ServerGeminiEventType.UserCancelled };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Submit query\n      await act(async () => {\n        await result.current.submitQuery('Test query');\n      });\n\n      // Verify cancellation message was added\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'info',\n            text: 'User cancelled the request.',\n          }),\n          expect.any(Number),\n        );\n      });\n\n      // Verify state is reset to idle\n      expect(result.current.streamingState).toBe(StreamingState.Idle);\n    });\n\n    it('should reset thought to null when there is an error', async () => {\n      // Mock a stream that yields a thought then encounters an error\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Thought,\n            value: { subject: 'Some thought', description: 'Description' },\n          };\n          yield {\n            type: ServerGeminiEventType.Error,\n            value: { error: { message: 'Test error' } },\n          };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      // Submit query\n      await act(async () => {\n        await result.current.submitQuery('Test query');\n      });\n\n      // Verify error message was added\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'error',\n          }),\n          expect.any(Number),\n        );\n      });\n\n      // Verify parseAndFormatApiError was called\n      expect(mockParseAndFormatApiError).toHaveBeenCalledWith(\n        { message: 'Test error' },\n        expect.any(String),\n        undefined,\n        'gemini-2.5-pro',\n        'gemini-2.5-flash',\n      );\n    });\n  });\n\n  it('should process @include commands, adding user turn after processing to prevent race conditions', async () => {\n    const rawQuery = '@include file.txt Summarize this.';\n    const processedQueryParts = [\n      { text: 'Summarize this with content from @file.txt' },\n      { text: 'File content...' },\n    ];\n    const userMessageTimestamp = Date.now();\n    vi.spyOn(Date, 'now').mockReturnValue(userMessageTimestamp);\n\n    handleAtCommandSpy.mockResolvedValue({\n      processedQuery: processedQueryParts,\n      shouldProceed: true,\n    });\n\n    const { result } = renderHook(() =>\n      useGeminiStream(\n        mockConfig.getGeminiClient() as GeminiClient,\n        [],\n        mockAddItem,\n        mockConfig,\n        mockOnDebugMessage,\n        mockHandleSlashCommand,\n        false, // shellModeActive\n        vi.fn(), // getPreferredEditor\n        vi.fn(), // onAuthError\n        vi.fn(), // performMemoryRefresh\n        false, // modelSwitched\n        vi.fn(), // setModelSwitched\n        vi.fn(), // onEditorClose\n        vi.fn(), // onCancelSubmit\n      ),\n    );\n\n    await act(async () => {\n      await result.current.submitQuery(rawQuery);\n    });\n\n    expect(handleAtCommandSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        query: rawQuery,\n      }),\n    );\n\n    expect(mockAddItem).toHaveBeenCalledWith(\n      {\n        type: MessageType.USER,\n        text: rawQuery,\n      },\n      userMessageTimestamp,\n    );\n\n    // FIX: The expectation now matches the actual call signature.\n    expect(mockSendMessageStream).toHaveBeenCalledWith(\n      processedQueryParts, // Argument 1: The parts array directly\n      expect.any(AbortSignal), // Argument 2: An AbortSignal\n      expect.any(String), // Argument 3: The prompt_id string\n    );\n  });\n  describe('Thought Reset', () => {\n    it('should reset thought to null when starting a new prompt', async () => {\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Thought,\n            value: {\n              subject: 'Previous thought',\n              description: 'Old description',\n            },\n          };\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'Some response content',\n          };\n          yield { type: ServerGeminiEventType.Finished, value: 'STOP' };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      await act(async () => {\n        await result.current.submitQuery('First query');\n      });\n\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'gemini',\n            text: 'Some response content',\n          }),\n          expect.any(Number),\n        );\n      });\n\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Content,\n            value: 'New response content',\n          };\n          yield { type: ServerGeminiEventType.Finished, value: 'STOP' };\n        })(),\n      );\n\n      await act(async () => {\n        await result.current.submitQuery('Second query');\n      });\n\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'gemini',\n            text: 'New response content',\n          }),\n          expect.any(Number),\n        );\n      });\n    });\n\n    it('should reset thought to null when user cancels', async () => {\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Thought,\n            value: { subject: 'Some thought', description: 'Description' },\n          };\n          yield { type: ServerGeminiEventType.UserCancelled };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      await act(async () => {\n        await result.current.submitQuery('Test query');\n      });\n\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'info',\n            text: 'User cancelled the request.',\n          }),\n          expect.any(Number),\n        );\n      });\n\n      expect(result.current.streamingState).toBe(StreamingState.Idle);\n    });\n\n    it('should reset thought to null when there is an error', async () => {\n      mockSendMessageStream.mockReturnValue(\n        (async function* () {\n          yield {\n            type: ServerGeminiEventType.Thought,\n            value: { subject: 'Some thought', description: 'Description' },\n          };\n          yield {\n            type: ServerGeminiEventType.Error,\n            value: { error: { message: 'Test error' } },\n          };\n        })(),\n      );\n\n      const { result } = renderHook(() =>\n        useGeminiStream(\n          new MockedGeminiClientClass(mockConfig),\n          [],\n          mockAddItem,\n          mockConfig,\n          mockOnDebugMessage,\n          mockHandleSlashCommand,\n          false,\n          () => 'vscode' as EditorType,\n          () => {},\n          () => Promise.resolve(),\n          false,\n          () => {},\n          () => {},\n          () => {},\n        ),\n      );\n\n      await act(async () => {\n        await result.current.submitQuery('Test query');\n      });\n\n      await waitFor(() => {\n        expect(mockAddItem).toHaveBeenCalledWith(\n          expect.objectContaining({\n            type: 'error',\n          }),\n          expect.any(Number),\n        );\n      });\n\n      expect(mockParseAndFormatApiError).toHaveBeenCalledWith(\n        { message: 'Test error' },\n        expect.any(String),\n        undefined,\n        'gemini-2.5-pro',\n        'gemini-2.5-flash',\n      );\n    });\n  });\n\n  it('should process @include commands, adding user turn after processing to prevent race conditions', async () => {\n    const rawQuery = '@include file.txt Summarize this.';\n    const processedQueryParts = [\n      { text: 'Summarize this with content from @file.txt' },\n      { text: 'File content...' },\n    ];\n    const userMessageTimestamp = Date.now();\n    vi.spyOn(Date, 'now').mockReturnValue(userMessageTimestamp);\n\n    handleAtCommandSpy.mockResolvedValue({\n      processedQuery: processedQueryParts,\n      shouldProceed: true,\n    });\n\n    const { result } = renderHook(() =>\n      useGeminiStream(\n        mockConfig.getGeminiClient() as GeminiClient,\n        [],\n        mockAddItem,\n        mockConfig,\n        mockOnDebugMessage,\n        mockHandleSlashCommand,\n        false,\n        vi.fn(),\n        vi.fn(),\n        vi.fn(),\n        false,\n        vi.fn(),\n        vi.fn(),\n        vi.fn(),\n      ),\n    );\n\n    await act(async () => {\n      await result.current.submitQuery(rawQuery);\n    });\n\n    expect(handleAtCommandSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        query: rawQuery,\n      }),\n    );\n\n    expect(mockAddItem).toHaveBeenCalledWith(\n      {\n        type: MessageType.USER,\n        text: rawQuery,\n      },\n      userMessageTimestamp,\n    );\n\n    // FIX: This expectation now correctly matches the actual function call signature.\n    expect(mockSendMessageStream).toHaveBeenCalledWith(\n      processedQueryParts, // Argument 1: The parts array directly\n      expect.any(AbortSignal), // Argument 2: An AbortSignal\n      expect.any(String), // Argument 3: The prompt_id string\n    );\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useGeminiStream.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useGitBranchName.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useGitBranchName.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useHistoryManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useHistoryManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useInputHistory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useInputHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useKeypress.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useKeypress.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useKittyKeyboardProtocol.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useLoadingIndicator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useLoadingIndicator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useMessageQueue.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useMessageQueue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/usePhraseCycler.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/usePhraseCycler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/usePrivacySettings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/usePrivacySettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/usePromptCompletion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useReactToolScheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useRefreshMemoryCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useReverseSearchCompletion.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useReverseSearchCompletion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useSettingsCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useShellHistory.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useShellHistory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useShowMemoryCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useSlashCompletion.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useSlashCompletion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useStateAndRef.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useTerminalSize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useThemeCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useTimer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useTimer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/useToolScheduler.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":205,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":205,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5358,5361],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5358,5361],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":290,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8350,8353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8350,8353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":324,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":324,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9745,9748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9745,9748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":365,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":365,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10803,10806],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10803,10806],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":416,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":416,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12109,12112],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12109,12112],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":453,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":453,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13176,13179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13176,13179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":489,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":489,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14175,14178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14175,14178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":530,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":530,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15364,15367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15364,15367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":586,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":586,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17041,17044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17041,17044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":658,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":658,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19222,19225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19222,19225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":740,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":740,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21506,21509],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21506,21509],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":741,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":741,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21572,21575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21572,21575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":827,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":827,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23874,23877],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23874,23877],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":832,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":832,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23994,23997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23994,23997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":868,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":868,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24944,24947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24944,24947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":885,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":885,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25381,25384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25381,25384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":995,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":995,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28977,28980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28977,28980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \nimport { describe, it, expect, vi, beforeEach, afterEach, Mock } from 'vitest';\nimport { renderHook, act } from '@testing-library/react';\nimport {\n  useReactToolScheduler,\n  mapToDisplay,\n} from './useReactToolScheduler.js';\nimport { PartUnion, FunctionResponse } from '@google/genai';\nimport {\n  Config,\n  ToolCallRequestInfo,\n  ToolRegistry,\n  ToolResult,\n  ToolCallConfirmationDetails,\n  ToolConfirmationOutcome,\n  ToolCallResponseInfo,\n  ToolCall, // Import from core\n  Status as ToolCallStatusType,\n  ApprovalMode,\n  Kind,\n  BaseDeclarativeTool,\n  BaseToolInvocation,\n  ToolInvocation,\n  AnyDeclarativeTool,\n  AnyToolInvocation,\n} from '@google/gemini-cli-core';\nimport {\n  HistoryItemWithoutId,\n  ToolCallStatus,\n  HistoryItemToolGroup,\n} from '../types.js';\n\n// Mocks\nvi.mock('@google/gemini-cli-core', async () => {\n  const actual = await vi.importActual('@google/gemini-cli-core');\n  return {\n    ...actual,\n    ToolRegistry: vi.fn(),\n    Config: vi.fn(),\n  };\n});\n\nconst mockToolRegistry = {\n  getTool: vi.fn(),\n};\n\nconst mockConfig = {\n  getToolRegistry: vi.fn(() => mockToolRegistry as unknown as ToolRegistry),\n  getApprovalMode: vi.fn(() => ApprovalMode.DEFAULT),\n  getUsageStatisticsEnabled: () => true,\n  getDebugMode: () => false,\n  getSessionId: () => 'test-session-id',\n  getContentGeneratorConfig: () => ({\n    model: 'test-model',\n    authType: 'oauth-personal',\n  }),\n};\n\nclass MockToolInvocation extends BaseToolInvocation<object, ToolResult> {\n  constructor(\n    private readonly tool: MockTool,\n    params: object,\n  ) {\n    super(params);\n  }\n\n  getDescription(): string {\n    return JSON.stringify(this.params);\n  }\n\n  override shouldConfirmExecute(\n    abortSignal: AbortSignal,\n  ): Promise<ToolCallConfirmationDetails | false> {\n    return this.tool.shouldConfirmExecute(this.params, abortSignal);\n  }\n\n  execute(\n    signal: AbortSignal,\n    updateOutput?: (output: string) => void,\n    terminalColumns?: number,\n    terminalRows?: number,\n  ): Promise<ToolResult> {\n    return this.tool.execute(\n      this.params,\n      signal,\n      updateOutput,\n      terminalColumns,\n      terminalRows,\n    );\n  }\n}\n\nclass MockTool extends BaseDeclarativeTool<object, ToolResult> {\n  constructor(\n    name: string,\n    displayName: string,\n    canUpdateOutput = false,\n    shouldConfirm = false,\n    isOutputMarkdown = false,\n  ) {\n    super(\n      name,\n      displayName,\n      'A mock tool for testing',\n      Kind.Other,\n      {},\n      isOutputMarkdown,\n      canUpdateOutput,\n    );\n    if (shouldConfirm) {\n      this.shouldConfirmExecute.mockImplementation(\n        async (): Promise<ToolCallConfirmationDetails | false> => ({\n          type: 'edit',\n          title: 'Mock Tool Requires Confirmation',\n          onConfirm: mockOnUserConfirmForToolConfirmation,\n          filePath: 'mock',\n          fileName: 'mockToolRequiresConfirmation.ts',\n          fileDiff: 'Mock tool requires confirmation',\n          originalContent: 'Original content',\n          newContent: 'New content',\n        }),\n      );\n    }\n  }\n\n  execute = vi.fn();\n  shouldConfirmExecute = vi.fn();\n\n  protected createInvocation(\n    params: object,\n  ): ToolInvocation<object, ToolResult> {\n    return new MockToolInvocation(this, params);\n  }\n}\n\nconst mockTool = new MockTool('mockTool', 'Mock Tool');\nconst mockToolWithLiveOutput = new MockTool(\n  'mockToolWithLiveOutput',\n  'Mock Tool With Live Output',\n  true,\n);\nlet mockOnUserConfirmForToolConfirmation: Mock;\nconst mockToolRequiresConfirmation = new MockTool(\n  'mockToolRequiresConfirmation',\n  'Mock Tool Requires Confirmation',\n  false,\n  true,\n);\n\ndescribe('useReactToolScheduler in YOLO Mode', () => {\n  let onComplete: Mock;\n  let setPendingHistoryItem: Mock;\n\n  beforeEach(() => {\n    onComplete = vi.fn();\n    setPendingHistoryItem = vi.fn();\n    mockToolRegistry.getTool.mockClear();\n    (mockToolRequiresConfirmation.execute as Mock).mockClear();\n    (mockToolRequiresConfirmation.shouldConfirmExecute as Mock).mockClear();\n\n    // IMPORTANT: Enable YOLO mode for this test suite\n    (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.YOLO);\n\n    vi.useFakeTimers();\n  });\n\n  afterEach(() => {\n    vi.clearAllTimers();\n    vi.useRealTimers();\n    // IMPORTANT: Disable YOLO mode after this test suite\n    (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.DEFAULT);\n  });\n\n  const renderSchedulerInYoloMode = () =>\n    renderHook(() =>\n      useReactToolScheduler(\n        onComplete,\n        mockConfig as unknown as Config,\n        setPendingHistoryItem,\n        () => undefined,\n        () => {},\n      ),\n    );\n\n  it('should skip confirmation and execute tool directly when yoloMode is true', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockToolRequiresConfirmation);\n    const expectedOutput = 'YOLO Confirmed output';\n    (mockToolRequiresConfirmation.execute as Mock).mockResolvedValue({\n      llmContent: expectedOutput,\n      returnDisplay: 'YOLO Formatted tool output',\n    } as ToolResult);\n\n    const { result } = renderSchedulerInYoloMode();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'yoloCall',\n      name: 'mockToolRequiresConfirmation',\n      args: { data: 'any data' },\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n\n    await act(async () => {\n      await vi.runAllTimersAsync(); // Process validation\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync(); // Process scheduling\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync(); // Process execution\n    });\n\n    // Check that shouldConfirmExecute was NOT called\n    expect(\n      mockToolRequiresConfirmation.shouldConfirmExecute,\n    ).not.toHaveBeenCalled();\n\n    // Check that execute WAS called\n    expect(mockToolRequiresConfirmation.execute).toHaveBeenCalledWith(\n      request.args,\n      expect.any(AbortSignal),\n      undefined,\n      undefined,\n      undefined,\n    );\n\n    // Check that onComplete was called with success\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'success',\n        request,\n        response: expect.objectContaining({\n          resultDisplay: 'YOLO Formatted tool output',\n          responseParts: [\n            {\n              functionResponse: {\n                id: 'yoloCall',\n                name: 'mockToolRequiresConfirmation',\n                response: { output: expectedOutput },\n              },\n            },\n          ],\n        }),\n      }),\n    ]);\n\n    // Ensure no confirmation UI was triggered (setPendingHistoryItem should not have been called with confirmation details)\n    const setPendingHistoryItemCalls = setPendingHistoryItem.mock.calls;\n    const confirmationCall = setPendingHistoryItemCalls.find((call) => {\n      const item = typeof call[0] === 'function' ? call[0]({}) : call[0];\n      return item?.tools?.[0]?.confirmationDetails;\n    });\n    expect(confirmationCall).toBeUndefined();\n  });\n});\n\ndescribe('useReactToolScheduler', () => {\n  // TODO(ntaylormullen): The following tests are skipped due to difficulties in\n  // reliably testing the asynchronous state updates and interactions with timers.\n  // These tests involve complex sequences of events, including confirmations,\n  // live output updates, and cancellations, which are challenging to assert\n  // correctly with the current testing setup. Further investigation is needed\n  // to find a robust way to test these scenarios.\n  let onComplete: Mock;\n  let setPendingHistoryItem: Mock;\n  let capturedOnConfirmForTest:\n    | ((outcome: ToolConfirmationOutcome) => void | Promise<void>)\n    | undefined;\n\n  beforeEach(() => {\n    onComplete = vi.fn();\n    capturedOnConfirmForTest = undefined;\n    setPendingHistoryItem = vi.fn((updaterOrValue) => {\n      let pendingItem: HistoryItemWithoutId | null = null;\n      if (typeof updaterOrValue === 'function') {\n        // Loosen the type for prevState to allow for more flexible updates in tests\n        const prevState: Partial<HistoryItemToolGroup> = {\n          type: 'tool_group', // Still default to tool_group for most cases\n          tools: [],\n        };\n\n        pendingItem = updaterOrValue(prevState as any); // Allow any for more flexibility\n      } else {\n        pendingItem = updaterOrValue;\n      }\n      // Capture onConfirm if it exists, regardless of the exact type of pendingItem\n      // This is a common pattern in these tests.\n      if (\n        (pendingItem as HistoryItemToolGroup)?.tools?.[0]?.confirmationDetails\n          ?.onConfirm\n      ) {\n        capturedOnConfirmForTest = (pendingItem as HistoryItemToolGroup)\n          .tools[0].confirmationDetails?.onConfirm;\n      }\n    });\n\n    mockToolRegistry.getTool.mockClear();\n    (mockTool.execute as Mock).mockClear();\n    (mockTool.shouldConfirmExecute as Mock).mockClear();\n    (mockToolWithLiveOutput.execute as Mock).mockClear();\n    (mockToolWithLiveOutput.shouldConfirmExecute as Mock).mockClear();\n    (mockToolRequiresConfirmation.execute as Mock).mockClear();\n    (mockToolRequiresConfirmation.shouldConfirmExecute as Mock).mockClear();\n\n    mockOnUserConfirmForToolConfirmation = vi.fn();\n    (\n      mockToolRequiresConfirmation.shouldConfirmExecute as Mock\n    ).mockImplementation(\n      async (): Promise<ToolCallConfirmationDetails | null> =>\n        ({\n          onConfirm: mockOnUserConfirmForToolConfirmation,\n          fileName: 'mockToolRequiresConfirmation.ts',\n          fileDiff: 'Mock tool requires confirmation',\n          type: 'edit',\n          title: 'Mock Tool Requires Confirmation',\n        }) as any,\n    );\n\n    vi.useFakeTimers();\n  });\n\n  afterEach(() => {\n    vi.clearAllTimers();\n    vi.useRealTimers();\n  });\n\n  const renderScheduler = () =>\n    renderHook(() =>\n      useReactToolScheduler(\n        onComplete,\n        mockConfig as unknown as Config,\n        setPendingHistoryItem,\n        () => undefined,\n        () => {},\n      ),\n    );\n\n  it('initial state should be empty', () => {\n    const { result } = renderScheduler();\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it('should schedule and execute a tool call successfully', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockTool);\n    (mockTool.execute as Mock).mockResolvedValue({\n      llmContent: 'Tool output',\n      returnDisplay: 'Formatted tool output',\n    } as ToolResult);\n    (mockTool.shouldConfirmExecute as Mock).mockResolvedValue(null);\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'call1',\n      name: 'mockTool',\n      args: { param: 'value' },\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(mockTool.execute).toHaveBeenCalledWith(\n      request.args,\n      expect.any(AbortSignal),\n      undefined,\n      undefined,\n      undefined,\n    );\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'success',\n        request,\n        response: expect.objectContaining({\n          resultDisplay: 'Formatted tool output',\n          responseParts: [\n            {\n              functionResponse: {\n                id: 'call1',\n                name: 'mockTool',\n                response: { output: 'Tool output' },\n              },\n            },\n          ],\n        }),\n      }),\n    ]);\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it('should handle tool not found', async () => {\n    mockToolRegistry.getTool.mockReturnValue(undefined);\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'call1',\n      name: 'nonexistentTool',\n      args: {},\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'error',\n        request,\n        response: expect.objectContaining({\n          error: expect.objectContaining({\n            message: 'Tool \"nonexistentTool\" not found in registry.',\n          }),\n        }),\n      }),\n    ]);\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it('should handle error during shouldConfirmExecute', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockTool);\n    const confirmError = new Error('Confirmation check failed');\n    (mockTool.shouldConfirmExecute as Mock).mockRejectedValue(confirmError);\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'call1',\n      name: 'mockTool',\n      args: {},\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'error',\n        request,\n        response: expect.objectContaining({\n          error: confirmError,\n        }),\n      }),\n    ]);\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it('should handle error during execute', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockTool);\n    (mockTool.shouldConfirmExecute as Mock).mockResolvedValue(null);\n    const execError = new Error('Execution failed');\n    (mockTool.execute as Mock).mockRejectedValue(execError);\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'call1',\n      name: 'mockTool',\n      args: {},\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'error',\n        request,\n        response: expect.objectContaining({\n          error: execError,\n        }),\n      }),\n    ]);\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it.skip('should handle tool requiring confirmation - approved', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockToolRequiresConfirmation);\n    const expectedOutput = 'Confirmed output';\n    (mockToolRequiresConfirmation.execute as Mock).mockResolvedValue({\n      llmContent: expectedOutput,\n      returnDisplay: 'Confirmed display',\n    } as ToolResult);\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'callConfirm',\n      name: 'mockToolRequiresConfirmation',\n      args: { data: 'sensitive' },\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(setPendingHistoryItem).toHaveBeenCalled();\n    expect(capturedOnConfirmForTest).toBeDefined();\n\n    await act(async () => {\n      await capturedOnConfirmForTest?.(ToolConfirmationOutcome.ProceedOnce);\n    });\n\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(mockOnUserConfirmForToolConfirmation).toHaveBeenCalledWith(\n      ToolConfirmationOutcome.ProceedOnce,\n    );\n    expect(mockToolRequiresConfirmation.execute).toHaveBeenCalled();\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'success',\n        request,\n        response: expect.objectContaining({\n          resultDisplay: 'Confirmed display',\n          responseParts: expect.arrayContaining([\n            expect.objectContaining({\n              functionResponse: expect.objectContaining({\n                response: { output: expectedOutput },\n              }),\n            }),\n          ]),\n        }),\n      }),\n    ]);\n  });\n\n  it.skip('should handle tool requiring confirmation - cancelled by user', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockToolRequiresConfirmation);\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'callConfirmCancel',\n      name: 'mockToolRequiresConfirmation',\n      args: {},\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(setPendingHistoryItem).toHaveBeenCalled();\n    expect(capturedOnConfirmForTest).toBeDefined();\n\n    await act(async () => {\n      await capturedOnConfirmForTest?.(ToolConfirmationOutcome.Cancel);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(mockOnUserConfirmForToolConfirmation).toHaveBeenCalledWith(\n      ToolConfirmationOutcome.Cancel,\n    );\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'cancelled',\n        request,\n        response: expect.objectContaining({\n          responseParts: expect.arrayContaining([\n            expect.objectContaining({\n              functionResponse: expect.objectContaining({\n                response: expect.objectContaining({\n                  error: `User did not allow tool call ${request.name}. Reason: User cancelled.`,\n                }),\n              }),\n            }),\n          ]),\n        }),\n      }),\n    ]);\n  });\n\n  it.skip('should handle live output updates', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockToolWithLiveOutput);\n    let liveUpdateFn: ((output: string) => void) | undefined;\n    let resolveExecutePromise: (value: ToolResult) => void;\n    const executePromise = new Promise<ToolResult>((resolve) => {\n      resolveExecutePromise = resolve;\n    });\n\n    (mockToolWithLiveOutput.execute as Mock).mockImplementation(\n      async (\n        _args: Record<string, unknown>,\n        _signal: AbortSignal,\n        updateFn: ((output: string) => void) | undefined,\n      ) => {\n        liveUpdateFn = updateFn;\n        return executePromise;\n      },\n    );\n    (mockToolWithLiveOutput.shouldConfirmExecute as Mock).mockResolvedValue(\n      null,\n    );\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request: ToolCallRequestInfo = {\n      callId: 'liveCall',\n      name: 'mockToolWithLiveOutput',\n      args: {},\n    } as any;\n\n    act(() => {\n      schedule(request, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(liveUpdateFn).toBeDefined();\n    expect(setPendingHistoryItem).toHaveBeenCalled();\n\n    await act(async () => {\n      liveUpdateFn?.('Live output 1');\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    await act(async () => {\n      liveUpdateFn?.('Live output 2');\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    act(() => {\n      resolveExecutePromise({\n        llmContent: 'Final output',\n        returnDisplay: 'Final display',\n      } as ToolResult);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'success',\n        request,\n        response: expect.objectContaining({\n          resultDisplay: 'Final display',\n          responseParts: expect.arrayContaining([\n            expect.objectContaining({\n              functionResponse: expect.objectContaining({\n                response: { output: 'Final output' },\n              }),\n            }),\n          ]),\n        }),\n      }),\n    ]);\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it('should schedule and execute multiple tool calls', async () => {\n    const tool1 = new MockTool('tool1', 'Tool 1');\n    tool1.execute.mockResolvedValue({\n      llmContent: 'Output 1',\n      returnDisplay: 'Display 1',\n    } as ToolResult);\n    tool1.shouldConfirmExecute.mockResolvedValue(null);\n\n    const tool2 = new MockTool('tool2', 'Tool 2');\n    tool2.execute.mockResolvedValue({\n      llmContent: 'Output 2',\n      returnDisplay: 'Display 2',\n    } as ToolResult);\n    tool2.shouldConfirmExecute.mockResolvedValue(null);\n\n    mockToolRegistry.getTool.mockImplementation((name) => {\n      if (name === 'tool1') return tool1;\n      if (name === 'tool2') return tool2;\n      return undefined;\n    });\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const requests: ToolCallRequestInfo[] = [\n      { callId: 'multi1', name: 'tool1', args: { p: 1 } } as any,\n      { callId: 'multi2', name: 'tool2', args: { p: 2 } } as any,\n    ];\n\n    act(() => {\n      schedule(requests, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(onComplete).toHaveBeenCalledTimes(1);\n    const completedCalls = onComplete.mock.calls[0][0] as ToolCall[];\n    expect(completedCalls.length).toBe(2);\n\n    const call1Result = completedCalls.find(\n      (c) => c.request.callId === 'multi1',\n    );\n    const call2Result = completedCalls.find(\n      (c) => c.request.callId === 'multi2',\n    );\n\n    expect(call1Result).toMatchObject({\n      status: 'success',\n      request: requests[0],\n      response: expect.objectContaining({\n        resultDisplay: 'Display 1',\n        responseParts: [\n          {\n            functionResponse: {\n              id: 'multi1',\n              name: 'tool1',\n              response: { output: 'Output 1' },\n            },\n          },\n        ],\n      }),\n    });\n    expect(call2Result).toMatchObject({\n      status: 'success',\n      request: requests[1],\n      response: expect.objectContaining({\n        resultDisplay: 'Display 2',\n        responseParts: [\n          {\n            functionResponse: {\n              id: 'multi2',\n              name: 'tool2',\n              response: { output: 'Output 2' },\n            },\n          },\n        ],\n      }),\n    });\n    expect(result.current[0]).toEqual([]);\n  });\n\n  it.skip('should throw error if scheduling while already running', async () => {\n    mockToolRegistry.getTool.mockReturnValue(mockTool);\n    const longExecutePromise = new Promise<ToolResult>((resolve) =>\n      setTimeout(\n        () =>\n          resolve({\n            llmContent: 'done',\n            returnDisplay: 'done display',\n          }),\n        50,\n      ),\n    );\n    (mockTool.execute as Mock).mockReturnValue(longExecutePromise);\n    (mockTool.shouldConfirmExecute as Mock).mockResolvedValue(null);\n\n    const { result } = renderScheduler();\n    const schedule = result.current[1];\n    const request1: ToolCallRequestInfo = {\n      callId: 'run1',\n      name: 'mockTool',\n      args: {},\n    } as any;\n    const request2: ToolCallRequestInfo = {\n      callId: 'run2',\n      name: 'mockTool',\n      args: {},\n    } as any;\n\n    act(() => {\n      schedule(request1, new AbortController().signal);\n    });\n    await act(async () => {\n      await vi.runAllTimersAsync();\n    });\n\n    expect(() => schedule(request2, new AbortController().signal)).toThrow(\n      'Cannot schedule tool calls while other tool calls are running',\n    );\n\n    await act(async () => {\n      await vi.advanceTimersByTimeAsync(50);\n      await vi.runAllTimersAsync();\n      await act(async () => {\n        await vi.runAllTimersAsync();\n      });\n    });\n    expect(onComplete).toHaveBeenCalledWith([\n      expect.objectContaining({\n        status: 'success',\n        request: request1,\n        response: expect.objectContaining({ resultDisplay: 'done display' }),\n      }),\n    ]);\n    expect(result.current[0]).toEqual([]);\n  });\n});\n\ndescribe('mapToDisplay', () => {\n  const baseRequest: ToolCallRequestInfo = {\n    callId: 'testCallId',\n    name: 'testTool',\n    args: { foo: 'bar' },\n  } as any;\n\n  const baseTool = new MockTool('testTool', 'Test Tool Display');\n\n  const baseResponse: ToolCallResponseInfo = {\n    callId: 'testCallId',\n    responseParts: [\n      {\n        functionResponse: {\n          name: 'testTool',\n          id: 'testCallId',\n          response: { output: 'Test output' },\n        } as FunctionResponse,\n      } as PartUnion,\n    ],\n    resultDisplay: 'Test display output',\n    error: undefined,\n  } as any;\n\n  // Define a more specific type for extraProps for these tests\n  // This helps ensure that tool and confirmationDetails are only accessed when they are expected to exist.\n  type MapToDisplayExtraProps =\n    | {\n        tool?: AnyDeclarativeTool;\n        invocation?: AnyToolInvocation;\n        liveOutput?: string;\n        response?: ToolCallResponseInfo;\n        confirmationDetails?: ToolCallConfirmationDetails;\n      }\n    | {\n        tool: AnyDeclarativeTool;\n        invocation?: AnyToolInvocation;\n        response?: ToolCallResponseInfo;\n        confirmationDetails?: ToolCallConfirmationDetails;\n      }\n    | {\n        response: ToolCallResponseInfo;\n        tool?: undefined;\n        confirmationDetails?: ToolCallConfirmationDetails;\n      }\n    | {\n        confirmationDetails: ToolCallConfirmationDetails;\n        tool?: AnyDeclarativeTool;\n        invocation?: AnyToolInvocation;\n        response?: ToolCallResponseInfo;\n      };\n\n  const baseInvocation = baseTool.build(baseRequest.args);\n  const testCases: Array<{\n    name: string;\n    status: ToolCallStatusType;\n    extraProps?: MapToDisplayExtraProps;\n    expectedStatus: ToolCallStatus;\n    expectedResultDisplay?: string;\n    expectedName?: string;\n    expectedDescription?: string;\n  }> = [\n    {\n      name: 'validating',\n      status: 'validating',\n      extraProps: { tool: baseTool, invocation: baseInvocation },\n      expectedStatus: ToolCallStatus.Executing,\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'awaiting_approval',\n      status: 'awaiting_approval',\n      extraProps: {\n        tool: baseTool,\n        invocation: baseInvocation,\n        confirmationDetails: {\n          onConfirm: vi.fn(),\n          type: 'edit',\n          title: 'Test Tool Display',\n          serverName: 'testTool',\n          toolName: 'testTool',\n          toolDisplayName: 'Test Tool Display',\n          filePath: 'mock',\n          fileName: 'test.ts',\n          fileDiff: 'Test diff',\n          originalContent: 'Original content',\n          newContent: 'New content',\n        } as ToolCallConfirmationDetails,\n      },\n      expectedStatus: ToolCallStatus.Confirming,\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'scheduled',\n      status: 'scheduled',\n      extraProps: { tool: baseTool, invocation: baseInvocation },\n      expectedStatus: ToolCallStatus.Pending,\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'executing no live output',\n      status: 'executing',\n      extraProps: { tool: baseTool, invocation: baseInvocation },\n      expectedStatus: ToolCallStatus.Executing,\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'executing with live output',\n      status: 'executing',\n      extraProps: {\n        tool: baseTool,\n        invocation: baseInvocation,\n        liveOutput: 'Live test output',\n      },\n      expectedStatus: ToolCallStatus.Executing,\n      expectedResultDisplay: 'Live test output',\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'success',\n      status: 'success',\n      extraProps: {\n        tool: baseTool,\n        invocation: baseInvocation,\n        response: baseResponse,\n      },\n      expectedStatus: ToolCallStatus.Success,\n      expectedResultDisplay: baseResponse.resultDisplay as any,\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'error tool not found',\n      status: 'error',\n      extraProps: {\n        response: {\n          ...baseResponse,\n          error: new Error('Test error tool not found'),\n          resultDisplay: 'Error display tool not found',\n        },\n      },\n      expectedStatus: ToolCallStatus.Error,\n      expectedResultDisplay: 'Error display tool not found',\n      expectedName: baseRequest.name,\n      expectedDescription: JSON.stringify(baseRequest.args),\n    },\n    {\n      name: 'error tool execution failed',\n      status: 'error',\n      extraProps: {\n        tool: baseTool,\n        response: {\n          ...baseResponse,\n          error: new Error('Tool execution failed'),\n          resultDisplay: 'Execution failed display',\n        },\n      },\n      expectedStatus: ToolCallStatus.Error,\n      expectedResultDisplay: 'Execution failed display',\n      expectedName: baseTool.displayName, // Changed from baseTool.name\n      expectedDescription: baseInvocation.getDescription(),\n    },\n    {\n      name: 'cancelled',\n      status: 'cancelled',\n      extraProps: {\n        tool: baseTool,\n        invocation: baseInvocation,\n        response: {\n          ...baseResponse,\n          resultDisplay: 'Cancelled display',\n        },\n      },\n      expectedStatus: ToolCallStatus.Canceled,\n      expectedResultDisplay: 'Cancelled display',\n      expectedName: baseTool.displayName,\n      expectedDescription: baseInvocation.getDescription(),\n    },\n  ];\n\n  testCases.forEach(\n    ({\n      name: testName,\n      status,\n      extraProps,\n      expectedStatus,\n      expectedResultDisplay,\n      expectedName,\n      expectedDescription,\n    }) => {\n      it(`should map ToolCall with status '${status}' (${testName}) correctly`, () => {\n        const toolCall: ToolCall = {\n          request: baseRequest,\n          status,\n          ...(extraProps || {}),\n        } as ToolCall;\n\n        const display = mapToDisplay(toolCall);\n        expect(display.type).toBe('tool_group');\n        expect(display.tools.length).toBe(1);\n        const toolDisplay = display.tools[0];\n\n        expect(toolDisplay.callId).toBe(baseRequest.callId);\n        expect(toolDisplay.status).toBe(expectedStatus);\n        expect(toolDisplay.resultDisplay).toBe(expectedResultDisplay);\n\n        expect(toolDisplay.name).toBe(expectedName);\n        expect(toolDisplay.description).toBe(expectedDescription);\n\n        expect(toolDisplay.renderOutputAsMarkdown).toBe(\n          extraProps?.tool?.isOutputMarkdown ?? false,\n        );\n        if (status === 'awaiting_approval') {\n          expect(toolDisplay.confirmationDetails).toBe(\n            extraProps!.confirmationDetails,\n          );\n        } else {\n          expect(toolDisplay.confirmationDetails).toBeUndefined();\n        }\n      });\n    },\n  );\n\n  it('should map an array of ToolCalls correctly', () => {\n    const toolCall1: ToolCall = {\n      request: { ...baseRequest, callId: 'call1' },\n      status: 'success',\n      tool: baseTool,\n      invocation: baseTool.build(baseRequest.args),\n      response: { ...baseResponse, callId: 'call1' },\n    } as ToolCall;\n    const toolForCall2 = new MockTool(\n      baseTool.name,\n      baseTool.displayName,\n      false,\n      false,\n      true,\n    );\n    const toolCall2: ToolCall = {\n      request: { ...baseRequest, callId: 'call2' },\n      status: 'executing',\n      tool: toolForCall2,\n      invocation: toolForCall2.build(baseRequest.args),\n      liveOutput: 'markdown output',\n    } as ToolCall;\n\n    const display = mapToDisplay([toolCall1, toolCall2]);\n    expect(display.tools.length).toBe(2);\n    expect(display.tools[0].callId).toBe('call1');\n    expect(display.tools[0].status).toBe(ToolCallStatus.Success);\n    expect(display.tools[0].renderOutputAsMarkdown).toBe(false);\n    expect(display.tools[1].callId).toBe('call2');\n    expect(display.tools[1].status).toBe(ToolCallStatus.Executing);\n    expect(display.tools[1].resultDisplay).toBe('markdown output');\n    expect(display.tools[1].renderOutputAsMarkdown).toBe(true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/vim.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/hooks/vim.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/keyMatchers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/keyMatchers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/privacy/CloudFreePrivacyNotice.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/privacy/CloudPaidPrivacyNotice.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/privacy/GeminiPrivacyNotice.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/privacy/PrivacyNotice.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/semantic-colors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/ansi-light.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/ansi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/atom-one-dark.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/ayu-light.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/ayu.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/color-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/color-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/default-light.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/default.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/dracula.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/github-dark.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/github-light.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/googlecode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/mew.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/no-color.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/semantic-tokens.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/shades-of-purple.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/theme-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/theme-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/theme.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/theme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/themes/xcode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/CodeColorizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/ConsolePatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/InlineMarkdownRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/MarkdownDisplay.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/MarkdownDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/TableRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/clipboardUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/clipboardUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/commandUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/commandUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/computeStats.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/computeStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/displayUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/displayUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/formatters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/isNarrowWidth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/kittyProtocolDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/markdownUtilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/markdownUtilities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/platformConstants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/terminalSetup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/textUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/updateCheck.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/ui/utils/updateCheck.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/checks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/cleanup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/dialogScopeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/gitUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/gitUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/handleAutoUpdate.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/handleAutoUpdate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/installationInfo.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/installationInfo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/license.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/license.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/package.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/readStdin.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/readStdin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/resolvePath.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/sandbox.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/settingsUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/settingsUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/spawnWrapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/startupWarnings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/startupWarnings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/updateEventEmitter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/userStartupWarnings.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/userStartupWarnings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/utils/version.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/validateNonInterActiveAuth.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/validateNonInterActiveAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/zed-integration/acp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/zed-integration/fileSystemService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/zed-integration/schema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/src/zed-integration/zedIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/cli/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/__mocks__/fs/promises.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ast/adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ast/finder.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[770,773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[770,773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":146,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":146,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4142,4145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4142,4145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":147,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4184,4187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4184,4187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":159,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4544,4547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4544,4547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":160,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4580,4583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4580,4583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":162,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4644,4647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4644,4647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5948,5951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5948,5951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5982,5985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5982,5985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":238,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6554,6557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6554,6557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7367,7370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7367,7370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":262,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":262,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7399,7402],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7399,7402],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":263,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7458,7461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7458,7461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":267,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7574,7577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7574,7577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":281,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7941,7944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7941,7944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":281,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":281,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7956,7959],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7956,7959],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8677,8680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8677,8680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":310,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8839,8842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8839,8842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":310,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8871,8874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8871,8874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":311,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":311,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8918,8921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8918,8921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":325,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":325,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9273,9276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9273,9276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":344,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":344,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9747,9750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9747,9750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Node, SourceFile, SyntaxKind } from 'ts-morph';\nimport { DictionaryQuery } from './models.js';\n\n// Simple in-memory cache for query results (keyed by stringified query)\nconst queryCache = new Map<string, Node[]>();\n\n/**\n * Enhanced XPath-like parser for simple node tests and predicates.\n * Supports: //Node, /Node, ./Node, ../Node, predicates: [@attr='val'], [contains(@attr,'val')], [starts-with(@attr,'val')], [123]\n */\nclass EnhancedXPathParser {\n  parse(xpath: string) {\n    const parts = {\n      axis: 'descendant-or-self' as\n        | 'descendant-or-self'\n        | 'child'\n        | 'parent'\n        | 'self',\n      nodeTest: '' as string,\n      conditions: [] as any[],\n      position: undefined as number | undefined,\n    };\n\n    let expr = xpath.trim();\n    if (expr.startsWith('//')) {\n      parts.axis = 'descendant-or-self';\n      expr = expr.slice(2);\n    } else if (expr.startsWith('../')) {\n      parts.axis = 'parent';\n      expr = expr.slice(3);\n    } else if (expr.startsWith('./')) {\n      parts.axis = 'self';\n      expr = expr.slice(2);\n    } else if (expr.startsWith('/')) {\n      parts.axis = 'child';\n      expr = expr.slice(1);\n    }\n\n    // split node test and predicates\n    const predicateMatch = expr.match(/^([^[]+)(\\[[\\s\\S]+\\])?/);\n    if (!predicateMatch) return parts;\n    parts.nodeTest = predicateMatch[1].trim();\n\n    const predicates = Array.from(expr.matchAll(/\\[([^\\]]+)\\]/g)).map((m) =>\n      m[1].trim(),\n    );\n    for (const pred of predicates) {\n      // position\n      if (/^\\d+$/.test(pred)) {\n        parts.position = Number(pred);\n        continue;\n      }\n      // attribute equality @attr='value'\n      const attrEq = pred.match(/^@([\\w$]+)\\s*=\\s*(['\"])([\\s\\S]+)\\2$/);\n      if (attrEq) {\n        parts.conditions.push({\n          type: 'attribute',\n          field: attrEq[1],\n          operator: 'eq',\n          value: attrEq[3],\n        });\n        continue;\n      }\n      // attribute not equals\n      const attrNe = pred.match(/^@([\\w$]+)\\s*!=\\s*(['\"])([\\s\\S]+)\\2$/);\n      if (attrNe) {\n        parts.conditions.push({\n          type: 'attribute',\n          field: attrNe[1],\n          operator: 'ne',\n          value: attrNe[3],\n        });\n        continue;\n      }\n      // contains(@attr, 'val')\n      const contains = pred.match(\n        /^contains\\(\\s*@([\\w$]+)\\s*,\\s*(['\"])([\\s\\S]+)\\2\\s*\\)$/,\n      );\n      if (contains) {\n        parts.conditions.push({\n          type: 'attribute',\n          field: contains[1],\n          operator: 'contains',\n          value: contains[3],\n        });\n        continue;\n      }\n      // starts-with(@attr, 'val')\n      const starts = pred.match(\n        /^starts-with\\(\\s*@([\\w$]+)\\s*,\\s*(['\"])([\\s\\S]+)\\2\\s*\\)$/,\n      );\n      if (starts) {\n        parts.conditions.push({\n          type: 'attribute',\n          field: starts[1],\n          operator: 'starts_with',\n          value: starts[3],\n        });\n        continue;\n      }\n\n      // fallback: raw condition\n      parts.conditions.push({ type: 'raw', raw: pred });\n    }\n\n    return parts;\n  }\n}\n\n/**\n * Finds nodes in a ts-morph AST that match a given query.\n *\n * Extended behavior:\n * - query can be a DictionaryQuery (existing behavior)\n * - query can be a string (interpreted as an XPath-like expression parsed above)\n * - query can be an object with { xpath: string } or { custom: (node)=>boolean }\n *\n * Caches results for string/xpath queries.\n */\nexport function findNodes(\n  sourceFile: SourceFile,\n  query:\n    | DictionaryQuery\n    | string\n    | { xpath?: string; custom?: (n: Node) => boolean },\n): Node[] {\n  // Support raw xpath string directly\n  if (typeof query === 'string') {\n    // use cache\n    const key = `xpath:${query}`;\n    if (queryCache.has(key)) return queryCache.get(key)!;\n    const parser = new EnhancedXPathParser();\n    const parsed = parser.parse(query);\n    const nodes = findByXPath(sourceFile, parsed);\n    queryCache.set(key, nodes);\n    return nodes;\n  }\n\n  // Support object with xpath or custom\n  if (typeof query === 'object' && (query as any).xpath) {\n    const xpath = (query as any).xpath as string;\n    const key = `xpath:${xpath}`;\n    if (queryCache.has(key)) return queryCache.get(key)!;\n    const parser = new EnhancedXPathParser();\n    const parsed = parser.parse(xpath);\n    const nodes = findByXPath(sourceFile, parsed);\n    queryCache.set(key, nodes);\n    return nodes;\n  }\n\n  if (\n    typeof query === 'object' &&\n    (query as any).custom &&\n    typeof (query as any).custom === 'function'\n  ) {\n    const customFn = (query as any).custom as (n: Node) => boolean;\n    return findByCustom(sourceFile, customFn);\n  }\n\n  // Fallback to original dictionary query behavior\n  const results: Node[] = [];\n  const descendants = sourceFile.getDescendants();\n\n  for (const node of descendants) {\n    if (matchesQuery(node, { conditions: query } as DictionaryQuery)) {\n      results.push(node);\n    }\n  }\n\n  return results;\n}\n\n/**\n * Find nodes using a custom function.\n */\nfunction findByCustom(\n  sourceFile: SourceFile,\n  fn: (n: Node) => boolean,\n): Node[] {\n  const found: Node[] = [];\n  for (const n of sourceFile.getDescendants()) {\n    try {\n      if (fn(n)) found.push(n);\n    } catch (_err) {\n      // ignore errors in user-provided function\n      void _err;\n    }\n  }\n  return found;\n}\n\n/**\n * Find nodes by parsed XPath-like expression.\n */\nfunction findByXPath(\n  sourceFile: SourceFile,\n  parsed: ReturnType<EnhancedXPathParser['parse']>,\n): Node[] {\n  const candidates: Node[] = [];\n  const nodeTest = parsed.nodeTest;\n  if (!nodeTest) return [];\n  const descendants =\n    parsed.axis === 'child'\n      ? sourceFile.getChildren()\n      : sourceFile.getDescendants();\n\n  for (const node of descendants) {\n    // match by kind name (e.g. FunctionDeclaration, ClassDeclaration, VariableStatement...)\n    const kindName = (node as any).getKindName\n      ? (node as any).getKindName()\n      : SyntaxKind[node.getKind()];\n    if (kindName === nodeTest || node.getKind().toString() === nodeTest) {\n      if (matchesParsedConditions(node, parsed.conditions)) {\n        candidates.push(node);\n      }\n    }\n  }\n\n  // if a position was requested\n  if (typeof parsed.position === 'number') {\n    return candidates.length >= parsed.position\n      ? [candidates[parsed.position - 1]]\n      : [];\n  }\n\n  return candidates;\n}\n\n/**\n * Evaluate parsed predicate conditions against a node.\n */\nfunction matchesParsedConditions(node: Node, conditions: any[]): boolean {\n  if (!conditions || conditions.length === 0) return true;\n  for (const cond of conditions) {\n    if (cond.type === 'attribute') {\n      const val = extractAttributeValue(node, cond.field);\n      if (!compareValues(val, cond.value, cond.operator)) return false;\n    } else if (cond.type === 'raw') {\n      // best-effort: check raw string existence in node text\n      if (!node.getText().includes(cond.raw)) return false;\n    } else {\n      // unknown predicate: fail-safe to false\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Extracts a best-effort attribute value from a Node.\n * Supports common properties: name, getName(), getText(), getType?.getText()\n */\nfunction extractAttributeValue(node: Node, field: string): string | undefined {\n  try {\n    // named nodes\n    if ((node as any).getName && typeof (node as any).getName === 'function') {\n      const name = (node as any).getName();\n      if (field === 'name') return name;\n    }\n    // try direct property\n    const prop = (node as any)[field];\n    if (typeof prop === 'string') return prop;\n    if (prop && typeof prop === 'object' && typeof prop.getText === 'function')\n      return prop.getText();\n    // fallback to text search\n    return node.getText();\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Compare helper supporting eq, ne, contains, starts_with.\n */\nfunction compareValues(actual: any, expected: any, operator: string) {\n  if (operator === 'eq') return String(actual) === String(expected);\n  if (operator === 'ne') return String(actual) !== String(expected);\n  if (operator === 'contains') return String(actual).includes(String(expected));\n  if (operator === 'starts_with')\n    return String(actual).startsWith(String(expected));\n  return false;\n}\n\n/**\n * Checks if a given AST node matches the conditions of a DictionaryQuery.\n */\nfunction matchesQuery(node: Node, query: DictionaryQuery): boolean {\n  const { conditions } = query;\n\n  // Check kind\n  if (conditions.kind) {\n    const kinds = Array.isArray(conditions.kind)\n      ? conditions.kind\n      : [conditions.kind];\n    if (!kinds.includes(node.getKind() as any)) {\n      return false;\n    }\n  }\n\n  // Check name\n  if (conditions.name) {\n    // Named nodes in ts-morph may have getName()\n    const name =\n      (node as any).getName && typeof (node as any).getName === 'function'\n        ? (node as any).getName()\n        : undefined;\n    if (name !== conditions.name) return false;\n  }\n\n  // Check for parent condition\n  if (conditions.parent) {\n    let parent = node.getParent();\n    let matched = false;\n    while (parent) {\n      if (\n        matchesQuery(parent, {\n          type: 'dictionary',\n          conditions: conditions.parent,\n        } as any)\n      ) {\n        matched = true;\n        break;\n      }\n      parent = parent.getParent();\n    }\n    if (!matched) return false;\n  }\n\n  // Check for child condition: ensure at least one direct child matches\n  if (conditions.child) {\n    const children = node.getChildren();\n    let hasMatchingChild = false;\n    for (const child of children) {\n      if (\n        matchesQuery(child, {\n          type: 'dictionary',\n          conditions: conditions.child,\n        } as any)\n      ) {\n        hasMatchingChild = true;\n        break;\n      }\n    }\n    if (!hasMatchingChild) return false;\n  }\n\n  return true;\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ast/models.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ast/modifier.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1916,1919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1916,1919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1936,1939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1936,1939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2002,2005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2002,2005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2713,2716],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2713,2716],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2799,2802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2799,2802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3147,3150],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3147,3150],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":173,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5096,5099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5096,5099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5410,5413],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5410,5413],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":207,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6352,6355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6352,6355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9175,9178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9175,9178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":293,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9223,9226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9223,9226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":296,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9354,9357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9354,9357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":297,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":297,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9393,9396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9393,9396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":303,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9578,9581],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9578,9581],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":304,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":304,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9635,9638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9635,9638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11536,11539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11536,11539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11573,11576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11573,11576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":366,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11669,11672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11669,11672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":366,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11690,11693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11690,11693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":386,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12266,12269],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12266,12269],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":386,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12290,12293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12290,12293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":408,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":408,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13003,13006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13003,13006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":409,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13058,13061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13058,13061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":410,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":410,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13107,13110],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13107,13110],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":411,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":411,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13175,13178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13175,13178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":25,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport crypto from 'crypto';\nimport {\n  Project,\n  SourceFile,\n  Node,\n  ClassDeclaration,\n  SyntaxKind,\n} from 'ts-morph';\nimport { findNodes } from './finder.js';\nimport { ModificationSpec, ModificationOperation } from './models.js';\n\ntype ModifierResult = {\n  success: boolean;\n  output?: string;\n  error?: string;\n  modifiedText?: string;\n  backupId?: string;\n};\n\nexport class ASTModifier {\n  private backups = new Map<string, string>();\n\n  constructor(\n    private readonly projectOptions: { useInMemoryFileSystem?: boolean } = {\n      useInMemoryFileSystem: true,\n    },\n  ) {}\n\n  private createProject() {\n    return new Project({\n      useInMemoryFileSystem: !!this.projectOptions.useInMemoryFileSystem,\n    });\n  }\n\n  private createBackup(sourceText: string) {\n    const id = crypto\n      .createHash('md5')\n      .update(sourceText + Date.now().toString())\n      .digest('hex')\n      .slice(0, 12);\n    this.backups.set(id, sourceText);\n    return id;\n  }\n\n  private restoreBackup(id: string): string | undefined {\n    return this.backups.get(id);\n  }\n\n  /**\n   * Apply a list of modifications to a source text. Returns modified text on success,\n   * or restores the backup and returns an error on failure.\n   */\n  async applyModifications(\n    sourceText: string,\n    modifications: ModificationSpec[],\n    opts?: { filePath?: string; format?: boolean },\n  ): Promise<ModifierResult> {\n    const project = this.createProject();\n    const filePath = opts?.filePath ?? '/virtual-file.ts';\n    const sourceFile = project.createSourceFile(filePath, sourceText, {\n      overwrite: true,\n    });\n\n    const backupId = this.createBackup(sourceText);\n\n  try {\n      // Group modifications by target nodes if possible, otherwise apply sequentially\n      for (const mod of modifications) {\n        const targetQuery = (mod as any).targetQuery as any;\n        const targets = findNodes(sourceFile, targetQuery as any);\n\n        // If target nodes found, apply to each. If none, try to apply at file-level (e.g., add_import/add_class)\n        if (targets && targets.length > 0) {\n          for (const node of targets) {\n            await this.applyModificationToNode(sourceFile, node, mod);\n          }\n        } else {\n          // file-level ops\n          await this.applyFileLevelModification(sourceFile, mod);\n        }\n      }\n\n      // Save / format optionally\n      let modifiedText = sourceFile.getFullText();\n      if (opts?.format) {\n        try {\n          // try prettier if available (dynamic import to avoid require)\n          const prettier = await import('prettier');\n          const cfg = await (prettier as any).resolveConfig(filePath).catch(() => ({}));\n          modifiedText = (prettier as any).format(modifiedText, {\n            ...(cfg || {}),\n            filepath: filePath,\n          });\n        } catch {\n          // ignore formatting errors, return raw modified text\n        }\n      }\n\n      return {\n        success: true,\n        output: 'Modifications applied',\n        modifiedText,\n        backupId,\n      };\n    } catch (_e: any) {\n      const restored = this.restoreBackup(backupId);\n      return {\n        success: false,\n        error: String(_e),\n        output: 'Restored from backup',\n        modifiedText: restored,\n        backupId,\n      };\n    }\n  }\n\n  private async applyFileLevelModification(\n    sourceFile: SourceFile,\n    mod: ModificationSpec,\n  ): Promise<void> {\n    switch (mod.operation) {\n      case ModificationOperation.ADD_IMPORT:\n        if (!mod.newCode) throw new Error('add_import requires newCode');\n        // Insert import at top\n        sourceFile.insertText(0, mod.newCode.trim() + '\\n');\n        break;\n      case ModificationOperation.ADD_CLASS: {\n        if (!mod.newCode) throw new Error('add_class requires newCode');\n        // Try to find sensible insertion point: after last import or at top\n        const imports = sourceFile.getImportDeclarations();\n        if (imports.length > 0) {\n          const lastImp = imports[imports.length - 1];\n          sourceFile.insertText(lastImp.getEnd(), '\\n' + mod.newCode);\n        } else {\n          sourceFile.insertStatements(0, mod.newCode);\n        }\n        break;\n      }\n      default:\n        // unsupported at file-level; nothing to do\n        break;\n    }\n  }\n\n  private async applyModificationToNode(\n    sourceFile: SourceFile,\n    node: Node,\n    mod: ModificationSpec,\n  ): Promise<void> {\n    switch (mod.operation) {\n      case ModificationOperation.REPLACE:\n        if (!mod.newCode) throw new Error('replace requires newCode');\n        node.replaceWithText(mod.newCode);\n        break;\n\n      case ModificationOperation.INSERT_BEFORE:\n      case ModificationOperation.INSERT_AFTER:\n        if (!mod.newCode) throw new Error('insert requires newCode');\n        await this.insertRelative(\n          node,\n          mod.newCode,\n          mod.operation === ModificationOperation.INSERT_BEFORE,\n        );\n        break;\n\n      case ModificationOperation.DELETE:\n        (node as any).remove();\n        break;\n\n      case ModificationOperation.MODIFY_ATTRIBUTE:\n        if (!mod.attribute)\n          throw new Error('modify_attribute requires attribute name');\n        // Try to set property if exists\n        try {\n          // accessing internal ts-morph API; safe for now\n          (node as any)[mod.attribute] = mod.value;\n        } catch (_e) {\n          // intentionally ignore errors from internal access\n          void _e;\n        }\n        break;\n\n      case ModificationOperation.WRAP:\n        if (!mod.wrapperTemplate)\n          throw new Error('wrap requires wrapperTemplate');\n        await this.wrapNode(node, mod.wrapperTemplate);\n        break;\n\n      case ModificationOperation.EXTRACT:\n        // create a new function at top-level with name=extractName and replace node with call\n        if (!mod.extractName) throw new Error('extract requires extractName');\n        await this.extractNodeAsFunction(sourceFile, node, mod.extractName);\n        break;\n\n      case ModificationOperation.REFACTOR:\n        if (!mod.attribute)\n          throw new Error('refactor requires attribute & value');\n        try {\n          // set attribute on node if possible\n          // internal mutation of ts-morph node\n          (node as any)[mod.attribute] = mod.value;\n        } catch (_e) {\n          void _e;\n        }\n        break;\n\n      case ModificationOperation.RENAME_SYMBOL_SCOPED:\n        if (!mod.attribute || typeof mod.value !== 'string')\n          throw new Error(\n            'rename_symbol_scoped requires attribute(oldName) and value(newName)',\n          );\n        await this.renameSymbolScoped(\n          node,\n          String(mod.attribute),\n          String(mod.value),\n        );\n        break;\n\n      case ModificationOperation.ADD_TO_CLASS_BASES:\n        if (!mod.newCode)\n          throw new Error('add_to_class_bases requires newCode');\n        if (Node.isClassDeclaration(node)) {\n          const cls = node as ClassDeclaration;\n          const existing = cls.getExtends();\n          if (existing) {\n            // append to heritageClause by replacing with new text\n            const baseText = cls\n              .getHeritageClauses()\n              .map((h: Node) => h.getText())\n              .join(' ');\n            cls.replaceWithText(\n              cls.getText().replace(baseText, `${baseText}, ${mod.newCode}`),\n            );\n          } else {\n            // add an extends clause\n            cls.insertText(\n              cls.getStart() + cls.getText().indexOf('{'),\n              ` extends ${mod.newCode} `,\n            );\n          }\n        }\n        break;\n      case ModificationOperation.UPDATE_METHOD_SIGNATURE:\n        if (!mod.newCode)\n          throw new Error('update_method_signature requires newCode');\n        await this.updateMethodSignature(node, mod.newCode);\n        break;\n\n      case ModificationOperation.INSERT_STATEMENT_INTO_FUNCTION:\n        if (!mod.newCode)\n          throw new Error('insert_statement_into_function requires newCode');\n        await this.insertStatementIntoFunction(\n          node,\n          mod.newCode,\n          (mod.metadata?.['insert_at_end'] ?? true) as boolean,\n        );\n        break;\n\n      case ModificationOperation.REPLACE_EXPRESSION:\n        if (!mod.newCode)\n          throw new Error('replace_expression requires newCode');\n        node.replaceWithText(mod.newCode);\n        break;\n\n      default:\n        // If unknown, try best-effort replaceWithText\n        if (mod.newCode) node.replaceWithText(mod.newCode);\n        break;\n    }\n  }\n\n  private async insertRelative(node: Node, code: string, before: boolean) {\n    const parent = node.getParent();\n    if (!parent) {\n      // fallback to replaceWithText surrounding insertion\n      const text = before\n        ? `${code}\\n${node.getText()}`\n        : `${node.getText()}\\n${code}`;\n      node.replaceWithText(text);\n      return;\n    }\n\n    // If parent is a block (list of statements), use insertStatements\n    const block = parent.getFirstChildByKind(SyntaxKind.Block) ?? parent;\n    if (\n      (block as any).insertStatements &&\n      typeof (block as any).insertStatements === 'function'\n    ) {\n      // find index of node among block statements\n      const statements = (block as any).getStatements\n        ? (block as any).getStatements()\n        : [];\n      const idx = statements.findIndex(\n  (s: Node) => s.getStart() === node.getStart(),\n      );\n      if (idx >= 0) {\n        if (before) (block as any).insertStatements(idx, code);\n        else (block as any).insertStatements(idx + 1, code);\n        return;\n      }\n    }\n\n    // fallback: text replacement\n    const text = before\n      ? `${code}\\n${node.getText()}`\n      : `${node.getText()}\\n${code}`;\n    node.replaceWithText(text);\n  }\n\n  private async wrapNode(node: Node, wrapperTemplate: string) {\n    // wrapperTemplate expected to contain a placeholder like \"{node}\" or \"/*NODE*/\"\n    const raw = wrapperTemplate\n      .replace('{node}', node.getText())\n      .replace('/*NODE*/', node.getText());\n    node.replaceWithText(raw);\n  }\n\n  private async extractNodeAsFunction(\n    sourceFile: SourceFile,\n    node: Node,\n    funcName: string,\n  ) {\n    // Try to create a function at top of file that returns or contains the node\n    const nodeText = node.getText();\n    const funcText = `function ${funcName}() { return (${nodeText}); }`;\n    // Insert at top, after imports if any\n    const imports = sourceFile.getImportDeclarations();\n    if (imports.length > 0) {\n      sourceFile.insertText(\n        imports[imports.length - 1].getEnd(),\n        '\\n' + funcText,\n      );\n    } else {\n      sourceFile.insertStatements(0, funcText);\n    }\n    // Replace original with a call\n    node.replaceWithText(`${funcName}()`);\n  }\n\n  private async renameSymbolScoped(\n    scopeNode: Node,\n    oldName: string,\n    newName: string,\n  ) {\n    // Walk descendants and replace identifier text when it matches oldName\n  scopeNode.forEachDescendant((n: Node) => {\n      try {\n        // look for identifiers (VariableDeclaration, Identifier nodes)\n        if (\n          (n.getKind && n.getKind() === SyntaxKind.Identifier) ||\n          (n.getText && n.getText() === oldName)\n        ) {\n          if (n.getText() === oldName) {\n            n.replaceWithText(newName);\n          }\n        } else {\n          // sometimes ts-morph nodes (parameters, variable names) expose getName\n          if (typeof (n as any).getName === 'function' && (n as any).getName() === oldName) {\n            // rename is optional on some nodes\n            (n as any).rename && (n as any).rename(newName);\n          }\n        }\n      } catch {\n        // ignore problematic nodes\n      }\n    });\n  }\n\n  private async updateMethodSignature(node: Node, newSignature: string) {\n    if (\n      Node.isFunctionDeclaration(node) ||\n      Node.isMethodDeclaration(node) ||\n      Node.isArrowFunction(node) ||\n      Node.isFunctionExpression(node)\n    ) {\n      try {\n        // attempt to set parameters by replacing the signature portion\n        const bodyText =\n          node.getFirstChildByKind(SyntaxKind.Block)?.getText() ?? '{}';\n        const name = (node as any).getName ? (node as any).getName() : '';\n        const replaceText = `${name}(${newSignature}) ${bodyText}`;\n        // replace whole node with new signature + body (safer than trying to mutate params)\n        node.replaceWithText(replaceText);\n      } catch {\n        // fallback: naive text replace\n        node.replaceWithText(\n          node.getText().replace(/\\([^)]*\\)/, `(${newSignature})`),\n        );\n      }\n    } else {\n      // not a function -> ignore\n    }\n  }\n\n  private async insertStatementIntoFunction(\n    node: Node,\n    stmtCode: string,\n    atEnd = true,\n  ) {\n    // If node is a function or method, insert into its body\n    const block = node.getFirstChildByKind(SyntaxKind.Block);\n    if (block && (block as any).insertStatements) {\n      const stmts = (block as any).getStatements();\n      if (atEnd) (block as any).insertStatements(stmts.length, stmtCode);\n      else (block as any).insertStatements(0, stmtCode);\n      return;\n    }\n\n    // fallback: replace node text by injecting before/after\n    const text = atEnd\n      ? `${node.getText()}\\n${stmtCode}`\n      : `${stmtCode}\\n${node.getText()}`;\n    node.replaceWithText(text);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ast/parser.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1368,1371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1368,1371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3006,3009],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3006,3009],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5362,5365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5362,5365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":184,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5386,5389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5386,5389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":215,"column":4,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":7,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6237,6240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6237,6240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":216,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6260,6263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6260,6263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6788,6791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6788,6791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8059,8062],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8059,8062],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8221,8224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8221,8224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":296,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8848,8851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8848,8851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9004,9007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9004,9007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":333,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10190,10193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10190,10193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":339,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10362,10365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10362,10365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":353,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10843,10846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10843,10846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":366,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11237,11240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11237,11240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":434,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13025,13028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13025,13028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":460,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":460,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13687,13690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13687,13690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":484,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":484,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14359,14362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14359,14362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":515,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":515,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15320,15323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15320,15323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * TypeScript port of ideas/ASTRAL_TOOLS/ast_tools/reader.py\n * - robust file reading with encoding fallbacks\n * - file size guard\n * - defensive parsing with ts-morph\n * - comment / JSDoc extraction\n * - intention extraction (functions, classes, imports, constants)\n */\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { Project, SourceFile, SyntaxKind } from 'ts-morph';\n\nconst MAX_FILE_SIZE_MB = 50; // maximum file size to process\n\n/**\n * Result shape returned by readAndParseFile / ASTReader.execute\n */\nexport interface ParseResult {\n  source?: string | null;\n  sourceFile?: SourceFile | null;\n  parseError?: string | null;\n  comments: string[];\n  jsdocs: string[];\n  intentions: unknown;\n  fileInfo: {\n    path: string;\n    sizeBytes: number;\n    lineCount: number;\n    processingTimeMs: number;\n  };\n}\n\n/**\n * Simple defensive file size check.\n */\nexport async function checkFileSize(\n  filePath: string,\n): Promise<{ ok: boolean; error?: string }> {\n  try {\n    const st = await fs.stat(filePath);\n    const sizeMb = st.size / (1024 * 1024);\n    if (sizeMb > MAX_FILE_SIZE_MB) {\n      return {\n        ok: false,\n        error: `File too large: ${sizeMb.toFixed(1)}MB (max ${MAX_FILE_SIZE_MB}MB)`,\n      };\n    }\n    return { ok: true };\n  } catch (_e: any) {\n    return { ok: false, error: `Cannot check file size: ${String(_e)}` };\n  }\n}\n\n/**\n * Read file with encoding fallbacks (utf-8, latin1).\n */\nexport async function readFileWithEncodingFallback(\n  filePath: string,\n): Promise<{ content: string | null; error: string | null }> {\n  const encodings = ['utf8', 'latin1', 'cp1252'] as const;\n  for (const enc of encodings) {\n    try {\n      const buf = await fs.readFile(filePath);\n      // try decoding according to encoding\n      const content = Buffer.from(buf).toString(enc as BufferEncoding);\n      // cheap sanity: if decoding produced replacement chars many times, fall through (best-effort)\n      if (content.length === 0 && buf.length > 0) {\n        continue;\n      }\n      return { content, error: null };\n    } catch (_err) {\n      // try next encoding\n      void _err;\n      continue;\n    }\n  }\n  return { content: null, error: `Could not decode file with tried encodings` };\n}\n\n/**\n * Defensive parse to ts-morph SourceFile.\n * Uses a fresh Project (in-memory) so we do not affect disk.\n */\n// Internal implementation expects (source, filePath)\nfunction parseSourceToSourceFileImpl(\n  source: string,\n  filePath: string,\n): { sourceFile?: SourceFile | null; error?: string | null } {\n  try {\n    const project = new Project({\n      useInMemoryFileSystem: true,\n      compilerOptions: { allowJs: true },\n    });\n    const normalizedPath = path.isAbsolute(filePath)\n      ? filePath\n      : path.resolve('/', filePath);\n    const sf = project.createSourceFile(normalizedPath, source, {\n      overwrite: true,\n    });\n    return { sourceFile: sf, error: null };\n  } catch (e: any) {\n    return { sourceFile: null, error: `Parsing failed: ${String(e)}` };\n  }\n}\n\n/**\n * Compatibility wrapper for parseSourceToSourceFile.\n * Accepts either (source, filePath) or the older callers that pass (filePath, source).\n */\nexport function parseSourceToSourceFile(\n  a: string,\n  b?: string,\n): { sourceFile?: SourceFile | null; error?: string | null } {\n  // If only one arg provided, treat it as source with missing filePath -> use virtual path\n  if (b === undefined) {\n    return parseSourceToSourceFileImpl(a, '/virtual-file.ts');\n  }\n\n  // Heuristic: if first arg contains a newline or semicolon, treat as source\n  const looksLikeSource =\n    a.includes('\\n') || a.includes(';') || a.includes('{');\n  const looksLikePath =\n    b.includes('\\n') === false &&\n    (a.startsWith('.') || a.startsWith('/') || a.match(/\\\\.[tj]s[x]?$/i));\n\n  if (looksLikeSource && !looksLikePath) {\n    return parseSourceToSourceFileImpl(a, b);\n  }\n\n  // Fallback: assume callers passed (filePath, source)\n  return parseSourceToSourceFileImpl(b, a);\n}\n\n/**\n * Extract comments (line comments and block comments) and JSDoc blocks using regex + ts-morph where possible.\n */\nexport function extractCommentsAndJsDoc(\n  source: string,\n  sourceFile?: SourceFile | null,\n): { comments: string[]; jsdocs: string[] } {\n  const comments: string[] = [];\n  const jsdocs: string[] = [];\n\n  try {\n    // line comments //\n    const lineRe = /^\\s*\\/\\/(.*)$/gm;\n    let m;\n    while ((m = lineRe.exec(source)) !== null) {\n      const txt = m[1].trim();\n      if (txt) comments.push(txt);\n    }\n\n    // block comments /* ... */\n    const blockRe = /\\/\\*([\\s\\S]*?)\\*\\//g;\n    while ((m = blockRe.exec(source)) !== null) {\n      const txt = m[1].trim();\n      if (txt) {\n        // JSDoc-style starts with *\n        if (/^\\*/.test(txt) || txt.startsWith('*')) {\n          // split lines and clean leading '*'\n          const cleaned = txt\n            .split('\\n')\n            .map((l) => l.replace(/^\\s*\\*\\s?/, '').trim())\n            .join('\\n')\n            .trim();\n          jsdocs.push(cleaned);\n        } else {\n          comments.push(txt);\n        }\n      }\n    }\n\n    // If ts-morph SourceFile available, collect JSDoc nodes defensively\n    if (sourceFile) {\n      try {\n        for (const nd of sourceFile.getDescendants()) {\n          try {\n            const js = (nd as any).getJsDocs ? (nd as any).getJsDocs() : [];\n            if (Array.isArray(js) && js.length > 0) {\n              for (const d of js) {\n                const txt =\n                  typeof d.getInnerText === 'function'\n                    ? d.getInnerText()\n                    : String(d.getText?.() ?? '');\n                if (txt) jsdocs.push(txt.trim());\n              }\n            }\n          } catch {\n            // ignore per-node errors\n          }\n        }\n      } catch {\n        // ignore\n      }\n    }\n  } catch {\n    // ignore extraction failure; return what we have\n  }\n\n  return { comments, jsdocs };\n}\n\n/**\n * Extract intentions (functions, classes, imports, constants) from a ts-morph SourceFile.\n * Defensive: isolate node-level errors to avoid complete failure.\n */\nexport function extractIntentionsFromSourceFile(\n  sourceFile?: SourceFile | null,\n): any {\n  const intents: any = {\n    functions: [],\n    classes: [],\n    imports: [],\n    constants: [],\n    parsingErrors: [],\n  };\n  if (!sourceFile) {\n    intents.parsingErrors.push('sourceFile not available');\n    return intents;\n  }\n\n  try {\n    // Imports\n    try {\n      const imps = sourceFile.getImportDeclarations();\n      for (const imp of imps) {\n        try {\n          // small local helper to avoid implicit-`any` callback in map\n          const namedImports = imp.getNamedImports();\n          const mappedNamed = namedImports.map((spec: any) => {\n            const s = spec as unknown as {\n              getName: () => string;\n              getAliasNode?: () => { getText?: () => string } | undefined;\n            };\n            return {\n              name: s.getName(),\n              alias: s.getAliasNode?.()?.getText?.() ?? undefined,\n            };\n          });\n\n          intents.imports.push({\n            moduleSpecifier: imp.getModuleSpecifierValue(),\n            namedImports: mappedNamed,\n            defaultImport: imp.getDefaultImport()?.getText?.() ?? undefined,\n            namespaceImport: imp.getNamespaceImport()?.getText?.() ?? undefined,\n          });\n        } catch (e) {\n          intents.parsingErrors.push(`import node error: ${String(e)}`);\n        }\n      }\n    } catch (e) {\n      intents.parsingErrors.push(`imports extraction failed: ${String(e)}`);\n    }\n\n    // Functions\n    try {\n      const funcs = sourceFile.getFunctions();\n      for (const f of funcs) {\n        try {\n          intents.functions.push({\n            name: f.getName?.() ?? '<anonymous>',\n            isAsync: f.isAsync?.() ?? false,\n            startLine: f.getStartLineNumber?.() ?? null,\n            endLine: f.getEndLineNumber?.() ?? null,\n            params:\n              f.getParameters?.().map((p: any) => ({\n                name: p.getName?.(),\n                type: p.getType?.().getText?.() ?? '',\n              })) ?? [],\n          });\n        } catch (e: any) {\n          intents.parsingErrors.push(`function node error: ${String(e)}`);\n        }\n      }\n    } catch (e) {\n      intents.parsingErrors.push(`functions extraction failed: ${String(e)}`);\n    }\n\n    // Classes\n    try {\n      const classes = sourceFile.getClasses();\n      for (const c of classes) {\n        try {\n          intents.classes.push({\n            name: c.getName?.() ?? '<anonymous>',\n            isExported: c.isExported?.() ?? false,\n            startLine: c.getStartLineNumber?.() ?? null,\n            endLine: c.getEndLineNumber?.() ?? null,\n            methods:\n              c.getMethods?.().map((m: any) => ({\n                name: m.getName?.(),\n                isAsync: m.isAsync?.() ?? false,\n              })) ?? [],\n          });\n        } catch (e: any) {\n          intents.parsingErrors.push(`class node error: ${String(e)}`);\n        }\n      }\n    } catch (e) {\n      intents.parsingErrors.push(`classes extraction failed: ${String(e)}`);\n    }\n\n    // Constants - best-effort: numeric/string/boolean initializers from variable statements\n    try {\n      const vars = sourceFile.getVariableStatements();\n      for (const stmt of vars) {\n        try {\n          const isExported = stmt.isExported?.() ?? false;\n          for (const decl of stmt.getDeclarations()) {\n            try {\n              const init = decl.getInitializer?.();\n              if (!init) continue;\n              const kind = init.getKind?.();\n              if (\n                kind === SyntaxKind.StringLiteral ||\n                kind === SyntaxKind.NumericLiteral ||\n                kind === SyntaxKind.TrueKeyword ||\n                kind === SyntaxKind.FalseKeyword\n              ) {\n                intents.constants.push({\n                  name: decl.getName?.(),\n                  value: init.getText?.(),\n                  isExported,\n                  startLine: decl.getStartLineNumber?.(),\n                });\n              }\n            } catch (e: any) {\n              intents.parsingErrors.push(\n                `variable declaration error: ${String(e)}`,\n              );\n            }\n          }\n        } catch (e: any) {\n          intents.parsingErrors.push(`variable statement error: ${String(e)}`);\n        }\n      }\n    } catch (e) {\n      intents.parsingErrors.push(`constants extraction failed: ${String(e)}`);\n    }\n\n    // Additionally: a defensive AST walk to collect some string literal docstrings if any\n    try {\n      sourceFile.forEachDescendant((n) => {\n        try {\n          const k = n.getKind?.();\n          if (k === SyntaxKind.StringLiteral) {\n            const txt = (n as any).getLiteralText?.();\n            if (typeof txt === 'string' && txt.length > 20) {\n              // heuristics: long string literals may be docstrings/comments\n              intents.constants.push({ inferredDocstring: txt.slice(0, 200) });\n            }\n          }\n        } catch {\n          // ignore per-node errors\n        }\n      });\n    } catch {\n      // ignore\n    }\n  } catch (e: any) {\n    intents.parsingErrors.push(\n      `intentions overall extraction failed: ${String(e)}`,\n    );\n  }\n\n  return intents;\n}\n\n/**\n * Main orchestration: read file, parse, extract comments and intentions.\n */\nexport async function readAndParseFile(filePath: string): Promise<ParseResult> {\n  const start = Date.now();\n  const resolved = path.resolve(filePath);\n\n  const result: ParseResult = {\n    source: null,\n    sourceFile: null,\n    parseError: null,\n    comments: [],\n    jsdocs: [],\n    intentions: {},\n    fileInfo: {\n      path: resolved,\n      sizeBytes: 0,\n      lineCount: 0,\n      processingTimeMs: 0,\n    },\n  };\n\n  try {\n    const sizeCheck = await checkFileSize(resolved);\n    if (!sizeCheck.ok) {\n      result.parseError = `File size check failed: ${sizeCheck.error}`;\n      return result;\n    }\n\n    const { content, error } = await readFileWithEncodingFallback(resolved);\n    if (error || content === null) {\n      result.parseError = `File reading failed: ${error ?? 'unknown'}`;\n      return result;\n    }\n\n    result.source = content;\n    result.fileInfo.sizeBytes = Buffer.byteLength(content, 'utf8');\n    result.fileInfo.lineCount = content.split(/\\r\\n|\\r|\\n/).length;\n\n    const { sourceFile, error: parseErr } = parseSourceToSourceFile(\n      content,\n      resolved,\n    );\n    if (parseErr) {\n      result.parseError = parseErr;\n      // continue with partial extraction where possible\n    }\n    result.sourceFile = sourceFile ?? null;\n\n    const { comments, jsdocs } = extractCommentsAndJsDoc(\n      content,\n      sourceFile ?? null,\n    );\n    result.comments = comments;\n    result.jsdocs = jsdocs;\n\n    result.intentions = extractIntentionsFromSourceFile(sourceFile ?? null);\n\n    result.fileInfo.processingTimeMs = Date.now() - start;\n  } catch (e: any) {\n    result.parseError = `Unexpected processing error: ${String(e)}`;\n  }\n\n  return result;\n}\n\n/**\n * Minimal ASTReader class matching the Python tool shape.\n * Adjust to your tool framework (BaseTool) if needed.\n */\nexport interface ASTReaderParams {\n  filePath: string;\n  includeSource?: boolean;\n  extractIntentions?: boolean;\n  extractComments?: boolean;\n}\n\nexport class ASTReader {\n  name = 'ast_reader';\n  description =\n    'Reads JS/TS files, parses them into an AST, extracts structural information and comments with defensive parsing.';\n\n  async execute(params: ASTReaderParams): Promise<{\n    success: boolean;\n    output: string;\n    metadata?: any;\n    errorMessage?: string;\n    executionTime?: number;\n  }> {\n    const start = Date.now();\n    try {\n      const filePath = params.filePath;\n      const r = await readAndParseFile(filePath);\n\n      const parts: string[] = [];\n      parts.push(` AST READER RESULTS`);\n      parts.push(`File: ${r.fileInfo.path}`);\n      parts.push(\n        `Size: ${r.fileInfo.sizeBytes} bytes (${r.fileInfo.lineCount} lines)`,\n      );\n      parts.push(`Processing Time: ${r.fileInfo.processingTimeMs}ms`);\n\n      if (r.parseError) {\n        parts.push(` Parse Error: ${r.parseError}`);\n      } else {\n        parts.push(` Parse Status: Success`);\n      }\n\n   \n  const intents: any = r.intentions || {};\n      if (intents && !intents.extraction_error) {\n        const fnCount = Array.isArray(intents.functions)\n          ? intents.functions.length\n          : 0;\n        const clsCount = Array.isArray(intents.classes)\n          ? intents.classes.length\n          : 0;\n        const impCount = Array.isArray(intents.imports)\n          ? intents.imports.length\n          : 0;\n        parts.push(\n          ` Extracted: ${fnCount} functions, ${clsCount} classes, ${impCount} imports`,\n        );\n        if (\n          Array.isArray(intents.parsingErrors) &&\n          intents.parsingErrors.length > 0\n        ) {\n          parts.push(\n            ` Partial Errors: ${intents.parsingErrors.length} node processing issues`,\n          );\n        }\n      }\n\n      parts.push(\n        ` Documentation: ${r.comments.length} comments, ${r.jsdocs.length} JSDoc blocks`,\n      );\n\n      const output = parts.join('\\n');\n\n   \n  const metadata: any = {\n        fileInfo: r.fileInfo,\n        parseError: r.parseError,\n        intentions:\n          params.extractIntentions === false ? undefined : r.intentions,\n        comments: params.extractComments === false ? undefined : r.comments,\n        jsdocs: params.extractComments === false ? undefined : r.jsdocs,\n      };\n      if (params.includeSource !== false) metadata.source = r.source;\n\n      return {\n        success: !!r.source && (!r.parseError || !!r.intentions),\n        output,\n        metadata,\n        executionTime: (Date.now() - start) / 1000,\n      };\n    } catch (e: unknown) {\n      return {\n        success: false,\n        output: '',\n        errorMessage: String(e),\n        executionTime: (Date.now() - start) / 1000,\n      };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/codeAssist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/converter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/converter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/oauth2.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/oauth2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/setup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/code_assist/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/config/config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/config/config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":892,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":892,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26361,26364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26361,26364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":892,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":892,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26369,26372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26369,26372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":892,"column":30,"severity":1,"nodeType":null,"fix":{"range":[26374,26436],"text":" "}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as path from 'node:path';\nimport process from 'node:process';\nimport {\n  AuthType,\n  ContentGeneratorConfig,\n  createContentGeneratorConfig,\n} from '../core/contentGenerator.js';\nimport { PromptRegistry } from '../prompts/prompt-registry.js';\nimport { ToolRegistry } from '../tools/tool-registry.js';\nimport { LSTool } from '../tools/ls.js';\nimport { ReadFileTool } from '../tools/read-file.js';\nimport { GrepTool } from '../tools/grep.js';\nimport { RipGrepTool } from '../tools/ripGrep.js';\nimport { GlobTool } from '../tools/glob.js';\nimport { EditTool } from '../tools/edit.js';\nimport { ShellTool } from '../tools/shell.js';\nimport { WriteFileTool } from '../tools/write-file.js';\nimport { WebFetchTool } from '../tools/web-fetch.js';\nimport { ReadManyFilesTool } from '../tools/read-many-files.js';\nimport { MemoryTool, setGeminiMdFilename } from '../tools/memoryTool.js';\nimport { WebSearchTool } from '../tools/web-search.js';\nimport { UpsertCodeBlockTool } from '../tools/upsert_code_block.js';\nimport { ASTReadTool, ASTFindTool, ASTEditTool } from '../tools/ast.js';\nimport { GeminiClient } from '../core/client.js';\nimport { FileDiscoveryService } from '../services/fileDiscoveryService.js';\nimport { GitService } from '../services/gitService.js';\nimport {\n  initializeTelemetry,\n  DEFAULT_TELEMETRY_TARGET,\n  DEFAULT_OTLP_ENDPOINT,\n  TelemetryTarget,\n  StartSessionEvent,\n} from '../telemetry/index.js';\nimport {\n  DEFAULT_GEMINI_EMBEDDING_MODEL,\n  DEFAULT_GEMINI_FLASH_MODEL,\n} from './models.js';\nimport { shouldAttemptBrowserLaunch } from '../utils/browser.js';\nimport { MCPOAuthConfig } from '../mcp/oauth-provider.js';\nimport { IdeClient } from '../ide/ide-client.js';\nimport type { Content } from '@google/genai';\nimport {\n  FileSystemService,\n  StandardFileSystemService,\n} from '../services/fileSystemService.js';\nimport { logCliConfiguration, logIdeConnection } from '../telemetry/loggers.js';\nimport { IdeConnectionEvent, IdeConnectionType } from '../telemetry/types.js';\n\n// Re-export OAuth config type\nexport type { MCPOAuthConfig };\nimport { WorkspaceContext } from '../utils/workspaceContext.js';\nimport { Storage } from './storage.js';\nimport { FileExclusions } from '../utils/ignorePatterns.js';\n\nexport enum ApprovalMode {\n  DEFAULT = 'default',\n  AUTO_EDIT = 'autoEdit',\n  YOLO = 'yolo',\n}\n\nexport interface AccessibilitySettings {\n  disableLoadingPhrases?: boolean;\n  screenReader?: boolean;\n}\n\nexport interface BugCommandSettings {\n  urlTemplate: string;\n}\n\nexport interface ChatCompressionSettings {\n  contextPercentageThreshold?: number;\n}\n\nexport interface SummarizeToolOutputSettings {\n  tokenBudget?: number;\n}\n\nexport interface TelemetrySettings {\n  enabled?: boolean;\n  target?: TelemetryTarget;\n  otlpEndpoint?: string;\n  otlpProtocol?: 'grpc' | 'http';\n  logPrompts?: boolean;\n  outfile?: string;\n}\n\nexport interface GeminiCLIExtension {\n  name: string;\n  version: string;\n  isActive: boolean;\n  path: string;\n}\nexport interface FileFilteringOptions {\n  respectGitIgnore: boolean;\n  respectGeminiIgnore: boolean;\n}\n// For memory files\nexport const DEFAULT_MEMORY_FILE_FILTERING_OPTIONS: FileFilteringOptions = {\n  respectGitIgnore: false,\n  respectGeminiIgnore: true,\n};\n// For all other files\nexport const DEFAULT_FILE_FILTERING_OPTIONS: FileFilteringOptions = {\n  respectGitIgnore: true,\n  respectGeminiIgnore: true,\n};\n\n/**\n * Loop detection configuration options\n */\nexport interface LoopDetectionConfig {\n  /** Enable advanced pattern detection (alternating, non-consecutive) */\n  enableAdvancedPatterns: boolean;\n  /** Enable semantic content analysis */\n  enableSemanticAnalysis: boolean;\n  /** Enable file state tracking */\n  enableFileStateTracking: boolean;\n  /** Confidence threshold for triggering automatic actions */\n  autoActionThreshold: number;\n  /** Enable visual confidence feedback */\n  enableVisualFeedback: boolean;\n  /** LLM temperature increase when loop detected */\n  loopBreakTemperature: number;\n}\n\n// In ConfigManager or equivalent:\nexport const DEFAULT_LOOP_DETECTION_CONFIG: LoopDetectionConfig = {\n  enableAdvancedPatterns: true,\n  enableSemanticAnalysis: true,\n  enableFileStateTracking: true,\n  autoActionThreshold: 0.7,\n  enableVisualFeedback: true,\n  loopBreakTemperature: 0.9,\n};\n\nexport class MCPServerConfig {\n  constructor(\n    // For stdio transport\n    readonly command?: string,\n    readonly args?: string[],\n    readonly env?: Record<string, string>,\n    readonly cwd?: string,\n    // For sse transport\n    readonly url?: string,\n    // For streamable http transport\n    readonly httpUrl?: string,\n    readonly headers?: Record<string, string>,\n    // For websocket transport\n    readonly tcp?: string,\n    // Common\n    readonly timeout?: number,\n    readonly trust?: boolean,\n    // Metadata\n    readonly description?: string,\n    readonly includeTools?: string[],\n    readonly excludeTools?: string[],\n    readonly extensionName?: string,\n    // OAuth configuration\n    readonly oauth?: MCPOAuthConfig,\n    readonly authProviderType?: AuthProviderType,\n  ) {}\n}\n\nexport enum AuthProviderType {\n  DYNAMIC_DISCOVERY = 'dynamic_discovery',\n  GOOGLE_CREDENTIALS = 'google_credentials',\n}\n\nexport interface SandboxConfig {\n  command: 'docker' | 'podman' | 'sandbox-exec';\n  image: string;\n}\n\nexport type FlashFallbackHandler = (\n  currentModel: string,\n  fallbackModel: string,\n  error?: unknown,\n) => Promise<boolean | string | null>;\n\nexport interface ConfigParameters {\n  sessionId: string;\n  embeddingModel?: string;\n  sandbox?: SandboxConfig;\n  targetDir: string;\n  debugMode: boolean;\n  question?: string;\n  fullContext?: boolean;\n  coreTools?: string[];\n  excludeTools?: string[];\n  toolDiscoveryCommand?: string;\n  toolCallCommand?: string;\n  mcpServerCommand?: string;\n  mcpServers?: Record<string, MCPServerConfig>;\n  userMemory?: string;\n  geminiMdFileCount?: number;\n  approvalMode?: ApprovalMode;\n  showMemoryUsage?: boolean;\n  contextFileName?: string | string[];\n  accessibility?: AccessibilitySettings;\n  telemetry?: TelemetrySettings;\n  usageStatisticsEnabled?: boolean;\n  fileFiltering?: {\n    respectGitIgnore?: boolean;\n    respectGeminiIgnore?: boolean;\n    enableRecursiveFileSearch?: boolean;\n    disableFuzzySearch?: boolean;\n  };\n  checkpointing?: boolean;\n  proxy?: string;\n  cwd: string;\n  fileDiscoveryService?: FileDiscoveryService;\n  includeDirectories?: string[];\n  bugCommand?: BugCommandSettings;\n  model: string;\n  extensionContextFilePaths?: string[];\n  maxSessionTurns?: number;\n  experimentalZedIntegration?: boolean;\n  listExtensions?: boolean;\n  extensions?: GeminiCLIExtension[];\n  blockedMcpServers?: Array<{ name: string; extensionName: string }>;\n  noBrowser?: boolean;\n  summarizeToolOutput?: Record<string, SummarizeToolOutputSettings>;\n  folderTrustFeature?: boolean;\n  folderTrust?: boolean;\n  ideMode?: boolean;\n  loadMemoryFromIncludeDirectories?: boolean;\n  chatCompression?: ChatCompressionSettings;\n  interactive?: boolean;\n  trustedFolder?: boolean;\n  useRipgrep?: boolean;\n  shouldUseNodePtyShell?: boolean;\n  skipNextSpeakerCheck?: boolean;\n  enablePromptCompletion?: boolean;\n}\n\nexport class Config {\n  private toolRegistry!: ToolRegistry;\n  private promptRegistry!: PromptRegistry;\n  private sessionId: string;\n  private fileSystemService: FileSystemService;\n  private contentGeneratorConfig!: ContentGeneratorConfig;\n  private readonly embeddingModel: string;\n  private readonly sandbox: SandboxConfig | undefined;\n  private readonly targetDir: string;\n  private workspaceContext: WorkspaceContext;\n  private readonly debugMode: boolean;\n  private readonly question: string | undefined;\n  private readonly fullContext: boolean;\n  private readonly coreTools: string[] | undefined;\n  private readonly excludeTools: string[] | undefined;\n  private readonly toolDiscoveryCommand: string | undefined;\n  private readonly toolCallCommand: string | undefined;\n  private readonly mcpServerCommand: string | undefined;\n  private readonly mcpServers: Record<string, MCPServerConfig> | undefined;\n  private userMemory: string;\n  private geminiMdFileCount: number;\n  private approvalMode: ApprovalMode;\n  private readonly showMemoryUsage: boolean;\n  private readonly accessibility: AccessibilitySettings;\n  private readonly telemetrySettings: TelemetrySettings;\n  private readonly usageStatisticsEnabled: boolean;\n  private geminiClient!: GeminiClient;\n  private readonly fileFiltering: {\n    respectGitIgnore: boolean;\n    respectGeminiIgnore: boolean;\n    enableRecursiveFileSearch: boolean;\n    disableFuzzySearch: boolean;\n  };\n  private fileDiscoveryService: FileDiscoveryService | null = null;\n  private gitService: GitService | undefined = undefined;\n  private readonly checkpointing: boolean;\n  private readonly proxy: string | undefined;\n  private readonly cwd: string;\n  private readonly bugCommand: BugCommandSettings | undefined;\n  private readonly model: string;\n  private readonly extensionContextFilePaths: string[];\n  private readonly noBrowser: boolean;\n  private readonly folderTrustFeature: boolean;\n  private readonly folderTrust: boolean;\n  private ideMode: boolean;\n  private ideClient: IdeClient;\n  private inFallbackMode = false;\n  private readonly maxSessionTurns: number;\n  private readonly listExtensions: boolean;\n  private readonly _extensions: GeminiCLIExtension[];\n  private readonly _blockedMcpServers: Array<{\n    name: string;\n    extensionName: string;\n  }>;\n  flashFallbackHandler?: FlashFallbackHandler;\n  private quotaErrorOccurred: boolean = false;\n  private readonly summarizeToolOutput:\n    | Record<string, SummarizeToolOutputSettings>\n    | undefined;\n  private readonly experimentalZedIntegration: boolean = false;\n  private readonly loadMemoryFromIncludeDirectories: boolean = false;\n  private readonly chatCompression: ChatCompressionSettings | undefined;\n  private readonly interactive: boolean;\n  private readonly trustedFolder: boolean | undefined;\n  private readonly useRipgrep: boolean;\n  private readonly shouldUseNodePtyShell: boolean;\n  private readonly skipNextSpeakerCheck: boolean;\n  private readonly enablePromptCompletion: boolean = false;\n  private initialized: boolean = false;\n  readonly storage: Storage;\n  private readonly fileExclusions: FileExclusions;\n\n  constructor(params: ConfigParameters) {\n    this.sessionId = params.sessionId;\n    this.embeddingModel =\n      params.embeddingModel ?? DEFAULT_GEMINI_EMBEDDING_MODEL;\n    this.fileSystemService = new StandardFileSystemService();\n    this.sandbox = params.sandbox;\n    this.targetDir = path.resolve(params.targetDir);\n    this.workspaceContext = new WorkspaceContext(\n      this.targetDir,\n      params.includeDirectories ?? [],\n    );\n    this.debugMode = params.debugMode;\n    this.question = params.question;\n    this.fullContext = params.fullContext ?? false;\n    this.coreTools = params.coreTools;\n    this.excludeTools = params.excludeTools;\n    this.toolDiscoveryCommand = params.toolDiscoveryCommand;\n    this.toolCallCommand = params.toolCallCommand;\n    this.mcpServerCommand = params.mcpServerCommand;\n    this.mcpServers = params.mcpServers;\n    this.userMemory = params.userMemory ?? '';\n    this.geminiMdFileCount = params.geminiMdFileCount ?? 0;\n    this.approvalMode = params.approvalMode ?? ApprovalMode.DEFAULT;\n    this.showMemoryUsage = params.showMemoryUsage ?? false;\n    this.accessibility = params.accessibility ?? {};\n    this.telemetrySettings = {\n      enabled: params.telemetry?.enabled ?? false,\n      target: params.telemetry?.target ?? DEFAULT_TELEMETRY_TARGET,\n      otlpEndpoint: params.telemetry?.otlpEndpoint ?? DEFAULT_OTLP_ENDPOINT,\n      otlpProtocol: params.telemetry?.otlpProtocol,\n      logPrompts: params.telemetry?.logPrompts ?? true,\n      outfile: params.telemetry?.outfile,\n    };\n    this.usageStatisticsEnabled = params.usageStatisticsEnabled ?? true;\n\n    this.fileFiltering = {\n      respectGitIgnore: params.fileFiltering?.respectGitIgnore ?? true,\n      respectGeminiIgnore: params.fileFiltering?.respectGeminiIgnore ?? true,\n      enableRecursiveFileSearch:\n        params.fileFiltering?.enableRecursiveFileSearch ?? true,\n      disableFuzzySearch: params.fileFiltering?.disableFuzzySearch ?? false,\n    };\n    this.checkpointing = params.checkpointing ?? false;\n    this.proxy = params.proxy;\n    this.cwd = params.cwd ?? process.cwd();\n    this.fileDiscoveryService = params.fileDiscoveryService ?? null;\n    this.bugCommand = params.bugCommand;\n    this.model = params.model;\n    this.extensionContextFilePaths = params.extensionContextFilePaths ?? [];\n    this.maxSessionTurns = params.maxSessionTurns ?? -1;\n    this.experimentalZedIntegration =\n      params.experimentalZedIntegration ?? false;\n    this.listExtensions = params.listExtensions ?? false;\n    this._extensions = params.extensions ?? [];\n    this._blockedMcpServers = params.blockedMcpServers ?? [];\n    this.noBrowser = params.noBrowser ?? false;\n    this.summarizeToolOutput = params.summarizeToolOutput;\n    this.folderTrustFeature = params.folderTrustFeature ?? false;\n    this.folderTrust = params.folderTrust ?? false;\n    this.ideMode = params.ideMode ?? false;\n    this.ideClient = IdeClient.getInstance();\n    this.loadMemoryFromIncludeDirectories =\n      params.loadMemoryFromIncludeDirectories ?? false;\n    this.chatCompression = params.chatCompression;\n    this.interactive = params.interactive ?? false;\n    this.trustedFolder = params.trustedFolder;\n    this.useRipgrep = params.useRipgrep ?? false;\n    this.shouldUseNodePtyShell = params.shouldUseNodePtyShell ?? false;\n    this.skipNextSpeakerCheck = params.skipNextSpeakerCheck ?? false;\n    this.storage = new Storage(this.targetDir);\n    this.enablePromptCompletion = params.enablePromptCompletion ?? false;\n    this.fileExclusions = new FileExclusions(this);\n\n    if (params.contextFileName) {\n      setGeminiMdFilename(params.contextFileName);\n    }\n\n    if (this.telemetrySettings.enabled) {\n      initializeTelemetry(this);\n    }\n  }\n\n  /**\n   * Must only be called once, throws if called again.\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      throw Error('Config was already initialized');\n    }\n    this.initialized = true;\n    // Initialize centralized FileDiscoveryService\n    this.getFileService();\n    if (this.getCheckpointingEnabled()) {\n      await this.getGitService();\n    }\n    this.promptRegistry = new PromptRegistry();\n    this.toolRegistry = await this.createToolRegistry();\n    logCliConfiguration(this, new StartSessionEvent(this, this.toolRegistry));\n  }\n\n  async refreshAuth(authMethod: AuthType) {\n    // Save the current conversation history before creating a new client\n    let existingHistory: Content[] = [];\n    if (this.geminiClient && this.geminiClient.isInitialized()) {\n      existingHistory = this.geminiClient.getHistory();\n    }\n\n    // Create new content generator config\n    const newContentGeneratorConfig = createContentGeneratorConfig(\n      this,\n      authMethod,\n    );\n\n    // Create and initialize new client in local variable first\n    const newGeminiClient = new GeminiClient(this);\n    await newGeminiClient.initialize(newContentGeneratorConfig);\n\n    // Vertex and Genai have incompatible encryption and sending history with\n    // throughtSignature from Genai to Vertex will fail, we need to strip them\n    const fromGenaiToVertex =\n      this.contentGeneratorConfig?.authType === AuthType.USE_GEMINI &&\n      authMethod === AuthType.LOGIN_WITH_GOOGLE;\n\n    // Only assign to instance properties after successful initialization\n    this.contentGeneratorConfig = newContentGeneratorConfig;\n    this.geminiClient = newGeminiClient;\n\n    // Restore the conversation history to the new client\n    if (existingHistory.length > 0) {\n      this.geminiClient.setHistory(existingHistory, {\n        stripThoughts: fromGenaiToVertex,\n      });\n    }\n\n    // Reset the session flag since we're explicitly changing auth and using default model\n    this.inFallbackMode = false;\n  }\n\n  getSessionId(): string {\n    return this.sessionId;\n  }\n\n  setSessionId(sessionId: string): void {\n    this.sessionId = sessionId;\n  }\n\n  shouldLoadMemoryFromIncludeDirectories(): boolean {\n    return this.loadMemoryFromIncludeDirectories;\n  }\n\n  getContentGeneratorConfig(): ContentGeneratorConfig {\n    return this.contentGeneratorConfig;\n  }\n\n  getModel(): string {\n    return this.contentGeneratorConfig?.model || this.model;\n  }\n\n  setModel(newModel: string): void {\n    if (this.contentGeneratorConfig) {\n      this.contentGeneratorConfig.model = newModel;\n    }\n  }\n\n  isInFallbackMode(): boolean {\n    return this.inFallbackMode;\n  }\n\n  setFallbackMode(active: boolean): void {\n    this.inFallbackMode = active;\n  }\n\n  setFlashFallbackHandler(handler: FlashFallbackHandler): void {\n    this.flashFallbackHandler = handler;\n  }\n\n  getMaxSessionTurns(): number {\n    return this.maxSessionTurns;\n  }\n\n  setQuotaErrorOccurred(value: boolean): void {\n    this.quotaErrorOccurred = value;\n  }\n\n  getQuotaErrorOccurred(): boolean {\n    return this.quotaErrorOccurred;\n  }\n\n  getEmbeddingModel(): string {\n    return this.embeddingModel;\n  }\n\n  getSandbox(): SandboxConfig | undefined {\n    return this.sandbox;\n  }\n\n  isRestrictiveSandbox(): boolean {\n    const sandboxConfig = this.getSandbox();\n    const seatbeltProfile = process.env['SEATBELT_PROFILE'];\n    return (\n      !!sandboxConfig &&\n      sandboxConfig.command === 'sandbox-exec' &&\n      !!seatbeltProfile &&\n      seatbeltProfile.startsWith('restrictive-')\n    );\n  }\n\n  getTargetDir(): string {\n    return this.targetDir;\n  }\n\n  getProjectRoot(): string {\n    return this.targetDir;\n  }\n\n  getWorkspaceContext(): WorkspaceContext {\n    return this.workspaceContext;\n  }\n\n  getToolRegistry(): ToolRegistry {\n    return this.toolRegistry;\n  }\n\n  getPromptRegistry(): PromptRegistry {\n    return this.promptRegistry;\n  }\n\n  getDebugMode(): boolean {\n    return this.debugMode;\n  }\n  getQuestion(): string | undefined {\n    return this.question;\n  }\n\n  getFullContext(): boolean {\n    return this.fullContext;\n  }\n\n  getCoreTools(): string[] | undefined {\n    return this.coreTools;\n  }\n\n  getExcludeTools(): string[] | undefined {\n    return this.excludeTools;\n  }\n\n  getToolDiscoveryCommand(): string | undefined {\n    return this.toolDiscoveryCommand;\n  }\n\n  getToolCallCommand(): string | undefined {\n    return this.toolCallCommand;\n  }\n\n  getMcpServerCommand(): string | undefined {\n    return this.mcpServerCommand;\n  }\n\n  getMcpServers(): Record<string, MCPServerConfig> | undefined {\n    return this.mcpServers;\n  }\n\n  getUserMemory(): string {\n    return this.userMemory;\n  }\n\n  setUserMemory(newUserMemory: string): void {\n    this.userMemory = newUserMemory;\n  }\n\n  getGeminiMdFileCount(): number {\n    return this.geminiMdFileCount;\n  }\n\n  setGeminiMdFileCount(count: number): void {\n    this.geminiMdFileCount = count;\n  }\n\n  getApprovalMode(): ApprovalMode {\n    return this.approvalMode;\n  }\n\n  setApprovalMode(mode: ApprovalMode): void {\n    this.approvalMode = mode;\n  }\n\n  getShowMemoryUsage(): boolean {\n    return this.showMemoryUsage;\n  }\n\n  getAccessibility(): AccessibilitySettings {\n    return this.accessibility;\n  }\n\n  getTelemetryEnabled(): boolean {\n    return this.telemetrySettings.enabled ?? false;\n  }\n\n  getTelemetryLogPromptsEnabled(): boolean {\n    return this.telemetrySettings.logPrompts ?? true;\n  }\n\n  getTelemetryOtlpEndpoint(): string {\n    return this.telemetrySettings.otlpEndpoint ?? DEFAULT_OTLP_ENDPOINT;\n  }\n\n  getTelemetryOtlpProtocol(): 'grpc' | 'http' {\n    return this.telemetrySettings.otlpProtocol ?? 'grpc';\n  }\n\n  getTelemetryTarget(): TelemetryTarget {\n    return this.telemetrySettings.target ?? DEFAULT_TELEMETRY_TARGET;\n  }\n\n  getTelemetryOutfile(): string | undefined {\n    return this.telemetrySettings.outfile;\n  }\n\n  getGeminiClient(): GeminiClient {\n    return this.geminiClient;\n  }\n\n  getEnableRecursiveFileSearch(): boolean {\n    return this.fileFiltering.enableRecursiveFileSearch;\n  }\n\n  getFileFilteringDisableFuzzySearch(): boolean {\n    return this.fileFiltering.disableFuzzySearch;\n  }\n\n  getFileFilteringRespectGitIgnore(): boolean {\n    return this.fileFiltering.respectGitIgnore;\n  }\n  getFileFilteringRespectGeminiIgnore(): boolean {\n    return this.fileFiltering.respectGeminiIgnore;\n  }\n\n  getFileFilteringOptions(): FileFilteringOptions {\n    return {\n      respectGitIgnore: this.fileFiltering.respectGitIgnore,\n      respectGeminiIgnore: this.fileFiltering.respectGeminiIgnore,\n    };\n  }\n\n  /**\n   * Gets custom file exclusion patterns from configuration.\n   * TODO: This is a placeholder implementation. In the future, this could\n   * read from settings files, CLI arguments, or environment variables.\n   */\n  getCustomExcludes(): string[] {\n    // Placeholder implementation - returns empty array for now\n    // Future implementation could read from:\n    // - User settings file\n    // - Project-specific configuration\n    // - Environment variables\n    // - CLI arguments\n    return [];\n  }\n\n  getCheckpointingEnabled(): boolean {\n    return this.checkpointing;\n  }\n\n  getProxy(): string | undefined {\n    return this.proxy;\n  }\n\n  getWorkingDir(): string {\n    return this.cwd;\n  }\n\n  getBugCommand(): BugCommandSettings | undefined {\n    return this.bugCommand;\n  }\n\n  getFileService(): FileDiscoveryService {\n    if (!this.fileDiscoveryService) {\n      this.fileDiscoveryService = new FileDiscoveryService(this.targetDir);\n    }\n    return this.fileDiscoveryService;\n  }\n\n  getUsageStatisticsEnabled(): boolean {\n    return this.usageStatisticsEnabled;\n  }\n\n  getExtensionContextFilePaths(): string[] {\n    return this.extensionContextFilePaths;\n  }\n\n  getExperimentalZedIntegration(): boolean {\n    return this.experimentalZedIntegration;\n  }\n\n  getListExtensions(): boolean {\n    return this.listExtensions;\n  }\n\n  getExtensions(): GeminiCLIExtension[] {\n    return this._extensions;\n  }\n\n  getBlockedMcpServers(): Array<{ name: string; extensionName: string }> {\n    return this._blockedMcpServers;\n  }\n\n  getNoBrowser(): boolean {\n    return this.noBrowser;\n  }\n\n  isBrowserLaunchSuppressed(): boolean {\n    return this.getNoBrowser() || !shouldAttemptBrowserLaunch();\n  }\n\n  getSummarizeToolOutputConfig():\n    | Record<string, SummarizeToolOutputSettings>\n    | undefined {\n    return this.summarizeToolOutput;\n  }\n\n  getIdeMode(): boolean {\n    return this.ideMode;\n  }\n\n  getFolderTrustFeature(): boolean {\n    return this.folderTrustFeature;\n  }\n\n  getFolderTrust(): boolean {\n    return this.folderTrust;\n  }\n\n  isTrustedFolder(): boolean | undefined {\n    return this.trustedFolder;\n  }\n\n  setIdeMode(value: boolean): void {\n    this.ideMode = value;\n  }\n\n  async setIdeModeAndSyncConnection(value: boolean): Promise<void> {\n    this.ideMode = value;\n    if (value) {\n      await this.ideClient.connect();\n      logIdeConnection(this, new IdeConnectionEvent(IdeConnectionType.SESSION));\n    } else {\n      await this.ideClient.disconnect();\n    }\n  }\n\n  getIdeClient(): IdeClient {\n    return this.ideClient;\n  }\n\n  /**\n   * Get the current FileSystemService\n   */\n  getFileSystemService(): FileSystemService {\n    return this.fileSystemService;\n  }\n\n  /**\n   * Set a custom FileSystemService\n   */\n  setFileSystemService(fileSystemService: FileSystemService): void {\n    this.fileSystemService = fileSystemService;\n  }\n\n  getChatCompression(): ChatCompressionSettings | undefined {\n    return this.chatCompression;\n  }\n\n  isInteractive(): boolean {\n    return this.interactive;\n  }\n\n  getUseRipgrep(): boolean {\n    return this.useRipgrep;\n  }\n\n  getShouldUseNodePtyShell(): boolean {\n    return this.shouldUseNodePtyShell;\n  }\n\n  getSkipNextSpeakerCheck(): boolean {\n    return this.skipNextSpeakerCheck;\n  }\n\n  getScreenReader(): boolean {\n    return this.accessibility.screenReader ?? false;\n  }\n\n  getEnablePromptCompletion(): boolean {\n    return this.enablePromptCompletion;\n  }\n\n  async getGitService(): Promise<GitService> {\n    if (!this.gitService) {\n      this.gitService = new GitService(this.targetDir, this.storage);\n      await this.gitService.initialize();\n    }\n    return this.gitService;\n  }\n\n  getFileExclusions(): FileExclusions {\n    return this.fileExclusions;\n  }\n\n  getLoopDetectionConfig(): LoopDetectionConfig {\n    return DEFAULT_LOOP_DETECTION_CONFIG;\n  }\n\n  async createToolRegistry(): Promise<ToolRegistry> {\n    const registry = new ToolRegistry(this);\n\n    // helper to create & register core tools that are enabled\n     \n    const registerCoreTool = (ToolClass: ToolConstructor, ...args: unknown[]) => {\n      const className = ToolClass.name;\n      const toolName = ToolClass.Name || className;\n      const coreTools = this.getCoreTools();\n      const excludeTools = this.getExcludeTools();\n\n      let isEnabled = false;\n      if (coreTools === undefined) {\n        isEnabled = true;\n      } else {\n        isEnabled = coreTools.some(\n          (tool) =>\n            tool === className ||\n            tool === toolName ||\n            tool.startsWith(`${className}(`) ||\n            tool.startsWith(`${toolName}(`),\n        );\n      }\n\n      if (\n        excludeTools?.includes(className) ||\n        excludeTools?.includes(toolName)\n      ) {\n        isEnabled = false;\n      }\n\n      if (isEnabled) {\n        registry.registerTool(new ToolClass(...args));\n      }\n    };\n\n    registerCoreTool(LSTool, this);\n    registerCoreTool(ReadFileTool, this);\n\n    if (this.getUseRipgrep()) {\n      registerCoreTool(RipGrepTool, this);\n    } else {\n      registerCoreTool(GrepTool, this);\n    }\n\n    registerCoreTool(GlobTool, this);\n    registerCoreTool(EditTool, this);\n    registerCoreTool(WriteFileTool, this);\n    registerCoreTool(UpsertCodeBlockTool);\n    registerCoreTool(ASTReadTool, this);\n    registerCoreTool(ASTFindTool, this);\n    registerCoreTool(ASTEditTool, this);\n    registerCoreTool(WebFetchTool, this);\n    registerCoreTool(ReadManyFilesTool, this);\n    registerCoreTool(ShellTool, this);\n    registerCoreTool(MemoryTool);\n    registerCoreTool(WebSearchTool, this);\n\n    await registry.discoverAllTools();\n    return registry;\n  }\n}\n\n// Export model constants for use in CLI\nexport { DEFAULT_GEMINI_FLASH_MODEL };\ninterface ToolConstructor {\n  new (...args: any[]): any; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Name?: string; // Static property\n  name: string; // Static property\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/config/flashFallback.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/config/models.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/config/storage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/config/storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/contentGenerator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/contentGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/coreToolScheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/geminiChat.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/geminiChat.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-this-alias","severity":2,"message":"Unexpected aliasing of 'this' to local variable.","line":349,"column":11,"nodeType":"Identifier","messageId":"thisAssignment","endLine":349,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/geminiRequest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/logger.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/loggingContentGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/nonInteractiveToolExecutor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/nonInteractiveToolExecutor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/prompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/subagent.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1537,1540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1537,1540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3769,3772],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3769,3772],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":186,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5784,5787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5784,5787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":214,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6684,6687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6684,6687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":761,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":761,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24960,24963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24960,24963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":782,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":782,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25641,25644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25641,25644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { vi, describe, it, expect, beforeEach, Mock, afterEach } from 'vitest';\nimport {\n  ContextState,\n  SubAgentScope,\n  SubagentTerminateMode,\n  PromptConfig,\n  ModelConfig,\n  RunConfig,\n  OutputConfig,\n  ToolConfig,\n} from './subagent.js';\nimport { Config, ConfigParameters } from '../config/config.js';\nimport { GeminiChat } from './geminiChat.js';\nimport { createContentGenerator } from './contentGenerator.js';\nimport { getEnvironmentContext } from '../utils/environmentContext.js';\nimport { executeToolCall } from './nonInteractiveToolExecutor.js';\nimport { ToolRegistry } from '../tools/tool-registry.js';\nimport { DEFAULT_GEMINI_MODEL } from '../config/models.js';\nimport {\n  Content,\n  FunctionCall,\n  FunctionDeclaration,\n  GenerateContentConfig,\n  Type,\n} from '@google/genai';\nimport { ToolErrorType } from '../tools/tool-error.js';\n\nvi.mock('./geminiChat.js');\nvi.mock('./contentGenerator.js');\nvi.mock('../utils/environmentContext.js');\nvi.mock('./nonInteractiveToolExecutor.js');\nvi.mock('../ide/ide-client.js');\n\nasync function createMockConfig(\n  toolRegistryMocks = {},\n): Promise<{ config: Config; toolRegistry: ToolRegistry }> {\n  const configParams: ConfigParameters = {\n    sessionId: 'test-session',\n    model: DEFAULT_GEMINI_MODEL,\n    targetDir: '.',\n    debugMode: false,\n    cwd: process.cwd(),\n  };\n  const config = new Config(configParams);\n  await config.initialize();\n   \n  await config.refreshAuth('test-auth' as any);\n\n  // Mock ToolRegistry\n  const mockToolRegistry = {\n    getTool: vi.fn(),\n    getFunctionDeclarationsFiltered: vi.fn().mockReturnValue([]),\n    ...toolRegistryMocks,\n  } as unknown as ToolRegistry;\n\n  vi.spyOn(config, 'getToolRegistry').mockReturnValue(mockToolRegistry);\n  return { config, toolRegistry: mockToolRegistry };\n}\n\n// Helper to simulate LLM responses (sequence of tool calls over multiple turns)\nconst createMockStream = (\n  functionCallsList: Array<FunctionCall[] | 'stop'>,\n) => {\n  let index = 0;\n  return vi.fn().mockImplementation(() => {\n    const response = functionCallsList[index] || 'stop';\n    index++;\n    return (async function* () {\n      if (response === 'stop') {\n        // When stopping, the model might return text, but the subagent logic primarily cares about the absence of functionCalls.\n        yield { text: 'Done.' };\n      } else if (response.length > 0) {\n        yield { functionCalls: response };\n      } else {\n        yield { text: 'Done.' }; // Handle empty array also as stop\n      }\n    })();\n  });\n};\n\ndescribe('subagent.ts', () => {\n  describe('ContextState', () => {\n    it('should set and get values correctly', () => {\n      const context = new ContextState();\n      context.set('key1', 'value1');\n      context.set('key2', 123);\n      expect(context.get('key1')).toBe('value1');\n      expect(context.get('key2')).toBe(123);\n      expect(context.get_keys()).toEqual(['key1', 'key2']);\n    });\n\n    it('should return undefined for missing keys', () => {\n      const context = new ContextState();\n      expect(context.get('missing')).toBeUndefined();\n    });\n  });\n\n  describe('SubAgentScope', () => {\n    let mockSendMessageStream: Mock;\n\n    const defaultModelConfig: ModelConfig = {\n      model: 'gemini-1.5-flash-latest',\n      temp: 0.5, // Specific temp to test override\n      top_p: 1,\n    };\n\n    const defaultRunConfig: RunConfig = {\n      max_time_minutes: 5,\n      max_turns: 10,\n    };\n\n    beforeEach(async () => {\n      vi.clearAllMocks();\n\n      vi.mocked(getEnvironmentContext).mockResolvedValue([\n        { text: 'Env Context' },\n      ]);\n      vi.mocked(createContentGenerator).mockResolvedValue({\n        getGenerativeModel: vi.fn(),\n         \n      } as any);\n\n      mockSendMessageStream = vi.fn();\n      // We mock the implementation of the constructor.\n      vi.mocked(GeminiChat).mockImplementation(\n        () =>\n          ({\n            sendMessageStream: mockSendMessageStream,\n          }) as unknown as GeminiChat,\n      );\n    });\n\n    afterEach(() => {\n      vi.restoreAllMocks();\n    });\n\n    // Helper to safely access generationConfig from mock calls\n    const getGenerationConfigFromMock = (\n      callIndex = 0,\n    ): GenerateContentConfig & { systemInstruction?: string | Content } => {\n      const callArgs = vi.mocked(GeminiChat).mock.calls[callIndex];\n      const generationConfig = callArgs?.[2];\n      // Ensure it's defined before proceeding\n      expect(generationConfig).toBeDefined();\n      if (!generationConfig) throw new Error('generationConfig is undefined');\n      return generationConfig as GenerateContentConfig & {\n        systemInstruction?: string | Content;\n      };\n    };\n\n    describe('create (Tool Validation)', () => {\n      const promptConfig: PromptConfig = { systemPrompt: 'Test prompt' };\n\n      it('should create a SubAgentScope successfully with minimal config', async () => {\n        const { config } = await createMockConfig();\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n        );\n        expect(scope).toBeInstanceOf(SubAgentScope);\n      });\n\n      it('should throw an error if a tool requires confirmation', async () => {\n        const mockTool = {\n          schema: { parameters: { type: Type.OBJECT, properties: {} } },\n          build: vi.fn().mockReturnValue({\n            shouldConfirmExecute: vi.fn().mockResolvedValue({\n              type: 'exec',\n              title: 'Confirm',\n              command: 'rm -rf /',\n            }),\n          }),\n        };\n\n        const { config } = await createMockConfig({\n           \n          getTool: vi.fn().mockReturnValue(mockTool as any),\n        });\n\n        const toolConfig: ToolConfig = { tools: ['risky_tool'] };\n\n        await expect(\n          SubAgentScope.create(\n            'test-agent',\n            config,\n            promptConfig,\n            defaultModelConfig,\n            defaultRunConfig,\n            toolConfig,\n          ),\n        ).rejects.toThrow(\n          'Tool \"risky_tool\" requires user confirmation and cannot be used in a non-interactive subagent.',\n        );\n      });\n\n      it('should succeed if tools do not require confirmation', async () => {\n        const mockTool = {\n          schema: { parameters: { type: Type.OBJECT, properties: {} } },\n          build: vi.fn().mockReturnValue({\n            shouldConfirmExecute: vi.fn().mockResolvedValue(null),\n          }),\n        };\n        const { config } = await createMockConfig({\n           \n          getTool: vi.fn().mockReturnValue(mockTool as any),\n        });\n\n        const toolConfig: ToolConfig = { tools: ['safe_tool'] };\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          toolConfig,\n        );\n        expect(scope).toBeInstanceOf(SubAgentScope);\n      });\n\n      it('should skip interactivity check and warn for tools with required parameters', async () => {\n        const consoleWarnSpy = vi\n          .spyOn(console, 'warn')\n          .mockImplementation(() => {});\n\n        const mockToolWithParams = {\n          schema: {\n            parameters: {\n              type: Type.OBJECT,\n              properties: {\n                path: { type: Type.STRING },\n              },\n              required: ['path'],\n            },\n          },\n          // build should not be called, but we mock it to be safe\n          build: vi.fn(),\n        };\n\n        const { config } = await createMockConfig({\n          getTool: vi.fn().mockReturnValue(mockToolWithParams),\n        });\n\n        const toolConfig: ToolConfig = { tools: ['tool_with_params'] };\n\n        // The creation should succeed without throwing\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          toolConfig,\n        );\n\n        expect(scope).toBeInstanceOf(SubAgentScope);\n\n        // Check that the warning was logged\n        expect(consoleWarnSpy).toHaveBeenCalledWith(\n          'Cannot check tool \"tool_with_params\" for interactivity because it requires parameters. Assuming it is safe for non-interactive use.',\n        );\n\n        // Ensure build was never called\n        expect(mockToolWithParams.build).not.toHaveBeenCalled();\n\n        consoleWarnSpy.mockRestore();\n      });\n    });\n\n    describe('runNonInteractive - Initialization and Prompting', () => {\n      it('should correctly template the system prompt and initialize GeminiChat', async () => {\n        const { config } = await createMockConfig();\n\n        vi.mocked(GeminiChat).mockClear();\n\n        const promptConfig: PromptConfig = {\n          systemPrompt: 'Hello ${name}, your task is ${task}.',\n        };\n        const context = new ContextState();\n        context.set('name', 'Agent');\n        context.set('task', 'Testing');\n\n        // Model stops immediately\n        mockSendMessageStream.mockImplementation(createMockStream(['stop']));\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n        );\n\n        await scope.runNonInteractive(context);\n\n        // Check if GeminiChat was initialized correctly by the subagent\n        expect(GeminiChat).toHaveBeenCalledTimes(1);\n        const callArgs = vi.mocked(GeminiChat).mock.calls[0];\n\n        // Check Generation Config\n        const generationConfig = getGenerationConfigFromMock();\n\n        // Check temperature override\n        expect(generationConfig.temperature).toBe(defaultModelConfig.temp);\n        expect(generationConfig.systemInstruction).toContain(\n          'Hello Agent, your task is Testing.',\n        );\n        expect(generationConfig.systemInstruction).toContain(\n          'Important Rules:',\n        );\n\n        // Check History (should include environment context)\n        const history = callArgs[3];\n        expect(history).toEqual([\n          { role: 'user', parts: [{ text: 'Env Context' }] },\n          {\n            role: 'model',\n            parts: [{ text: 'Got it. Thanks for the context!' }],\n          },\n        ]);\n      });\n\n      it('should include output instructions in the system prompt when outputs are defined', async () => {\n        const { config } = await createMockConfig();\n        vi.mocked(GeminiChat).mockClear();\n\n        const promptConfig: PromptConfig = { systemPrompt: 'Do the task.' };\n        const outputConfig: OutputConfig = {\n          outputs: {\n            result1: 'The first result',\n          },\n        };\n        const context = new ContextState();\n\n        // Model stops immediately\n        mockSendMessageStream.mockImplementation(createMockStream(['stop']));\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          undefined, // ToolConfig\n          outputConfig,\n        );\n\n        await scope.runNonInteractive(context);\n\n        const generationConfig = getGenerationConfigFromMock();\n        const systemInstruction = generationConfig.systemInstruction as string;\n\n        expect(systemInstruction).toContain('Do the task.');\n        expect(systemInstruction).toContain(\n          'you MUST emit the required output variables',\n        );\n        expect(systemInstruction).toContain(\n          \"Use 'self.emitvalue' to emit the 'result1' key\",\n        );\n      });\n\n      it('should use initialMessages instead of systemPrompt if provided', async () => {\n        const { config } = await createMockConfig();\n        vi.mocked(GeminiChat).mockClear();\n\n        const initialMessages: Content[] = [\n          { role: 'user', parts: [{ text: 'Hi' }] },\n        ];\n        const promptConfig: PromptConfig = { initialMessages };\n        const context = new ContextState();\n\n        // Model stops immediately\n        mockSendMessageStream.mockImplementation(createMockStream(['stop']));\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n        );\n\n        await scope.runNonInteractive(context);\n\n        const callArgs = vi.mocked(GeminiChat).mock.calls[0];\n        const generationConfig = getGenerationConfigFromMock();\n        const history = callArgs[3];\n\n        expect(generationConfig.systemInstruction).toBeUndefined();\n        expect(history).toEqual([\n          { role: 'user', parts: [{ text: 'Env Context' }] },\n          {\n            role: 'model',\n            parts: [{ text: 'Got it. Thanks for the context!' }],\n          },\n          ...initialMessages,\n        ]);\n      });\n\n      it('should throw an error if template variables are missing', async () => {\n        const { config } = await createMockConfig();\n        const promptConfig: PromptConfig = {\n          systemPrompt: 'Hello ${name}, you are missing ${missing}.',\n        };\n        const context = new ContextState();\n        context.set('name', 'Agent');\n        // 'missing' is not set\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n        );\n\n        // The error from templating causes the runNonInteractive to reject and the terminate_reason to be ERROR.\n        await expect(scope.runNonInteractive(context)).rejects.toThrow(\n          'Missing context values for the following keys: missing',\n        );\n        expect(scope.output.terminate_reason).toBe(SubagentTerminateMode.ERROR);\n      });\n\n      it('should validate that systemPrompt and initialMessages are mutually exclusive', async () => {\n        const { config } = await createMockConfig();\n        const promptConfig: PromptConfig = {\n          systemPrompt: 'System',\n          initialMessages: [{ role: 'user', parts: [{ text: 'Hi' }] }],\n        };\n        const context = new ContextState();\n\n        const agent = await SubAgentScope.create(\n          'TestAgent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n        );\n\n        await expect(agent.runNonInteractive(context)).rejects.toThrow(\n          'PromptConfig cannot have both `systemPrompt` and `initialMessages` defined.',\n        );\n        expect(agent.output.terminate_reason).toBe(SubagentTerminateMode.ERROR);\n      });\n    });\n\n    describe('runNonInteractive - Execution and Tool Use', () => {\n      const promptConfig: PromptConfig = { systemPrompt: 'Execute task.' };\n\n      it('should terminate with GOAL if no outputs are expected and model stops', async () => {\n        const { config } = await createMockConfig();\n        // Model stops immediately\n        mockSendMessageStream.mockImplementation(createMockStream(['stop']));\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          // No ToolConfig, No OutputConfig\n        );\n\n        await scope.runNonInteractive(new ContextState());\n\n        expect(scope.output.terminate_reason).toBe(SubagentTerminateMode.GOAL);\n        expect(scope.output.emitted_vars).toEqual({});\n        expect(mockSendMessageStream).toHaveBeenCalledTimes(1);\n        // Check the initial message\n        expect(mockSendMessageStream.mock.calls[0][0].message).toEqual([\n          { text: 'Get Started!' },\n        ]);\n      });\n\n      it('should handle self.emitvalue and terminate with GOAL when outputs are met', async () => {\n        const { config } = await createMockConfig();\n        const outputConfig: OutputConfig = {\n          outputs: { result: 'The final result' },\n        };\n\n        // Turn 1: Model responds with emitvalue call\n        // Turn 2: Model stops after receiving the tool response\n        mockSendMessageStream.mockImplementation(\n          createMockStream([\n            [\n              {\n                name: 'self.emitvalue',\n                args: {\n                  emit_variable_name: 'result',\n                  emit_variable_value: 'Success!',\n                },\n              },\n            ],\n            'stop',\n          ]),\n        );\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          undefined,\n          outputConfig,\n        );\n\n        await scope.runNonInteractive(new ContextState());\n\n        expect(scope.output.terminate_reason).toBe(SubagentTerminateMode.GOAL);\n        expect(scope.output.emitted_vars).toEqual({ result: 'Success!' });\n        expect(mockSendMessageStream).toHaveBeenCalledTimes(2);\n\n        // Check the tool response sent back in the second call\n        const secondCallArgs = mockSendMessageStream.mock.calls[1][0];\n        expect(secondCallArgs.message).toEqual([\n          { text: 'Emitted variable result successfully' },\n        ]);\n      });\n\n      it('should execute external tools and provide the response to the model', async () => {\n        const listFilesToolDef: FunctionDeclaration = {\n          name: 'list_files',\n          description: 'Lists files',\n          parameters: { type: Type.OBJECT, properties: {} },\n        };\n\n        const { config } = await createMockConfig({\n          getFunctionDeclarationsFiltered: vi\n            .fn()\n            .mockReturnValue([listFilesToolDef]),\n        });\n        const toolConfig: ToolConfig = { tools: ['list_files'] };\n\n        // Turn 1: Model calls the external tool\n        // Turn 2: Model stops\n        mockSendMessageStream.mockImplementation(\n          createMockStream([\n            [\n              {\n                id: 'call_1',\n                name: 'list_files',\n                args: { path: '.' },\n              },\n            ],\n            'stop',\n          ]),\n        );\n\n        // Mock the tool execution result\n        vi.mocked(executeToolCall).mockResolvedValue({\n          callId: 'call_1',\n          responseParts: [{ text: 'file1.txt\\nfile2.ts' }],\n          resultDisplay: 'Listed 2 files',\n          error: undefined,\n          errorType: undefined, // Or ToolErrorType.NONE if available and appropriate\n        });\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          toolConfig,\n        );\n\n        await scope.runNonInteractive(new ContextState());\n\n        // Check tool execution\n        expect(executeToolCall).toHaveBeenCalledWith(\n          config,\n          expect.objectContaining({ name: 'list_files', args: { path: '.' } }),\n          expect.any(AbortSignal),\n        );\n\n        // Check the response sent back to the model\n        const secondCallArgs = mockSendMessageStream.mock.calls[1][0];\n        expect(secondCallArgs.message).toEqual([\n          { text: 'file1.txt\\nfile2.ts' },\n        ]);\n\n        expect(scope.output.terminate_reason).toBe(SubagentTerminateMode.GOAL);\n      });\n\n      it('should provide specific tool error responses to the model', async () => {\n        const { config } = await createMockConfig();\n        const toolConfig: ToolConfig = { tools: ['failing_tool'] };\n\n        // Turn 1: Model calls the failing tool\n        // Turn 2: Model stops after receiving the error response\n        mockSendMessageStream.mockImplementation(\n          createMockStream([\n            [\n              {\n                id: 'call_fail',\n                name: 'failing_tool',\n                args: {},\n              },\n            ],\n            'stop',\n          ]),\n        );\n\n        // Mock the tool execution failure.\n        vi.mocked(executeToolCall).mockResolvedValue({\n          callId: 'call_fail',\n          responseParts: [{ text: 'ERROR: Tool failed catastrophically' }], // This should be sent to the model\n          resultDisplay: 'Tool failed catastrophically',\n          error: new Error('Failure'),\n          errorType: ToolErrorType.INVALID_TOOL_PARAMS,\n        });\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          toolConfig,\n        );\n\n        await scope.runNonInteractive(new ContextState());\n\n        // The agent should send the specific error message from responseParts.\n        const secondCallArgs = mockSendMessageStream.mock.calls[1][0];\n\n        expect(secondCallArgs.message).toEqual([\n          {\n            text: 'ERROR: Tool failed catastrophically',\n          },\n        ]);\n      });\n\n      it('should nudge the model if it stops before emitting all required variables', async () => {\n        const { config } = await createMockConfig();\n        const outputConfig: OutputConfig = {\n          outputs: { required_var: 'Must be present' },\n        };\n\n        // Turn 1: Model stops prematurely\n        // Turn 2: Model responds to the nudge and emits the variable\n        // Turn 3: Model stops\n        mockSendMessageStream.mockImplementation(\n          createMockStream([\n            'stop',\n            [\n              {\n                name: 'self.emitvalue',\n                args: {\n                  emit_variable_name: 'required_var',\n                  emit_variable_value: 'Here it is',\n                },\n              },\n            ],\n            'stop',\n          ]),\n        );\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n          undefined,\n          outputConfig,\n        );\n\n        await scope.runNonInteractive(new ContextState());\n\n        // Check the nudge message sent in Turn 2\n        const secondCallArgs = mockSendMessageStream.mock.calls[1][0];\n\n        // We check that the message contains the required variable name and the nudge phrasing.\n        expect(secondCallArgs.message[0].text).toContain('required_var');\n        expect(secondCallArgs.message[0].text).toContain(\n          'You have stopped calling tools',\n        );\n\n        expect(scope.output.terminate_reason).toBe(SubagentTerminateMode.GOAL);\n        expect(scope.output.emitted_vars).toEqual({\n          required_var: 'Here it is',\n        });\n        expect(mockSendMessageStream).toHaveBeenCalledTimes(3);\n      });\n    });\n\n    describe('runNonInteractive - Termination and Recovery', () => {\n      const promptConfig: PromptConfig = { systemPrompt: 'Execute task.' };\n\n      it('should terminate with MAX_TURNS if the limit is reached', async () => {\n        const { config } = await createMockConfig();\n        const runConfig: RunConfig = { ...defaultRunConfig, max_turns: 2 };\n\n        // Model keeps looping by calling emitvalue repeatedly\n        mockSendMessageStream.mockImplementation(\n          createMockStream([\n            [\n              {\n                name: 'self.emitvalue',\n                args: { emit_variable_name: 'loop', emit_variable_value: 'v1' },\n              },\n            ],\n            [\n              {\n                name: 'self.emitvalue',\n                args: { emit_variable_name: 'loop', emit_variable_value: 'v2' },\n              },\n            ],\n            // This turn should not happen\n            [\n              {\n                name: 'self.emitvalue',\n                args: { emit_variable_name: 'loop', emit_variable_value: 'v3' },\n              },\n            ],\n          ]),\n        );\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          runConfig,\n        );\n\n        await scope.runNonInteractive(new ContextState());\n\n        expect(mockSendMessageStream).toHaveBeenCalledTimes(2);\n        expect(scope.output.terminate_reason).toBe(\n          SubagentTerminateMode.MAX_TURNS,\n        );\n      });\n\n      it('should terminate with TIMEOUT if the time limit is reached during an LLM call', async () => {\n        // Use fake timers to reliably test timeouts\n        vi.useFakeTimers();\n\n        const { config } = await createMockConfig();\n        const runConfig: RunConfig = { max_time_minutes: 5, max_turns: 100 };\n\n        // We need to control the resolution of the sendMessageStream promise to advance the timer during execution.\n        let resolveStream: (\n          value: AsyncGenerator<unknown, void, unknown>,\n        ) => void;\n        const streamPromise = new Promise<\n          AsyncGenerator<unknown, void, unknown>\n        >((resolve) => {\n           \n          resolveStream = resolve as any;\n        });\n\n        // The LLM call will hang until we resolve the promise.\n        mockSendMessageStream.mockReturnValue(streamPromise);\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          runConfig,\n        );\n\n        const runPromise = scope.runNonInteractive(new ContextState());\n\n        // Advance time beyond the limit (6 minutes) while the agent is awaiting the LLM response.\n        await vi.advanceTimersByTimeAsync(6 * 60 * 1000);\n\n        // Now resolve the stream. The model returns 'stop'.\n         \n        resolveStream!(createMockStream(['stop'])() as any);\n\n        await runPromise;\n\n        expect(scope.output.terminate_reason).toBe(\n          SubagentTerminateMode.TIMEOUT,\n        );\n        expect(mockSendMessageStream).toHaveBeenCalledTimes(1);\n\n        vi.useRealTimers();\n      });\n\n      it('should terminate with ERROR if the model call throws', async () => {\n        const { config } = await createMockConfig();\n        mockSendMessageStream.mockRejectedValue(new Error('API Failure'));\n\n        const scope = await SubAgentScope.create(\n          'test-agent',\n          config,\n          promptConfig,\n          defaultModelConfig,\n          defaultRunConfig,\n        );\n\n        await expect(\n          scope.runNonInteractive(new ContextState()),\n        ).rejects.toThrow('API Failure');\n        expect(scope.output.terminate_reason).toBe(SubagentTerminateMode.ERROR);\n      });\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/subagent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/tokenLimits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/turn.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/core/turn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/generated/git-commit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/detect-ide.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/detect-ide.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/ide-client.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/ide-client.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[902,905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[902,905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[982,985],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[982,985],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as fs from 'node:fs';\nimport { isSubpath } from '../utils/paths.js';\nimport { detectIde, DetectedIde, getIdeInfo } from '../ide/detect-ide.js';\nimport {\n  ideContext,\n  IdeContextNotificationSchema,\n  IdeDiffAcceptedNotificationSchema,\n  IdeDiffClosedNotificationSchema,\n  CloseDiffResponseSchema,\n  DiffUpdateResult,\n} from '../ide/ideContext.js';\nimport { getIdeProcessId } from './process-utils.js';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport * as os from 'node:os';\nimport * as path from 'node:path';\nimport { EnvHttpProxyAgent } from 'undici';\n\nconst logger = {\n   \n  debug: (...args: any[]) => console.debug('[DEBUG] [IDEClient]', ...args),\n   \n  error: (...args: any[]) => console.error('[ERROR] [IDEClient]', ...args),\n};\n\nexport type IDEConnectionState = {\n  status: IDEConnectionStatus;\n  details?: string; // User-facing\n};\n\nexport enum IDEConnectionStatus {\n  Connected = 'connected',\n  Disconnected = 'disconnected',\n  Connecting = 'connecting',\n}\n\ntype StdioConfig = {\n  command: string;\n  args: string[];\n};\n\ntype ConnectionConfig = {\n  port?: string;\n  stdio?: StdioConfig;\n};\n\nfunction getRealPath(path: string): string {\n  try {\n    return fs.realpathSync(path);\n  } catch (_e) {\n    // If realpathSync fails, it might be because the path doesn't exist.\n    // In that case, we can fall back to the original path.\n    return path;\n  }\n}\n\n/**\n * Manages the connection to and interaction with the IDE server.\n */\nexport class IdeClient {\n  private static instance: IdeClient;\n  private client: Client | undefined = undefined;\n  private state: IDEConnectionState = {\n    status: IDEConnectionStatus.Disconnected,\n    details:\n      'IDE integration is currently disabled. To enable it, run /ide enable.',\n  };\n  private readonly currentIde: DetectedIde | undefined;\n  private readonly currentIdeDisplayName: string | undefined;\n  private diffResponses = new Map<string, (result: DiffUpdateResult) => void>();\n  private statusListeners = new Set<(state: IDEConnectionState) => void>();\n\n  private constructor() {\n    this.currentIde = detectIde();\n    if (this.currentIde) {\n      this.currentIdeDisplayName = getIdeInfo(this.currentIde).displayName;\n    }\n  }\n\n  static getInstance(): IdeClient {\n    if (!IdeClient.instance) {\n      IdeClient.instance = new IdeClient();\n    }\n    return IdeClient.instance;\n  }\n\n  addStatusChangeListener(listener: (state: IDEConnectionState) => void) {\n    this.statusListeners.add(listener);\n  }\n\n  removeStatusChangeListener(listener: (state: IDEConnectionState) => void) {\n    this.statusListeners.delete(listener);\n  }\n\n  async connect(): Promise<void> {\n    if (!this.currentIde || !this.currentIdeDisplayName) {\n      this.setState(\n        IDEConnectionStatus.Disconnected,\n        `IDE integration is not supported in your current environment. To use this feature, run Gemini CLI in one of these supported IDEs: ${Object.values(\n          DetectedIde,\n        )\n          .map((ide) => getIdeInfo(ide).displayName)\n          .join(', ')}`,\n        false,\n      );\n      return;\n    }\n\n    this.setState(IDEConnectionStatus.Connecting);\n\n    const configFromFile = await this.getConnectionConfigFromFile();\n    const workspacePath =\n      configFromFile?.workspacePath ??\n      process.env['GEMINI_CLI_IDE_WORKSPACE_PATH'];\n\n    const { isValid, error } = IdeClient.validateWorkspacePath(\n      workspacePath,\n      this.currentIdeDisplayName,\n      process.cwd(),\n    );\n\n    if (!isValid) {\n      this.setState(IDEConnectionStatus.Disconnected, error, true);\n      return;\n    }\n\n    if (configFromFile) {\n      if (configFromFile.port) {\n        const connected = await this.establishHttpConnection(\n          configFromFile.port,\n        );\n        if (connected) {\n          return;\n        }\n      }\n      if (configFromFile.stdio) {\n        const connected = await this.establishStdioConnection(\n          configFromFile.stdio,\n        );\n        if (connected) {\n          return;\n        }\n      }\n    }\n\n    const portFromEnv = this.getPortFromEnv();\n    if (portFromEnv) {\n      const connected = await this.establishHttpConnection(portFromEnv);\n      if (connected) {\n        return;\n      }\n    }\n\n    const stdioConfigFromEnv = this.getStdioConfigFromEnv();\n    if (stdioConfigFromEnv) {\n      const connected = await this.establishStdioConnection(stdioConfigFromEnv);\n      if (connected) {\n        return;\n      }\n    }\n\n    this.setState(\n      IDEConnectionStatus.Disconnected,\n      `Failed to connect to IDE companion extension for ${this.currentIdeDisplayName}. Please ensure the extension is running. To install the extension, run /ide install.`,\n      true,\n    );\n  }\n\n  /**\n   * A diff is accepted with any modifications if the user performs one of the\n   * following actions:\n   * - Clicks the checkbox icon in the IDE to accept\n   * - Runs `command+shift+p` > \"Gemini CLI: Accept Diff in IDE\" to accept\n   * - Selects \"accept\" in the CLI UI\n   * - Saves the file via `ctrl/command+s`\n   *\n   * A diff is rejected if the user performs one of the following actions:\n   * - Clicks the \"x\" icon in the IDE\n   * - Runs \"Gemini CLI: Close Diff in IDE\"\n   * - Selects \"no\" in the CLI UI\n   * - Closes the file\n   */\n  async openDiff(\n    filePath: string,\n    newContent?: string,\n  ): Promise<DiffUpdateResult> {\n    return new Promise<DiffUpdateResult>((resolve, reject) => {\n      this.diffResponses.set(filePath, resolve);\n      this.client\n        ?.callTool({\n          name: `openDiff`,\n          arguments: {\n            filePath,\n            newContent,\n          },\n        })\n        .catch((err) => {\n          logger.debug(`callTool for ${filePath} failed:`, err);\n          reject(err);\n        });\n    });\n  }\n\n  async closeDiff(filePath: string): Promise<string | undefined> {\n    try {\n      const result = await this.client?.callTool({\n        name: `closeDiff`,\n        arguments: {\n          filePath,\n        },\n      });\n\n      if (result) {\n        const parsed = CloseDiffResponseSchema.parse(result);\n        return parsed.content;\n      }\n    } catch (err) {\n      logger.debug(`callTool for ${filePath} failed:`, err);\n    }\n    return;\n  }\n\n  // Closes the diff. Instead of waiting for a notification,\n  // manually resolves the diff resolver as the desired outcome.\n  async resolveDiffFromCli(filePath: string, outcome: 'accepted' | 'rejected') {\n    const content = await this.closeDiff(filePath);\n    const resolver = this.diffResponses.get(filePath);\n    if (resolver) {\n      if (outcome === 'accepted') {\n        resolver({ status: 'accepted', content });\n      } else {\n        resolver({ status: 'rejected', content: undefined });\n      }\n      this.diffResponses.delete(filePath);\n    }\n  }\n\n  async disconnect() {\n    if (this.state.status === IDEConnectionStatus.Disconnected) {\n      return;\n    }\n    for (const filePath of this.diffResponses.keys()) {\n      await this.closeDiff(filePath);\n    }\n    this.diffResponses.clear();\n    this.setState(\n      IDEConnectionStatus.Disconnected,\n      'IDE integration disabled. To enable it again, run /ide enable.',\n    );\n    this.client?.close();\n  }\n\n  getCurrentIde(): DetectedIde | undefined {\n    return this.currentIde;\n  }\n\n  getConnectionStatus(): IDEConnectionState {\n    return this.state;\n  }\n\n  getDetectedIdeDisplayName(): string | undefined {\n    return this.currentIdeDisplayName;\n  }\n\n  private setState(\n    status: IDEConnectionStatus,\n    details?: string,\n    logToConsole = false,\n  ) {\n    const isAlreadyDisconnected =\n      this.state.status === IDEConnectionStatus.Disconnected &&\n      status === IDEConnectionStatus.Disconnected;\n\n    // Only update details & log to console if the state wasn't already\n    // disconnected, so that the first detail message is preserved.\n    if (!isAlreadyDisconnected) {\n      this.state = { status, details };\n      for (const listener of this.statusListeners) {\n        listener(this.state);\n      }\n      if (details) {\n        if (logToConsole) {\n          logger.error(details);\n        } else {\n          // We only want to log disconnect messages to debug\n          // if they are not already being logged to the console.\n          logger.debug(details);\n        }\n      }\n    }\n\n    if (status === IDEConnectionStatus.Disconnected) {\n      ideContext.clearIdeContext();\n    }\n  }\n\n  static validateWorkspacePath(\n    ideWorkspacePath: string | undefined,\n    currentIdeDisplayName: string | undefined,\n    cwd: string,\n  ): { isValid: boolean; error?: string } {\n    if (ideWorkspacePath === undefined) {\n      return {\n        isValid: false,\n        error: `Failed to connect to IDE companion extension for ${currentIdeDisplayName}. Please ensure the extension is running. To install the extension, run /ide install.`,\n      };\n    }\n\n    if (ideWorkspacePath === '') {\n      return {\n        isValid: false,\n        error: `To use this feature, please open a workspace folder in ${currentIdeDisplayName} and try again.`,\n      };\n    }\n\n    const ideWorkspacePaths = ideWorkspacePath.split(path.delimiter);\n    const realCwd = getRealPath(cwd);\n    const isWithinWorkspace = ideWorkspacePaths.some((workspacePath) => {\n      const idePath = getRealPath(workspacePath);\n      return isSubpath(idePath, realCwd);\n    });\n\n    if (!isWithinWorkspace) {\n      return {\n        isValid: false,\n        error: `Directory mismatch. Gemini CLI is running in a different location than the open workspace in ${currentIdeDisplayName}. Please run the CLI from one of the following directories: ${ideWorkspacePaths.join(\n          ', ',\n        )}`,\n      };\n    }\n    return { isValid: true };\n  }\n\n  private getPortFromEnv(): string | undefined {\n    const port = process.env['GEMINI_CLI_IDE_SERVER_PORT'];\n    if (!port) {\n      return undefined;\n    }\n    return port;\n  }\n\n  private getStdioConfigFromEnv(): StdioConfig | undefined {\n    const command = process.env['GEMINI_CLI_IDE_SERVER_STDIO_COMMAND'];\n    if (!command) {\n      return undefined;\n    }\n\n    const argsStr = process.env['GEMINI_CLI_IDE_SERVER_STDIO_ARGS'];\n    let args: string[] = [];\n    if (argsStr) {\n      try {\n        const parsedArgs = JSON.parse(argsStr);\n        if (Array.isArray(parsedArgs)) {\n          args = parsedArgs;\n        } else {\n          logger.error(\n            'GEMINI_CLI_IDE_SERVER_STDIO_ARGS must be a JSON array string.',\n          );\n        }\n      } catch (_e) {\n        logger.error('Failed to parse GEMINI_CLI_IDE_SERVER_STDIO_ARGS:', _e);\n      }\n    }\n\n    return { command, args };\n  }\n\n  private async getConnectionConfigFromFile(): Promise<\n    (ConnectionConfig & { workspacePath?: string }) | undefined\n  > {\n    try {\n      const ideProcessId = await getIdeProcessId();\n      const portFile = path.join(\n        os.tmpdir(),\n        `gemini-ide-server-${ideProcessId}.json`,\n      );\n      const portFileContents = await fs.promises.readFile(portFile, 'utf8');\n      return JSON.parse(portFileContents);\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n  private createProxyAwareFetch() {\n    // ignore proxy for 'localhost' by deafult to allow connecting to the ide mcp server\n    const existingNoProxy = process.env['NO_PROXY'] || '';\n    const agent = new EnvHttpProxyAgent({\n      noProxy: [existingNoProxy, 'localhost'].filter(Boolean).join(','),\n    });\n    const undiciPromise = import('undici');\n    return async (url: string | URL, init?: RequestInit): Promise<Response> => {\n      const { fetch: fetchFn } = await undiciPromise;\n      const fetchOptions: RequestInit & { dispatcher?: unknown } = {\n        ...init,\n        dispatcher: agent,\n      };\n      const options = fetchOptions as unknown as import('undici').RequestInit;\n      const response = await fetchFn(url, options);\n      return new Response(response.body as ReadableStream<unknown> | null, {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n      });\n    };\n  }\n\n  private registerClientHandlers() {\n    if (!this.client) {\n      return;\n    }\n\n    this.client.setNotificationHandler(\n      IdeContextNotificationSchema,\n      (notification) => {\n        ideContext.setIdeContext(notification.params);\n      },\n    );\n    this.client.onerror = (_error) => {\n      this.setState(\n        IDEConnectionStatus.Disconnected,\n        `IDE connection error. The connection was lost unexpectedly. Please try reconnecting by running /ide enable`,\n        true,\n      );\n    };\n    this.client.onclose = () => {\n      this.setState(\n        IDEConnectionStatus.Disconnected,\n        `IDE connection error. The connection was lost unexpectedly. Please try reconnecting by running /ide enable`,\n        true,\n      );\n    };\n    this.client.setNotificationHandler(\n      IdeDiffAcceptedNotificationSchema,\n      (notification) => {\n        const { filePath, content } = notification.params;\n        const resolver = this.diffResponses.get(filePath);\n        if (resolver) {\n          resolver({ status: 'accepted', content });\n          this.diffResponses.delete(filePath);\n        } else {\n          logger.debug(`No resolver found for ${filePath}`);\n        }\n      },\n    );\n\n    this.client.setNotificationHandler(\n      IdeDiffClosedNotificationSchema,\n      (notification) => {\n        const { filePath } = notification.params;\n        const resolver = this.diffResponses.get(filePath);\n        if (resolver) {\n          resolver({ status: 'rejected', content: undefined });\n          this.diffResponses.delete(filePath);\n        } else {\n          logger.debug(`No resolver found for ${filePath}`);\n        }\n      },\n    );\n  }\n\n  private async establishHttpConnection(port: string): Promise<boolean> {\n    let transport: StreamableHTTPClientTransport | undefined;\n    try {\n      logger.debug('Attempting to connect to IDE via HTTP SSE');\n      this.client = new Client({\n        name: 'streamable-http-client',\n        // TODO(#3487): use the CLI version here.\n        version: '1.0.0',\n      });\n      transport = new StreamableHTTPClientTransport(\n        new URL(`http://${getIdeServerHost()}:${port}/mcp`),\n        {\n          fetch: this.createProxyAwareFetch(),\n        },\n      );\n      await this.client.connect(transport);\n      this.registerClientHandlers();\n      this.setState(IDEConnectionStatus.Connected);\n      return true;\n    } catch (_error) {\n      if (transport) {\n        try {\n          await transport.close();\n        } catch (closeError) {\n          logger.debug('Failed to close transport:', closeError);\n        }\n      }\n      return false;\n    }\n  }\n\n  private async establishStdioConnection({\n    command,\n    args,\n  }: StdioConfig): Promise<boolean> {\n    let transport: StdioClientTransport | undefined;\n    try {\n      logger.debug('Attempting to connect to IDE via stdio');\n      this.client = new Client({\n        name: 'stdio-client',\n        // TODO(#3487): use the CLI version here.\n        version: '1.0.0',\n      });\n\n      transport = new StdioClientTransport({\n        command,\n        args,\n      });\n      await this.client.connect(transport);\n      this.registerClientHandlers();\n      this.setState(IDEConnectionStatus.Connected);\n      return true;\n    } catch (_error) {\n      if (transport) {\n        try {\n          await transport.close();\n        } catch (closeError) {\n          logger.debug('Failed to close transport:', closeError);\n        }\n      }\n      return false;\n    }\n  }\n}\n\nfunction getIdeServerHost() {\n  const isInContainer =\n    fs.existsSync('/.dockerenv') || fs.existsSync('/run/.containerenv');\n  return isInContainer ? 'host.docker.internal' : 'localhost';\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/ide-installer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/ide-installer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/ideContext.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/ideContext.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/ide/process-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/google-auth-provider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/google-auth-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/oauth-provider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/oauth-provider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/oauth-token-storage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/oauth-token-storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/oauth-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mcp/oauth-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/mocks/msw.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/prompts/mcp-prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/prompts/prompt-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/chatRecordingService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/chatRecordingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/fileDiscoveryService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/fileDiscoveryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/fileSystemService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/gitService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/gitService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/loopDetectionService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/loopDetectionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/shellExecutionService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/services/shellExecutionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/clearcut-logger/clearcut-logger.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1251,1254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1251,1254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":45,"column":13,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":45,"endColumn":21,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[1228,1284],"text":"type Matchers<T = any> = CustomMatchers<T>"},"desc":"Replace empty interface with a type alias."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport 'vitest';\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  afterEach,\n  beforeAll,\n  afterAll,\n} from 'vitest';\nimport {\n  ClearcutLogger,\n  LogEvent,\n  LogEventEntry,\n  EventNames,\n  TEST_ONLY,\n} from './clearcut-logger.js';\nimport {\n  AuthType,\n  ContentGeneratorConfig,\n} from '../../core/contentGenerator.js';\nimport { ConfigParameters } from '../../config/config.js';\nimport { EventMetadataKey } from './event-metadata-key.js';\nimport { makeFakeConfig } from '../../test-utils/config.js';\nimport { http, HttpResponse } from 'msw';\nimport { server } from '../../mocks/msw.js';\nimport { UserPromptEvent, makeChatCompressionEvent } from '../types.js';\nimport { GIT_COMMIT_INFO, CLI_VERSION } from '../../generated/git-commit.js';\nimport { UserAccountManager } from '../../utils/userAccountManager.js';\nimport { InstallationManager } from '../../utils/installationManager.js';\n\ninterface CustomMatchers<R = unknown> {\n  toHaveMetadataValue: ([key, value]: [EventMetadataKey, string]) => R;\n  toHaveEventName: (name: EventNames) => R;\n}\n\ndeclare module 'vitest' {\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  interface Matchers<T = any> extends CustomMatchers<T> {}\n}\n\nexpect.extend({\n  toHaveEventName(received: LogEventEntry[], name: EventNames) {\n    const { isNot } = this;\n    const event = JSON.parse(received[0].source_extension_json) as LogEvent;\n    const pass = event.event_name === (name as unknown as string);\n    return {\n      pass,\n      message: () =>\n        `event name ${event.event_name} does${isNot ? ' not ' : ''} match ${name}}`,\n    };\n  },\n\n  toHaveMetadataValue(\n    received: LogEventEntry[],\n    [key, value]: [EventMetadataKey, string],\n  ) {\n    const { isNot } = this;\n    const event = JSON.parse(received[0].source_extension_json) as LogEvent;\n    const metadata = event['event_metadata'][0];\n    const data = metadata.find((m) => m.gemini_cli_key === key)?.value;\n\n    const pass = data !== undefined && data === value;\n\n    return {\n      pass,\n      message: () =>\n        `event ${received} does${isNot ? ' not' : ''} have ${value}}`,\n    };\n  },\n});\n\nvi.mock('../../utils/userAccountManager.js');\nvi.mock('../../utils/installationManager.js');\n\nconst mockUserAccount = vi.mocked(UserAccountManager.prototype);\nconst mockInstallMgr = vi.mocked(InstallationManager.prototype);\n\n// TODO(richieforeman): Consider moving this to test setup globally.\nbeforeAll(() => {\n  server.listen({});\n});\n\nafterEach(() => {\n  server.resetHandlers();\n});\n\nafterAll(() => {\n  server.close();\n});\n\ndescribe('ClearcutLogger', () => {\n  const NEXT_WAIT_MS = 1234;\n  const CLEARCUT_URL = 'https://play.googleapis.com/log';\n  const MOCK_DATE = new Date('2025-01-02T00:00:00.000Z');\n  const EXAMPLE_RESPONSE = `[\"${NEXT_WAIT_MS}\",null,[[[\"ANDROID_BACKUP\",0],[\"BATTERY_STATS\",0],[\"SMART_SETUP\",0],[\"TRON\",0]],-3334737594024971225],[]]`;\n\n  // A helper to get the internal events array for testing\n  const getEvents = (l: ClearcutLogger): LogEventEntry[][] =>\n    l['events'].toArray() as LogEventEntry[][];\n\n  const getEventsSize = (l: ClearcutLogger): number => l['events'].size;\n\n  const requeueFailedEvents = (l: ClearcutLogger, events: LogEventEntry[][]) =>\n    l['requeueFailedEvents'](events);\n\n  afterEach(() => {\n    vi.unstubAllEnvs();\n  });\n\n  function setup({\n    config = {} as Partial<ConfigParameters>,\n    lifetimeGoogleAccounts = 1,\n    cachedGoogleAccount = 'test@google.com',\n  } = {}) {\n    server.resetHandlers(\n      http.post(CLEARCUT_URL, () => HttpResponse.text(EXAMPLE_RESPONSE)),\n    );\n\n    vi.useFakeTimers();\n    vi.setSystemTime(MOCK_DATE);\n\n    const loggerConfig = makeFakeConfig({\n      ...config,\n    });\n    ClearcutLogger.clearInstance();\n\n    mockUserAccount.getCachedGoogleAccount.mockReturnValue(cachedGoogleAccount);\n    mockUserAccount.getLifetimeGoogleAccounts.mockReturnValue(\n      lifetimeGoogleAccounts,\n    );\n    mockInstallMgr.getInstallationId = vi\n      .fn()\n      .mockReturnValue('test-installation-id');\n\n    const logger = ClearcutLogger.getInstance(loggerConfig);\n\n    return { logger, loggerConfig };\n  }\n\n  afterEach(() => {\n    ClearcutLogger.clearInstance();\n    vi.useRealTimers();\n    vi.restoreAllMocks();\n  });\n\n  describe('getInstance', () => {\n    it.each([\n      { usageStatisticsEnabled: false, expectedValue: undefined },\n      {\n        usageStatisticsEnabled: true,\n        expectedValue: expect.any(ClearcutLogger),\n      },\n    ])(\n      'returns an instance if usage statistics are enabled',\n      ({ usageStatisticsEnabled, expectedValue }) => {\n        ClearcutLogger.clearInstance();\n        const { logger } = setup({\n          config: {\n            usageStatisticsEnabled,\n          },\n        });\n        expect(logger).toEqual(expectedValue);\n      },\n    );\n\n    it('is a singleton', () => {\n      ClearcutLogger.clearInstance();\n      const { loggerConfig } = setup();\n      const logger1 = ClearcutLogger.getInstance(loggerConfig);\n      const logger2 = ClearcutLogger.getInstance(loggerConfig);\n      expect(logger1).toBe(logger2);\n    });\n  });\n\n  describe('createLogEvent', () => {\n    it('logs the total number of google accounts', () => {\n      const { logger } = setup({\n        lifetimeGoogleAccounts: 9001,\n      });\n\n      const event = logger?.createLogEvent(EventNames.API_ERROR, []);\n\n      expect(event?.event_metadata[0]).toContainEqual({\n        gemini_cli_key: EventMetadataKey.GEMINI_CLI_GOOGLE_ACCOUNTS_COUNT,\n        value: '9001',\n      });\n    });\n\n    it('logs the current surface from a github action', () => {\n      const { logger } = setup({});\n\n      vi.stubEnv('GITHUB_SHA', '8675309');\n\n      const event = logger?.createLogEvent(EventNames.CHAT_COMPRESSION, []);\n\n      expect(event?.event_metadata[0]).toContainEqual({\n        gemini_cli_key: EventMetadataKey.GEMINI_CLI_SURFACE,\n        value: 'GitHub',\n      });\n    });\n\n    it('logs default metadata', () => {\n      // Define expected values\n      const session_id = 'my-session-id';\n      const auth_type = AuthType.USE_GEMINI;\n      const google_accounts = 123;\n      const surface = 'ide-1234';\n      const cli_version = CLI_VERSION;\n      const git_commit_hash = GIT_COMMIT_INFO;\n      const prompt_id = 'my-prompt-123';\n\n      // Setup logger with expected values\n      const { logger, loggerConfig } = setup({\n        lifetimeGoogleAccounts: google_accounts,\n        config: { sessionId: session_id },\n      });\n      vi.spyOn(loggerConfig, 'getContentGeneratorConfig').mockReturnValue({\n        authType: auth_type,\n      } as ContentGeneratorConfig);\n      logger?.logNewPromptEvent(new UserPromptEvent(1, prompt_id)); // prompt_id == session_id before this\n      vi.stubEnv('SURFACE', surface);\n\n      // Create log event\n      const event = logger?.createLogEvent(EventNames.API_ERROR, []);\n\n      // Ensure expected values exist\n      expect(event?.event_metadata[0]).toEqual(\n        expect.arrayContaining([\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_SESSION_ID,\n            value: session_id,\n          },\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_AUTH_TYPE,\n            value: JSON.stringify(auth_type),\n          },\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_GOOGLE_ACCOUNTS_COUNT,\n            value: `${google_accounts}`,\n          },\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_SURFACE,\n            value: surface,\n          },\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_VERSION,\n            value: cli_version,\n          },\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_GIT_COMMIT_HASH,\n            value: git_commit_hash,\n          },\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_PROMPT_ID,\n            value: prompt_id,\n          },\n        ]),\n      );\n    });\n\n    it('logs the current surface', () => {\n      const { logger } = setup({});\n\n      vi.stubEnv('TERM_PROGRAM', 'vscode');\n      vi.stubEnv('SURFACE', 'ide-1234');\n\n      const event = logger?.createLogEvent(EventNames.API_ERROR, []);\n\n      expect(event?.event_metadata[0]).toContainEqual({\n        gemini_cli_key: EventMetadataKey.GEMINI_CLI_SURFACE,\n        value: 'ide-1234',\n      });\n    });\n\n    it.each([\n      {\n        env: {\n          CURSOR_TRACE_ID: 'abc123',\n          GITHUB_SHA: undefined,\n        },\n        expectedValue: 'cursor',\n      },\n      {\n        env: {\n          TERM_PROGRAM: 'vscode',\n          GITHUB_SHA: undefined,\n        },\n        expectedValue: 'vscode',\n      },\n      {\n        env: {\n          MONOSPACE_ENV: 'true',\n          GITHUB_SHA: undefined,\n        },\n        expectedValue: 'firebasestudio',\n      },\n      {\n        env: {\n          __COG_BASHRC_SOURCED: 'true',\n          GITHUB_SHA: undefined,\n        },\n        expectedValue: 'devin',\n      },\n      {\n        env: {\n          CLOUD_SHELL: 'true',\n          GITHUB_SHA: undefined,\n        },\n        expectedValue: 'cloudshell',\n      },\n    ])(\n      'logs the current surface as $expectedValue, preempting vscode detection',\n      ({ env, expectedValue }) => {\n        const { logger } = setup({});\n        for (const [key, value] of Object.entries(env)) {\n          vi.stubEnv(key, value);\n        }\n        vi.stubEnv('TERM_PROGRAM', 'vscode');\n        const event = logger?.createLogEvent(EventNames.API_ERROR, []);\n        expect(event?.event_metadata[0][3]).toEqual({\n          gemini_cli_key: EventMetadataKey.GEMINI_CLI_SURFACE,\n          value: expectedValue,\n        });\n      },\n    );\n  });\n\n  describe('logChatCompressionEvent', () => {\n    it('logs an event with proper fields', () => {\n      const { logger } = setup();\n      logger?.logChatCompressionEvent(\n        makeChatCompressionEvent({\n          tokens_before: 9001,\n          tokens_after: 8000,\n        }),\n      );\n\n      const events = getEvents(logger!);\n      expect(events.length).toBe(1);\n      expect(events[0]).toHaveEventName(EventNames.CHAT_COMPRESSION);\n      expect(events[0]).toHaveMetadataValue([\n        EventMetadataKey.GEMINI_CLI_COMPRESSION_TOKENS_BEFORE,\n        '9001',\n      ]);\n      expect(events[0]).toHaveMetadataValue([\n        EventMetadataKey.GEMINI_CLI_COMPRESSION_TOKENS_AFTER,\n        '8000',\n      ]);\n    });\n  });\n\n  describe('enqueueLogEvent', () => {\n    it('should add events to the queue', () => {\n      const { logger } = setup();\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_ERROR));\n      expect(getEventsSize(logger!)).toBe(1);\n    });\n\n    it('should evict the oldest event when the queue is full', () => {\n      const { logger } = setup();\n\n      for (let i = 0; i < TEST_ONLY.MAX_EVENTS; i++) {\n        logger!.enqueueLogEvent(\n          logger!.createLogEvent(EventNames.API_ERROR, [\n            {\n              gemini_cli_key: EventMetadataKey.GEMINI_CLI_AI_ADDED_LINES,\n              value: `${i}`,\n            },\n          ]),\n        );\n      }\n\n      let events = getEvents(logger!);\n      expect(events.length).toBe(TEST_ONLY.MAX_EVENTS);\n      expect(events[0]).toHaveMetadataValue([\n        EventMetadataKey.GEMINI_CLI_AI_ADDED_LINES,\n        '0',\n      ]);\n\n      // This should push out the first event\n      logger!.enqueueLogEvent(\n        logger!.createLogEvent(EventNames.API_ERROR, [\n          {\n            gemini_cli_key: EventMetadataKey.GEMINI_CLI_AI_ADDED_LINES,\n            value: `${TEST_ONLY.MAX_EVENTS}`,\n          },\n        ]),\n      );\n      events = getEvents(logger!);\n      expect(events.length).toBe(TEST_ONLY.MAX_EVENTS);\n      expect(events[0]).toHaveMetadataValue([\n        EventMetadataKey.GEMINI_CLI_AI_ADDED_LINES,\n        '1',\n      ]);\n\n      expect(events.at(TEST_ONLY.MAX_EVENTS - 1)).toHaveMetadataValue([\n        EventMetadataKey.GEMINI_CLI_AI_ADDED_LINES,\n        `${TEST_ONLY.MAX_EVENTS}`,\n      ]);\n    });\n  });\n\n  describe('flushToClearcut', () => {\n    it('allows for usage with a configured proxy agent', async () => {\n      const { logger } = setup({\n        config: {\n          proxy: 'http://mycoolproxy.whatever.com:3128',\n        },\n      });\n\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_ERROR));\n\n      const response = await logger!.flushToClearcut();\n\n      expect(response.nextRequestWaitMs).toBe(NEXT_WAIT_MS);\n    });\n\n    it('should clear events on successful flush', async () => {\n      const { logger } = setup();\n\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_ERROR));\n      const response = await logger!.flushToClearcut();\n\n      expect(getEvents(logger!)).toEqual([]);\n      expect(response.nextRequestWaitMs).toBe(NEXT_WAIT_MS);\n    });\n\n    it('should handle a network error and requeue events', async () => {\n      const { logger } = setup();\n\n      server.resetHandlers(http.post(CLEARCUT_URL, () => HttpResponse.error()));\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_REQUEST));\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_ERROR));\n      expect(getEventsSize(logger!)).toBe(2);\n\n      const x = logger!.flushToClearcut();\n      await x;\n\n      expect(getEventsSize(logger!)).toBe(2);\n      const events = getEvents(logger!);\n\n      expect(events.length).toBe(2);\n      expect(events[0]).toHaveEventName(EventNames.API_REQUEST);\n    });\n\n    it('should handle an HTTP error and requeue events', async () => {\n      const { logger } = setup();\n\n      server.resetHandlers(\n        http.post(\n          CLEARCUT_URL,\n          () =>\n            new HttpResponse(\n              { 'the system is down': true },\n              {\n                status: 500,\n              },\n            ),\n        ),\n      );\n\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_REQUEST));\n      logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_ERROR));\n\n      expect(getEvents(logger!).length).toBe(2);\n      await logger!.flushToClearcut();\n\n      const events = getEvents(logger!);\n\n      expect(events[0]).toHaveEventName(EventNames.API_REQUEST);\n    });\n  });\n\n  describe('requeueFailedEvents logic', () => {\n    it('should limit the number of requeued events to max_retry_events', () => {\n      const { logger } = setup();\n      const eventsToLogCount = TEST_ONLY.MAX_RETRY_EVENTS + 5;\n      const eventsToSend: LogEventEntry[][] = [];\n      for (let i = 0; i < eventsToLogCount; i++) {\n        eventsToSend.push([\n          {\n            event_time_ms: Date.now(),\n            source_extension_json: JSON.stringify({ event_id: i }),\n          },\n        ]);\n      }\n\n      requeueFailedEvents(logger!, eventsToSend);\n\n      expect(getEventsSize(logger!)).toBe(TEST_ONLY.MAX_RETRY_EVENTS);\n      const firstRequeuedEvent = JSON.parse(\n        getEvents(logger!)[0][0].source_extension_json,\n      ) as { event_id: string };\n      // The last `maxRetryEvents` are kept. The oldest of those is at index `eventsToLogCount - maxRetryEvents`.\n      expect(firstRequeuedEvent.event_id).toBe(\n        eventsToLogCount - TEST_ONLY.MAX_RETRY_EVENTS,\n      );\n    });\n\n    it('should not requeue more events than available space in the queue', () => {\n      const { logger } = setup();\n      const maxEvents = TEST_ONLY.MAX_EVENTS;\n      const spaceToLeave = 5;\n      const initialEventCount = maxEvents - spaceToLeave;\n      for (let i = 0; i < initialEventCount; i++) {\n        logger!.enqueueLogEvent(logger!.createLogEvent(EventNames.API_ERROR));\n      }\n      expect(getEventsSize(logger!)).toBe(initialEventCount);\n\n      const failedEventsCount = 10; // More than spaceToLeave\n      const eventsToSend: LogEventEntry[][] = [];\n      for (let i = 0; i < failedEventsCount; i++) {\n        eventsToSend.push([\n          {\n            event_time_ms: Date.now(),\n            source_extension_json: JSON.stringify({ event_id: `failed_${i}` }),\n          },\n        ]);\n      }\n\n      requeueFailedEvents(logger!, eventsToSend);\n\n      // availableSpace is 5. eventsToRequeue is min(10, 5) = 5.\n      // Total size should be initialEventCount + 5 = maxEvents.\n      expect(getEventsSize(logger!)).toBe(maxEvents);\n\n      // The requeued events are the *last* 5 of the failed events.\n      // startIndex = max(0, 10 - 5) = 5.\n      // Loop unshifts events from index 9 down to 5.\n      // The first element in the deque is the one with id 'failed_5'.\n      const firstRequeuedEvent = JSON.parse(\n        getEvents(logger!)[0][0].source_extension_json,\n      ) as { event_id: string };\n      expect(firstRequeuedEvent.event_id).toBe('failed_5');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/clearcut-logger/event-metadata-key.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/file-exporters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/integration.test.circular.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[981,984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[981,984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":36,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1103,1106],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1103,1106],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1837,1840],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1837,1840],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Integration test to verify circular reference handling with proxy agents\n */\n\nimport { describe, it, expect } from 'vitest';\nimport { ClearcutLogger } from './clearcut-logger/clearcut-logger.js';\nimport { Config } from '../config/config.js';\n\ndescribe('Circular Reference Integration Test', () => {\n  it('should handle HttpsProxyAgent-like circular references in clearcut logging', () => {\n    // Create a mock config with proxy\n    const mockConfig = {\n      getTelemetryEnabled: () => true,\n      getUsageStatisticsEnabled: () => true,\n      getSessionId: () => 'test-session',\n      getModel: () => 'test-model',\n      getEmbeddingModel: () => 'test-embedding',\n      getDebugMode: () => false,\n      getProxy: () => 'http://proxy.example.com:8080',\n    } as unknown as Config;\n\n    // Simulate the structure that causes the circular reference error\n     \n    const proxyAgentLike: any = {\n      sockets: {},\n      options: { proxy: 'http://proxy.example.com:8080' },\n    };\n\n     \n    const socketLike: any = {\n      _httpMessage: {\n        agent: proxyAgentLike,\n        socket: null,\n      },\n    };\n\n    socketLike._httpMessage.socket = socketLike; // Create circular reference\n    proxyAgentLike.sockets['cloudcode-pa.googleapis.com:443'] = [socketLike];\n\n    // Create an event that would contain this circular structure\n    const problematicEvent = {\n      error: new Error('Network error'),\n      function_args: {\n        filePath: '/test/file.txt',\n        httpAgent: proxyAgentLike, // This would cause the circular reference\n      },\n    };\n\n    // Test that ClearcutLogger can handle this\n    const logger = ClearcutLogger.getInstance(mockConfig);\n\n    expect(() => {\n       \n      logger?.enqueueLogEvent(problematicEvent as any);\n    }).not.toThrow();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/loggers.test.circular.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1102,1105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1102,1105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Test to verify circular reference handling in telemetry logging\n */\n\nimport { describe, it, expect } from 'vitest';\nimport { logToolCall } from './loggers.js';\nimport { ToolCallEvent } from './types.js';\nimport { Config } from '../config/config.js';\nimport { CompletedToolCall } from '../core/coreToolScheduler.js';\nimport { ToolCallRequestInfo, ToolCallResponseInfo } from '../core/turn.js';\nimport { MockTool } from '../test-utils/tools.js';\n\ndescribe('Circular Reference Handling', () => {\n  it('should handle circular references in tool function arguments', () => {\n    // Create a mock config\n    const mockConfig = {\n      getTelemetryEnabled: () => true,\n      getUsageStatisticsEnabled: () => true,\n      getSessionId: () => 'test-session',\n      getModel: () => 'test-model',\n      getEmbeddingModel: () => 'test-embedding',\n      getDebugMode: () => false,\n    } as unknown as Config;\n\n    // Create an object with circular references (similar to HttpsProxyAgent)\n     \n    const circularObject: any = {\n      sockets: {},\n      agent: null,\n    };\n    circularObject.agent = circularObject; // Create circular reference\n    circularObject.sockets['test-host'] = [\n      { _httpMessage: { agent: circularObject } },\n    ];\n\n    // Create a mock CompletedToolCall with circular references in function_args\n    const mockRequest: ToolCallRequestInfo = {\n      callId: 'test-call-id',\n      name: 'ReadFile',\n      args: circularObject, // This would cause the original error\n      isClientInitiated: false,\n      prompt_id: 'test-prompt-id',\n    };\n\n    const mockResponse: ToolCallResponseInfo = {\n      callId: 'test-call-id',\n      responseParts: [{ text: 'test result' }],\n      resultDisplay: undefined,\n      error: undefined, // undefined means success\n      errorType: undefined,\n    };\n\n    const tool = new MockTool('mock-tool');\n    const mockCompletedToolCall: CompletedToolCall = {\n      status: 'success',\n      request: mockRequest,\n      response: mockResponse,\n      tool,\n      invocation: tool.build({}),\n      durationMs: 100,\n    };\n\n    // Create a tool call event with circular references in function_args\n    const event = new ToolCallEvent(mockCompletedToolCall);\n\n    // This should not throw an error\n    expect(() => {\n      logToolCall(mockConfig, event);\n    }).not.toThrow();\n  });\n\n  it('should handle normal objects without circular references', () => {\n    const mockConfig = {\n      getTelemetryEnabled: () => true,\n      getUsageStatisticsEnabled: () => true,\n      getSessionId: () => 'test-session',\n      getModel: () => 'test-model',\n      getEmbeddingModel: () => 'test-embedding',\n      getDebugMode: () => false,\n    } as unknown as Config;\n\n    const normalObject = {\n      filePath: '/test/path',\n      options: { encoding: 'utf8' },\n    };\n\n    const mockRequest: ToolCallRequestInfo = {\n      callId: 'test-call-id',\n      name: 'ReadFile',\n      args: normalObject,\n      isClientInitiated: false,\n      prompt_id: 'test-prompt-id',\n    };\n\n    const mockResponse: ToolCallResponseInfo = {\n      callId: 'test-call-id',\n      responseParts: [{ text: 'test result' }],\n      resultDisplay: undefined,\n      error: undefined, // undefined means success\n      errorType: undefined,\n    };\n\n    const tool = new MockTool('mock-tool');\n    const mockCompletedToolCall: CompletedToolCall = {\n      status: 'success',\n      request: mockRequest,\n      response: mockResponse,\n      tool,\n      invocation: tool.build({}),\n      durationMs: 100,\n    };\n\n    const event = new ToolCallEvent(mockCompletedToolCall);\n\n    expect(() => {\n      logToolCall(mockConfig, event);\n    }).not.toThrow();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/loggers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/loggers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/metrics.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/sdk.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/sdk.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/telemetry-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/telemetry-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/telemetry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/tool-call-decision.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4310,4313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4310,4313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GenerateContentResponseUsageMetadata } from '@google/genai';\nimport { Config } from '../config/config.js';\nimport { CompletedToolCall } from '../core/coreToolScheduler.js';\nimport { DiscoveredMCPTool } from '../tools/mcp-tool.js';\nimport { DiffStat, FileDiff } from '../tools/tools.js';\nimport { AuthType } from '../core/contentGenerator.js';\nimport {\n  getDecisionFromOutcome,\n  ToolCallDecision,\n} from './tool-call-decision.js';\nimport { FileOperation } from './metrics.js';\nexport { ToolCallDecision };\nimport { ToolRegistry } from '../tools/tool-registry.js';\n\nexport interface BaseTelemetryEvent {\n  'event.name': string;\n  /** Current timestamp in ISO 8601 format */\n  'event.timestamp': string;\n}\n\ntype CommonFields = keyof BaseTelemetryEvent;\n\nexport class StartSessionEvent implements BaseTelemetryEvent {\n  'event.name': 'cli_config';\n  'event.timestamp': string;\n  model: string;\n  embedding_model: string;\n  sandbox_enabled: boolean;\n  core_tools_enabled: string;\n  approval_mode: string;\n  api_key_enabled: boolean;\n  vertex_ai_enabled: boolean;\n  debug_enabled: boolean;\n  mcp_servers: string;\n  telemetry_enabled: boolean;\n  telemetry_log_user_prompts_enabled: boolean;\n  file_filtering_respect_git_ignore: boolean;\n  mcp_servers_count: number;\n  mcp_tools_count?: number;\n  mcp_tools?: string;\n\n  constructor(config: Config, toolRegistry?: ToolRegistry) {\n    const generatorConfig = config.getContentGeneratorConfig();\n    const mcpServers = config.getMcpServers();\n\n    let useGemini = false;\n    let useVertex = false;\n    if (generatorConfig && generatorConfig.authType) {\n      useGemini = generatorConfig.authType === AuthType.USE_GEMINI;\n      useVertex = generatorConfig.authType === AuthType.USE_VERTEX_AI;\n    }\n\n    this['event.name'] = 'cli_config';\n    this.model = config.getModel();\n    this.embedding_model = config.getEmbeddingModel();\n    this.sandbox_enabled =\n      typeof config.getSandbox() === 'string' || !!config.getSandbox();\n    this.core_tools_enabled = (config.getCoreTools() ?? []).join(',');\n    this.approval_mode = config.getApprovalMode();\n    this.api_key_enabled = useGemini || useVertex;\n    this.vertex_ai_enabled = useVertex;\n    this.debug_enabled = config.getDebugMode();\n    this.mcp_servers = mcpServers ? Object.keys(mcpServers).join(',') : '';\n    this.telemetry_enabled = config.getTelemetryEnabled();\n    this.telemetry_log_user_prompts_enabled =\n      config.getTelemetryLogPromptsEnabled();\n    this.file_filtering_respect_git_ignore =\n      config.getFileFilteringRespectGitIgnore();\n    this.mcp_servers_count = mcpServers ? Object.keys(mcpServers).length : 0;\n    if (toolRegistry) {\n      const mcpTools = toolRegistry\n        .getAllTools()\n        .filter((tool) => tool instanceof DiscoveredMCPTool);\n      this.mcp_tools_count = mcpTools.length;\n      this.mcp_tools = mcpTools\n        .map((tool) => (tool as DiscoveredMCPTool).name)\n        .join(',');\n    }\n  }\n}\n\nexport class EndSessionEvent implements BaseTelemetryEvent {\n  'event.name': 'end_session';\n  'event.timestamp': string;\n  session_id?: string;\n\n  constructor(config?: Config) {\n    this['event.name'] = 'end_session';\n    this['event.timestamp'] = new Date().toISOString();\n    this.session_id = config?.getSessionId();\n  }\n}\n\nexport class UserPromptEvent implements BaseTelemetryEvent {\n  'event.name': 'user_prompt';\n  'event.timestamp': string;\n  prompt_length: number;\n  prompt_id: string;\n  auth_type?: string;\n  prompt?: string;\n\n  constructor(\n    prompt_length: number,\n    prompt_Id: string,\n    auth_type?: string,\n    prompt?: string,\n  ) {\n    this['event.name'] = 'user_prompt';\n    this['event.timestamp'] = new Date().toISOString();\n    this.prompt_length = prompt_length;\n    this.prompt_id = prompt_Id;\n    this.auth_type = auth_type;\n    this.prompt = prompt;\n  }\n}\n\nexport class ToolCallEvent implements BaseTelemetryEvent {\n  'event.name': 'tool_call';\n  'event.timestamp': string;\n  function_name: string;\n  function_args: Record<string, unknown>;\n  duration_ms: number;\n  success: boolean;\n  decision?: ToolCallDecision;\n  error?: string;\n  error_type?: string;\n  prompt_id: string;\n  tool_type: 'native' | 'mcp';\n   \n  metadata?: { [key: string]: any };\n\n  constructor(call: CompletedToolCall) {\n    this['event.name'] = 'tool_call';\n    this['event.timestamp'] = new Date().toISOString();\n    this.function_name = call.request.name;\n    this.function_args = call.request.args;\n    this.duration_ms = call.durationMs ?? 0;\n    this.success = call.status === 'success';\n    this.decision = call.outcome\n      ? getDecisionFromOutcome(call.outcome)\n      : undefined;\n    this.error = call.response.error?.message;\n    this.error_type = call.response.errorType;\n    this.prompt_id = call.request.prompt_id;\n    this.tool_type =\n      typeof call.tool !== 'undefined' && call.tool instanceof DiscoveredMCPTool\n        ? 'mcp'\n        : 'native';\n\n    if (\n      call.status === 'success' &&\n      typeof call.response.resultDisplay === 'object' &&\n      call.response.resultDisplay !== null &&\n      'diffStat' in call.response.resultDisplay\n    ) {\n      const diffStat = (call.response.resultDisplay as FileDiff).diffStat;\n      if (diffStat) {\n        this.metadata = {\n          ai_added_lines: diffStat.ai_added_lines,\n          ai_removed_lines: diffStat.ai_removed_lines,\n          user_added_lines: diffStat.user_added_lines,\n          user_removed_lines: diffStat.user_removed_lines,\n        };\n      }\n    }\n  }\n}\n\nexport class ApiRequestEvent implements BaseTelemetryEvent {\n  'event.name': 'api_request';\n  'event.timestamp': string;\n  model: string;\n  prompt_id: string;\n  request_text?: string;\n\n  constructor(model: string, prompt_id: string, request_text?: string) {\n    this['event.name'] = 'api_request';\n    this['event.timestamp'] = new Date().toISOString();\n    this.model = model;\n    this.prompt_id = prompt_id;\n    this.request_text = request_text;\n  }\n}\n\nexport class ApiErrorEvent implements BaseTelemetryEvent {\n  'event.name': 'api_error';\n  'event.timestamp': string;\n  model: string;\n  error: string;\n  error_type?: string;\n  status_code?: number | string;\n  duration_ms: number;\n  prompt_id: string;\n  auth_type?: string;\n\n  constructor(\n    model: string,\n    error: string,\n    duration_ms: number,\n    prompt_id: string,\n    auth_type?: string,\n    error_type?: string,\n    status_code?: number | string,\n  ) {\n    this['event.name'] = 'api_error';\n    this['event.timestamp'] = new Date().toISOString();\n    this.model = model;\n    this.error = error;\n    this.error_type = error_type;\n    this.status_code = status_code;\n    this.duration_ms = duration_ms;\n    this.prompt_id = prompt_id;\n    this.auth_type = auth_type;\n  }\n}\n\nexport class ApiResponseEvent implements BaseTelemetryEvent {\n  'event.name': 'api_response';\n  'event.timestamp': string;\n  model: string;\n  status_code?: number | string;\n  duration_ms: number;\n  error?: string;\n  input_token_count: number;\n  output_token_count: number;\n  cached_content_token_count: number;\n  thoughts_token_count: number;\n  tool_token_count: number;\n  total_token_count: number;\n  response_text?: string;\n  prompt_id: string;\n  auth_type?: string;\n\n  constructor(\n    model: string,\n    duration_ms: number,\n    prompt_id: string,\n    auth_type?: string,\n    usage_data?: GenerateContentResponseUsageMetadata,\n    response_text?: string,\n    error?: string,\n  ) {\n    this['event.name'] = 'api_response';\n    this['event.timestamp'] = new Date().toISOString();\n    this.model = model;\n    this.duration_ms = duration_ms;\n    this.status_code = 200;\n    this.input_token_count = usage_data?.promptTokenCount ?? 0;\n    this.output_token_count = usage_data?.candidatesTokenCount ?? 0;\n    this.cached_content_token_count = usage_data?.cachedContentTokenCount ?? 0;\n    this.thoughts_token_count = usage_data?.thoughtsTokenCount ?? 0;\n    this.tool_token_count = usage_data?.toolUsePromptTokenCount ?? 0;\n    this.total_token_count = usage_data?.totalTokenCount ?? 0;\n    this.response_text = response_text;\n    this.error = error;\n    this.prompt_id = prompt_id;\n    this.auth_type = auth_type;\n  }\n}\n\nexport class FlashFallbackEvent implements BaseTelemetryEvent {\n  'event.name': 'flash_fallback';\n  'event.timestamp': string;\n  auth_type: string;\n\n  constructor(auth_type: string) {\n    this['event.name'] = 'flash_fallback';\n    this['event.timestamp'] = new Date().toISOString();\n    this.auth_type = auth_type;\n  }\n}\n\nexport enum LoopType {\n  CONSECUTIVE_IDENTICAL_TOOL_CALLS = 'consecutive_identical_tool_calls',\n  CHANTING_IDENTICAL_SENTENCES = 'chanting_identical_sentences',\n  LLM_DETECTED_LOOP = 'llm_detected_loop',\n  ALTERNATING_TOOL_PATTERN = 'alternating_tool_pattern',\n  NON_CONSECUTIVE_TOOL_PATTERN = 'non_consecutive_tool_pattern',\n  FILE_STATE_LOOP = 'file_state_loop',\n  SEMANTIC_CONTENT_LOOP = 'semantic_content_loop',\n  CONSECUTIVE_FAILED_TOOL_CALLS = 'consecutive_failed_tool_calls',\n}\n\n/**\n * Enhanced loop detection event with additional metadata\n */\nexport class LoopDetectedEvent {\n  constructor(\n    readonly loopType: LoopType,\n    readonly promptId: string,\n    readonly confidence?: number,\n    readonly affectedFiles?: string[],\n    readonly toolsInvolved?: string[],\n    readonly reasoning?: string,\n  ) {}\n}\n\n/**\n * File system state for tracking modification patterns\n */\nexport interface FileSystemState {\n  filePath: string;\n  contentHash: string;\n  timestamp: number;\n  operation: string;\n  size?: number;\n}\n\nexport class NextSpeakerCheckEvent implements BaseTelemetryEvent {\n  'event.name': 'next_speaker_check';\n  'event.timestamp': string;\n  prompt_id: string;\n  finish_reason: string;\n  result: string;\n\n  constructor(prompt_id: string, finish_reason: string, result: string) {\n    this['event.name'] = 'next_speaker_check';\n    this['event.timestamp'] = new Date().toISOString();\n    this.prompt_id = prompt_id;\n    this.finish_reason = finish_reason;\n    this.result = result;\n  }\n}\n\nexport interface SlashCommandEvent extends BaseTelemetryEvent {\n  'event.name': 'slash_command';\n  'event.timestamp': string;\n  command: string;\n  subcommand?: string;\n  status?: SlashCommandStatus;\n}\n\nexport function makeSlashCommandEvent({\n  command,\n  subcommand,\n  status,\n}: Omit<SlashCommandEvent, CommonFields>): SlashCommandEvent {\n  return {\n    'event.name': 'slash_command',\n    'event.timestamp': new Date().toISOString(),\n    command,\n    subcommand,\n    status,\n  };\n}\n\nexport enum SlashCommandStatus {\n  SUCCESS = 'success',\n  ERROR = 'error',\n}\n\nexport interface ChatCompressionEvent extends BaseTelemetryEvent {\n  'event.name': 'chat_compression';\n  'event.timestamp': string;\n  tokens_before: number;\n  tokens_after: number;\n}\n\nexport function makeChatCompressionEvent({\n  tokens_before,\n  tokens_after,\n}: Omit<ChatCompressionEvent, CommonFields>): ChatCompressionEvent {\n  return {\n    'event.name': 'chat_compression',\n    'event.timestamp': new Date().toISOString(),\n    tokens_before,\n    tokens_after,\n  };\n}\n\nexport class MalformedJsonResponseEvent implements BaseTelemetryEvent {\n  'event.name': 'malformed_json_response';\n  'event.timestamp': string;\n  model: string;\n\n  constructor(model: string) {\n    this['event.name'] = 'malformed_json_response';\n    this['event.timestamp'] = new Date().toISOString();\n    this.model = model;\n  }\n}\n\nexport enum IdeConnectionType {\n  START = 'start',\n  SESSION = 'session',\n}\n\nexport class IdeConnectionEvent {\n  'event.name': 'ide_connection';\n  'event.timestamp': string;\n  connection_type: IdeConnectionType;\n\n  constructor(connection_type: IdeConnectionType) {\n    this['event.name'] = 'ide_connection';\n    this['event.timestamp'] = new Date().toISOString();\n    this.connection_type = connection_type;\n  }\n}\n\nexport class KittySequenceOverflowEvent {\n  'event.name': 'kitty_sequence_overflow';\n  'event.timestamp': string; // ISO 8601\n  sequence_length: number;\n  truncated_sequence: string;\n  constructor(sequence_length: number, truncated_sequence: string) {\n    this['event.name'] = 'kitty_sequence_overflow';\n    this['event.timestamp'] = new Date().toISOString();\n    this.sequence_length = sequence_length;\n    // Truncate to first 20 chars for logging (avoid logging sensitive data)\n    this.truncated_sequence = truncated_sequence.substring(0, 20);\n  }\n}\n\nexport class FileOperationEvent implements BaseTelemetryEvent {\n  'event.name': 'file_operation';\n  'event.timestamp': string;\n  tool_name: string;\n  operation: FileOperation;\n  lines?: number;\n  mimetype?: string;\n  extension?: string;\n  diff_stat?: DiffStat;\n  programming_language?: string;\n\n  constructor(\n    tool_name: string,\n    operation: FileOperation,\n    lines?: number,\n    mimetype?: string,\n    extension?: string,\n    diff_stat?: DiffStat,\n    programming_language?: string,\n  ) {\n    this['event.name'] = 'file_operation';\n    this['event.timestamp'] = new Date().toISOString();\n    this.tool_name = tool_name;\n    this.operation = operation;\n    this.lines = lines;\n    this.mimetype = mimetype;\n    this.extension = extension;\n    this.diff_stat = diff_stat;\n    this.programming_language = programming_language;\n  }\n}\n\nexport type TelemetryEvent =\n  | StartSessionEvent\n  | EndSessionEvent\n  | UserPromptEvent\n  | ToolCallEvent\n  | ApiRequestEvent\n  | ApiErrorEvent\n  | ApiResponseEvent\n  | FlashFallbackEvent\n  | LoopDetectedEvent\n  | NextSpeakerCheckEvent\n  | KittySequenceOverflowEvent\n  | MalformedJsonResponseEvent\n  | IdeConnectionEvent\n  | SlashCommandEvent\n  | FileOperationEvent;\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/uiTelemetry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/telemetry/uiTelemetry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/test-utils/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/test-utils/mockWorkspaceContext.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/test-utils/tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/__tests__/replace-occurrence.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/ast.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[458,461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[458,461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[846,849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[846,849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[899,902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[899,902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[937,940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[937,940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { describe, it, expect, vi } from 'vitest';\nimport { ASTReadTool } from './ast.js';\n\n// Mock the parser used by the tool to avoid heavy ts-morph dependency in tests\nvi.mock('../ast/parser.js', () => ({\n    parseSourceToSourceFile: (_filePath: string, text: string) => ({ sourceFile: { getText: () => text } }),\n    extractIntentionsFromSourceFile: (_sourceFile: any) => ({ intentions: ['fn1', 'fn2'] }),\n  }));\n\ndescribe('ASTReadTool (unit)', () => {\n  it('returns extracted intentions from parser', async () => {\n    const mockConfig = {\n      getFileSystemService: () => ({\n        readTextFile: async (_filePath: string) => ({ success: true, data: 'function foo() {}' }),\n        writeTextFile: async () => ({ success: true }),\n      }),\n    } as any;\n\n    const tool = new ASTReadTool(mockConfig as any);\n    const invocation = (tool as any).createInvocation({ file_path: '/tmp/foo.ts' });\n    const res = await invocation.execute();\n\n    expect(res.llmContent).toBeDefined();\n    expect(res.llmContent).toContain('intentions');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/ast.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5333,5336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5333,5336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":287,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":287,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7961,7964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7961,7964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":288,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8020,8023],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8020,8023],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":309,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8730,8733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8730,8733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":332,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":332,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9524,9527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9524,9527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  BaseDeclarativeTool,\n  BaseToolInvocation,\n  Kind,\n  ToolInvocation,\n  ToolResult,\n} from './tools.js';\nimport { Config } from '../config/config.js';\nimport {\n  parseSourceToSourceFile,\n  extractIntentionsFromSourceFile,\n} from '../ast/parser.js';\nimport {\n  ASTQuery,\n  DictionaryQuery,\n  ASTQuery as _ASTQuery,\n} from '../ast/models.js';\n\n// Modifier imports\nimport { ASTModifier } from '../ast/modifier.js';\nimport { ModificationSpec, ModificationOperation } from '../ast/models.js';\nimport { findNodes } from '../ast/finder.js';\nimport { Node } from 'ts-morph';\n\n/**\n * Very small, dependency-free line-oriented unified-ish diff generator.\n * Not perfect, but returns a readable diff for preview mode without adding deps.\n */\nfunction generateSimpleLineDiff(\n  oldText: string,\n  newText: string,\n  filePath: string,\n) {\n  const oldLines = oldText.split(/\\r\\n|\\r|\\n/);\n  const newLines = newText.split(/\\r\\n|\\r|\\n/);\n  const max = Math.max(oldLines.length, newLines.length);\n  const out: string[] = [];\n  out.push(`--- ${filePath}`);\n  out.push(`+++ ${filePath} (modified)`);\n  out.push('');\n  for (let i = 0; i < max; i++) {\n    const o = oldLines[i];\n    const n = newLines[i];\n    if (o === n) {\n      // show a small context window only for readability\n      if (i === 0 || i % 200 === 0) {\n        out.push(' ' + (o ?? ''));\n      }\n    } else {\n      if (o !== undefined) out.push('-' + o);\n      if (n !== undefined) out.push('+' + n);\n    }\n  }\n  return out.join('\\n');\n}\n\n//=================================================================================================\n// AST Read Tool\n//=================================================================================================\n\nexport interface ASTReadToolParams {\n  file_path: string;\n}\n\nclass ASTReadToolInvocation extends BaseToolInvocation<\n  ASTReadToolParams,\n  ToolResult\n> {\n  constructor(\n    private readonly config: Config,\n    private readonly toolParams: ASTReadToolParams,\n  ) {\n    super(toolParams);\n  }\n\n  getDescription(): string {\n    return `Reading AST and intentions from ${this.toolParams.file_path}`;\n  }\n\n  async execute(): Promise<ToolResult> {\n    const { file_path } = this.toolParams;\n    const fs = this.config.getFileSystemService();\n\n    const readResult = await fs.readTextFile(file_path);\n    if (!readResult.success) {\n      return {\n        llmContent: `Error: Could not read file: ${readResult.error}`,\n        returnDisplay: `Error: Could not read file: ${readResult.error}`,\n      };\n    }\n\n    const sourceFile = parseSourceToSourceFile(\n      file_path,\n      readResult.data!,\n    )?.sourceFile;\n    if (!sourceFile) {\n      return {\n        llmContent: `Error: Could not parse file: ${file_path}`,\n        returnDisplay: `Error: Could not parse file: ${file_path}`,\n      };\n    }\n    const intentionMap = extractIntentionsFromSourceFile(sourceFile);\n\n    return {\n      llmContent: JSON.stringify(intentionMap, null, 2),\n      returnDisplay: JSON.stringify(intentionMap, null, 2),\n    };\n  }\n}\n\nexport class ASTReadTool extends BaseDeclarativeTool<\n  ASTReadToolParams,\n  ToolResult\n> {\n  static readonly Name = 'ast_read';\n\n  constructor(private readonly config: Config) {\n    super(\n      ASTReadTool.Name,\n      'ASTRead',\n      'Reads a TypeScript/JavaScript file and returns a structured map of its intentions (functions, classes, imports, etc.).',\n      Kind.Read,\n      {\n        properties: {\n          file_path: {\n            description: 'The absolute path to the file to analyze.',\n            type: 'string',\n          },\n        },\n        required: ['file_path'],\n        type: 'object',\n      },\n    );\n  }\n\n  protected createInvocation(\n    params: ASTReadToolParams,\n  ): ToolInvocation<ASTReadToolParams, ToolResult> {\n    return new ASTReadToolInvocation(this.config, params);\n  }\n}\n\n//=================================================================================================\n// AST Find Tool\n//=================================================================================================\n\nexport interface ASTFindToolParams {\n  file_path: string;\n  query: ASTQuery | DictionaryQuery | string;\n}\n\nclass ASTFindToolInvocation extends BaseToolInvocation<\n  ASTFindToolParams,\n  ToolResult\n> {\n  constructor(\n    private readonly config: Config,\n    private readonly toolParams: ASTFindToolParams,\n  ) {\n    super(toolParams);\n  }\n\n  getDescription(): string {\n    return `Finding AST nodes in ${this.toolParams.file_path}`;\n  }\n\n  async execute(): Promise<ToolResult> {\n    const { file_path, query } = this.toolParams;\n    const fs = this.config.getFileSystemService();\n\n    const readResult = await fs.readTextFile(file_path);\n    if (!readResult.success) {\n      return {\n        llmContent: `Error: Could not read file: ${readResult.error}`,\n        returnDisplay: `Error: Could not read file: ${readResult.error}`,\n      };\n    }\n\n    const sourceFile = parseSourceToSourceFile(\n      file_path,\n      readResult.data!,\n    )?.sourceFile;\n    if (!sourceFile) {\n      return {\n        llmContent: `Error: Could not parse file: ${file_path}`,\n        returnDisplay: `Error: Could not parse file: ${file_path}`,\n      };\n    }\n    const foundNodes = findNodes(sourceFile, query as any);\n\n    if (foundNodes.length === 0) {\n      return {\n        llmContent: 'No nodes found matching the query.',\n        returnDisplay: 'No nodes found matching the query.',\n      };\n    }\n\n    const results = foundNodes.map((node: Node) => ({\n        kind: node.getKindName(),\n        text:\n          node.getText().substring(0, 100) +\n          (node.getText().length > 100 ? '...' : ''),\n        startLine: node.getStartLineNumber(),\n        endLine: node.getEndLineNumber(),\n      }));\n\n    return {\n      llmContent: JSON.stringify(results, null, 2),\n      returnDisplay: JSON.stringify(results, null, 2),\n    };\n  }\n}\n\nexport class ASTFindTool extends BaseDeclarativeTool<\n  ASTFindToolParams,\n  ToolResult\n> {\n  static readonly Name = 'ast_find';\n\n  constructor(private readonly config: Config) {\n    super(\n      ASTFindTool.Name,\n      'ASTFind',\n      'Finds and returns information about nodes in a TypeScript/JavaScript file that match a given query.',\n      Kind.Read,\n      {\n        properties: {\n          file_path: {\n            description: 'The absolute path to the file to search.',\n            type: 'string',\n          },\n          query: {\n            description:\n              'A query to find nodes based on their properties. Accepts dictionary query, ComplexQuery, or XPath-like string.',\n            type: 'object',\n          },\n        },\n        required: ['file_path', 'query'],\n        type: 'object',\n      },\n    );\n  }\n\n  protected createInvocation(\n    params: ASTFindToolParams,\n  ): ToolInvocation<ASTFindToolParams, ToolResult> {\n    return new ASTFindToolInvocation(this.config, params);\n  }\n}\n\n//=================================================================================================\n// AST Edit Tool\n//=================================================================================================\n\nexport interface ASTEditToolParams {\n  file_path: string;\n  query: ASTQuery | DictionaryQuery | string;\n  new_text: string;\n  // Optional flags:\n  preview?: boolean; // if true, do not write file, return modified content\n  create_backup?: boolean; // if false, skip creating backup (default true)\n}\n\nclass ASTEditToolInvocation extends BaseToolInvocation<\n  ASTEditToolParams,\n  ToolResult\n> {\n  constructor(\n    private readonly config: Config,\n    private readonly toolParams: ASTEditToolParams,\n  ) {\n    super(toolParams);\n  }\n\n  getDescription(): string {\n    return `Editing AST node in ${this.toolParams.file_path}`;\n  }\n\n  async execute(): Promise<ToolResult> {\n    const { file_path, query, new_text } = this.toolParams;\n    const preview = !!(this.toolParams as any).preview;\n    const createBackup = (this.toolParams as any).create_backup !== false; // default true\n    const fs = this.config.getFileSystemService();\n\n    const readResult = await fs.readTextFile(file_path);\n    if (!readResult.success) {\n      return {\n        llmContent: `Error: Could not read file: ${readResult.error}`,\n        returnDisplay: `Error: Could not read file: ${readResult.error}`,\n      };\n    }\n\n    const sourceFile = parseSourceToSourceFile(\n      file_path,\n      readResult.data!,\n    )?.sourceFile;\n    if (!sourceFile) {\n      return {\n        llmContent: `Error: Could not parse file: ${file_path}`,\n        returnDisplay: `Error: Could not parse file: ${file_path}`,\n      };\n    }\n    const foundNodes = findNodes(sourceFile, query as any);\n\n    if (foundNodes.length === 0) {\n      return {\n        llmContent:\n          'Error: No nodes found matching the query. No changes made.',\n        returnDisplay:\n          'Error: No nodes found matching the query. No changes made.',\n      };\n    }\n\n    if (foundNodes.length > 1) {\n      return {\n        llmContent: `Error: Query is not specific enough. Found ${foundNodes.length} nodes. No changes made.`,\n        returnDisplay: `Error: Query is not specific enough. Found ${foundNodes.length} nodes. No changes made.`,\n      };\n    }\n\n    // Use ASTModifier to perform the replacement in a robust, consistent way\n    const modifier = new ASTModifier();\n    const mods: ModificationSpec[] = [\n      {\n        operation: ModificationOperation.REPLACE,\n        targetQuery: query as any,\n        newCode: new_text,\n      },\n    ];\n\n    // Ask modifier to format; it will always create an internal backup id.\n    const modResult = await modifier.applyModifications(\n      readResult.data!,\n      mods,\n      { filePath: file_path, format: true },\n    );\n\n    if (!modResult.success) {\n      return {\n        llmContent: `Error applying modification: ${modResult.error ?? 'unknown error'}`,\n        returnDisplay: `Error applying modification: ${modResult.error ?? 'unknown error'}`,\n      };\n    }\n\n    const newContent = modResult.modifiedText ?? readResult.data!;\n\n    if (preview) {\n      // Return a compact diff instead of the full modified file\n      const diff = generateSimpleLineDiff(\n        readResult.data!,\n        newContent,\n        file_path,\n      );\n      return {\n        llmContent: `Preview diff (no file written). Backup id: ${modResult.backupId ?? 'n/a'}\\n\\n${diff}`,\n        returnDisplay: `Preview diff (no file written). Backup id: ${modResult.backupId ?? 'n/a'}\\n\\n${diff}`,\n      };\n    }\n\n    // If createBackup is false, we still used modifier backup; user opted out of persistent backup on write.\n    const writeResult = await fs.writeTextFile(file_path, newContent);\n    if (!writeResult.success) {\n      return {\n        llmContent: `Error writing file: ${writeResult.error}`,\n        returnDisplay: `Error writing file: ${writeResult.error}`,\n      };\n    }\n\n    return {\n      llmContent: `Successfully edited node in ${file_path} (backup: ${createBackup ? (modResult.backupId ?? 'n/a') : 'skipped'})`,\n      returnDisplay: `Successfully edited node in ${file_path} (backup: ${createBackup ? (modResult.backupId ?? 'n/a') : 'skipped'})`,\n    };\n  }\n}\n\nexport class ASTEditTool extends BaseDeclarativeTool<\n  ASTEditToolParams,\n  ToolResult\n> {\n  static readonly Name = 'ast_edit';\n\n  constructor(private readonly config: Config) {\n    super(\n      ASTEditTool.Name,\n      'ASTEdit',\n      'Finds a single AST node using a query and replaces it with new text.',\n      Kind.Edit,\n      {\n        properties: {\n          file_path: {\n            description: 'The absolute path to the file to edit.',\n            type: 'string',\n          },\n          query: {\n            description:\n              'The query to locate the single node to edit (DictionaryQuery, ComplexQuery, or XPath-like string).',\n            type: 'object',\n          },\n          new_text: {\n            description: 'The new text to replace the found node with.',\n            type: 'string',\n          },\n          preview: {\n            description:\n              'If true, return the modified content without writing the file.',\n            type: 'boolean',\n          },\n          create_backup: {\n            description:\n              'If false, skip creating a persistent backup when writing the file (default true).',\n            type: 'boolean',\n          },\n        },\n        required: ['file_path', 'query', 'new_text'],\n        type: 'object',\n      },\n    );\n  }\n\n  protected createInvocation(\n    params: ASTEditToolParams,\n  ): ToolInvocation<ASTEditToolParams, ToolResult> {\n    return new ASTEditToolInvocation(this.config, params);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/diffOptions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/diffOptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/edit.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1491,1494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1491,1494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3064,3067],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3064,3067],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":126,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4589,4592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4589,4592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4649,4652],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4649,4652],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4942,4945],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4942,4945],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":136,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4961,4964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4961,4964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5136,5139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5136,5139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5155,5158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5155,5158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":846,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":846,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[31823,31826],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[31823,31826],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":856,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":856,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32092,32095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32092,32095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":857,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":857,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32143,32146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32143,32146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \n\nconst mockEnsureCorrectEdit = vi.hoisted(() => vi.fn());\nconst mockGenerateJson = vi.hoisted(() => vi.fn());\nconst mockOpenDiff = vi.hoisted(() => vi.fn());\n\nimport { IDEConnectionStatus } from '../ide/ide-client.js';\n\nvi.mock('../utils/editCorrector.js', () => ({\n  ensureCorrectEdit: mockEnsureCorrectEdit,\n  resetEditCorrectorCaches: vi.fn(),\n}));\n\nvi.mock('../core/client.js', () => ({\n  GeminiClient: vi.fn().mockImplementation(() => ({\n    generateJson: mockGenerateJson,\n  })),\n}));\n\nvi.mock('../utils/editor.js', () => ({\n  openDiff: mockOpenDiff,\n}));\n\nvi.mock('../telemetry/loggers.js', () => ({\n  logFileOperation: vi.fn(),\n}));\n\nimport { describe, it, expect, beforeEach, afterEach, vi, Mock } from 'vitest';\nimport { applyReplacement, EditTool, EditToolParams } from './edit.js';\nimport { FileDiff, ToolConfirmationOutcome } from './tools.js';\nimport { ToolErrorType } from './tool-error.js';\nimport path from 'path';\nimport fs from 'fs';\nimport os from 'os';\nimport { ApprovalMode, Config } from '../config/config.js';\nimport { Content, Part, SchemaUnion } from '@google/genai';\nimport { createMockWorkspaceContext } from '../test-utils/mockWorkspaceContext.js';\nimport { StandardFileSystemService } from '../services/fileSystemService.js';\n\ndescribe('EditTool', () => {\n  let tool: EditTool;\n  let tempDir: string;\n  let rootDir: string;\n  let mockConfig: Config;\n  let geminiClient: any;\n\n  beforeEach(() => {\n    vi.restoreAllMocks();\n    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'edit-tool-test-'));\n    rootDir = path.join(tempDir, 'root');\n    fs.mkdirSync(rootDir);\n\n    geminiClient = {\n      generateJson: mockGenerateJson, // mockGenerateJson is already defined and hoisted\n    };\n\n    mockConfig = {\n      getGeminiClient: vi.fn().mockReturnValue(geminiClient),\n      getTargetDir: () => rootDir,\n      getApprovalMode: vi.fn(),\n      setApprovalMode: vi.fn(),\n      getWorkspaceContext: () => createMockWorkspaceContext(rootDir),\n      getFileSystemService: () => new StandardFileSystemService(),\n      getIdeClient: () => undefined,\n      getIdeMode: () => false,\n      // getGeminiConfig: () => ({ apiKey: 'test-api-key' }), // This was not a real Config method\n      // Add other properties/methods of Config if EditTool uses them\n      // Minimal other methods to satisfy Config type if needed by EditTool constructor or other direct uses:\n      getApiKey: () => 'test-api-key',\n      getModel: () => 'test-model',\n      getSandbox: () => false,\n      getDebugMode: () => false,\n      getQuestion: () => undefined,\n      getFullContext: () => false,\n      getToolDiscoveryCommand: () => undefined,\n      getToolCallCommand: () => undefined,\n      getMcpServerCommand: () => undefined,\n      getMcpServers: () => undefined,\n      getUserAgent: () => 'test-agent',\n      getUserMemory: () => '',\n      setUserMemory: vi.fn(),\n      getGeminiMdFileCount: () => 0,\n      setGeminiMdFileCount: vi.fn(),\n      getToolRegistry: () => ({}) as any, // Minimal mock for ToolRegistry\n    } as unknown as Config;\n\n    // Reset mocks before each test\n    (mockConfig.getApprovalMode as Mock).mockClear();\n    // Default to not skipping confirmation\n    (mockConfig.getApprovalMode as Mock).mockReturnValue(ApprovalMode.DEFAULT);\n\n    // Reset mocks and set default implementation for ensureCorrectEdit\n    mockEnsureCorrectEdit.mockReset();\n    mockEnsureCorrectEdit.mockImplementation(\n      async (_, currentContent, params) => {\n        let occurrences = 0;\n        if (params.old_string && currentContent) {\n          // Simple string counting for the mock\n          let index = currentContent.indexOf(params.old_string);\n          while (index !== -1) {\n            occurrences++;\n            index = currentContent.indexOf(params.old_string, index + 1);\n          }\n        } else if (params.old_string === '') {\n          occurrences = 0; // Creating a new file\n        }\n        return Promise.resolve({ params, occurrences });\n      },\n    );\n\n    // Default mock for generateJson to return the snippet unchanged\n    mockGenerateJson.mockReset();\n    mockGenerateJson.mockImplementation(\n      async (contents: Content[], schema: SchemaUnion) => {\n        // The problematic_snippet is the last part of the user's content\n        const userContent = contents.find((c: Content) => c.role === 'user');\n        let promptText = '';\n        if (userContent && userContent.parts) {\n          promptText = userContent.parts\n            .filter((p: Part) => typeof (p as any).text === 'string')\n            .map((p: Part) => (p as any).text)\n            .join('\\n');\n        }\n        const snippetMatch = promptText.match(\n          /Problematic target snippet:\\n```\\n([\\s\\S]*?)\\n```/,\n        );\n        const problematicSnippet =\n          snippetMatch && snippetMatch[1] ? snippetMatch[1] : '';\n\n        if (((schema as any).properties as any)?.corrected_target_snippet) {\n          return Promise.resolve({\n            corrected_target_snippet: problematicSnippet,\n          });\n        }\n        if (((schema as any).properties as any)?.corrected_new_string) {\n          // For new_string correction, we might need more sophisticated logic,\n          // but for now, returning original is a safe default if not specified by a test.\n          const originalNewStringMatch = promptText.match(\n            /original_new_string \\(what was intended to replace original_old_string\\):\\n```\\n([\\s\\S]*?)\\n```/,\n          );\n          const originalNewString =\n            originalNewStringMatch && originalNewStringMatch[1]\n              ? originalNewStringMatch[1]\n              : '';\n          return Promise.resolve({ corrected_new_string: originalNewString });\n        }\n        return Promise.resolve({}); // Default empty object if schema doesn't match\n      },\n    );\n\n    tool = new EditTool(mockConfig);\n  });\n\n  afterEach(() => {\n    fs.rmSync(tempDir, { recursive: true, force: true });\n  });\n\n  describe('applyReplacement', () => {\n    it('should return newString if isNewFile is true', () => {\n      expect(applyReplacement(null, 'old', 'new', true)).toBe('new');\n      expect(applyReplacement('existing', 'old', 'new', true)).toBe('new');\n    });\n\n    it('should return newString if currentContent is null and oldString is empty (defensive)', () => {\n      expect(applyReplacement(null, '', 'new', false)).toBe('new');\n    });\n\n    it('should return empty string if currentContent is null and oldString is not empty (defensive)', () => {\n      expect(applyReplacement(null, 'old', 'new', false)).toBe('');\n    });\n\n    it('should replace oldString with newString in currentContent', () => {\n      expect(applyReplacement('hello old world old', 'old', 'new', false)).toBe(\n        'hello new world new',\n      );\n    });\n\n    it('should return currentContent if oldString is empty and not a new file', () => {\n      expect(applyReplacement('hello world', '', 'new', false)).toBe(\n        'hello world',\n      );\n    });\n  });\n\n  describe('validateToolParams', () => {\n    it('should return null for valid params', () => {\n      const params: EditToolParams = {\n        file_path: path.join(rootDir, 'test.txt'),\n        old_string: 'old',\n        new_string: 'new',\n      };\n      expect(tool.validateToolParams(params)).toBeNull();\n    });\n\n    it('should return error for relative path', () => {\n      const params: EditToolParams = {\n        file_path: 'test.txt',\n        old_string: 'old',\n        new_string: 'new',\n      };\n      expect(tool.validateToolParams(params)).toMatch(\n        /File path must be absolute/,\n      );\n    });\n\n    it('should return error for path outside root', () => {\n      const params: EditToolParams = {\n        file_path: path.join(tempDir, 'outside-root.txt'),\n        old_string: 'old',\n        new_string: 'new',\n      };\n      const error = tool.validateToolParams(params);\n      expect(error).toContain(\n        'File path must be within one of the workspace directories',\n      );\n    });\n  });\n\n  describe('shouldConfirmExecute', () => {\n    const testFile = 'edit_me.txt';\n    let filePath: string;\n\n    beforeEach(() => {\n      filePath = path.join(rootDir, testFile);\n    });\n\n    it('should throw an error if params are invalid', async () => {\n      const params: EditToolParams = {\n        file_path: 'relative.txt',\n        old_string: 'old',\n        new_string: 'new',\n      };\n      expect(() => tool.build(params)).toThrow();\n    });\n\n    it('should request confirmation for valid edit', async () => {\n      fs.writeFileSync(filePath, 'some old content here');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n      };\n      // ensureCorrectEdit will be called by shouldConfirmExecute\n      mockEnsureCorrectEdit.mockResolvedValueOnce({ params, occurrences: 1 });\n      const invocation = tool.build(params);\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).toEqual(\n        expect.objectContaining({\n          title: `Confirm Edit: ${testFile}`,\n          fileName: testFile,\n          fileDiff: expect.any(String),\n        }),\n      );\n    });\n\n    it('should return false if old_string is not found (ensureCorrectEdit returns 0)', async () => {\n      fs.writeFileSync(filePath, 'some content here');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'not_found',\n        new_string: 'new',\n      };\n      mockEnsureCorrectEdit.mockResolvedValueOnce({ params, occurrences: 0 });\n      const invocation = tool.build(params);\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).toBe(false);\n    });\n\n    it('should return false if multiple occurrences of old_string are found (ensureCorrectEdit returns > 1)', async () => {\n      fs.writeFileSync(filePath, 'old old content here');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n      };\n      mockEnsureCorrectEdit.mockResolvedValueOnce({ params, occurrences: 2 });\n      const invocation = tool.build(params);\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).toBe(false);\n    });\n\n    it('should request confirmation for creating a new file (empty old_string)', async () => {\n      const newFileName = 'new_file.txt';\n      const newFilePath = path.join(rootDir, newFileName);\n      const params: EditToolParams = {\n        file_path: newFilePath,\n        old_string: '',\n        new_string: 'new file content',\n      };\n      // ensureCorrectEdit might not be called if old_string is empty,\n      // as shouldConfirmExecute handles this for diff generation.\n      // If it is called, it should return 0 occurrences for a new file.\n      mockEnsureCorrectEdit.mockResolvedValueOnce({ params, occurrences: 0 });\n      const invocation = tool.build(params);\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).toEqual(\n        expect.objectContaining({\n          title: `Confirm Edit: ${newFileName}`,\n          fileName: newFileName,\n          fileDiff: expect.any(String),\n        }),\n      );\n    });\n\n    it('should use corrected params from ensureCorrectEdit for diff generation', async () => {\n      const originalContent = 'This is the original string to be replaced.';\n      const originalOldString = 'original string';\n      const originalNewString = 'new string';\n\n      const correctedOldString = 'original string to be replaced'; // More specific\n      const correctedNewString = 'completely new string'; // Different replacement\n      const expectedFinalContent = 'This is the completely new string.';\n\n      fs.writeFileSync(filePath, originalContent);\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: originalOldString,\n        new_string: originalNewString,\n      };\n\n      // The main beforeEach already calls mockEnsureCorrectEdit.mockReset()\n      // Set a specific mock for this test case\n      let mockCalled = false;\n      mockEnsureCorrectEdit.mockImplementationOnce(\n        async (_, content, p, client) => {\n          mockCalled = true;\n          expect(content).toBe(originalContent);\n          expect(p).toBe(params);\n          expect(client).toBe(geminiClient);\n          return {\n            params: {\n              file_path: filePath,\n              old_string: correctedOldString,\n              new_string: correctedNewString,\n            },\n            occurrences: 1,\n          };\n        },\n      );\n      const invocation = tool.build(params);\n      const confirmation = (await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      )) as FileDiff;\n\n      expect(mockCalled).toBe(true); // Check if the mock implementation was run\n      // expect(mockEnsureCorrectEdit).toHaveBeenCalledWith(originalContent, params, expect.anything()); // Keep this commented for now\n      expect(confirmation).toEqual(\n        expect.objectContaining({\n          title: `Confirm Edit: ${testFile}`,\n          fileName: testFile,\n        }),\n      );\n      // Check that the diff is based on the corrected strings leading to the new state\n      expect(confirmation.fileDiff).toContain(`-${originalContent}`);\n      expect(confirmation.fileDiff).toContain(`+${expectedFinalContent}`);\n\n      // Verify that applying the correctedOldString and correctedNewString to originalContent\n      // indeed produces the expectedFinalContent, which is what the diff should reflect.\n      const patchedContent = originalContent.replace(\n        correctedOldString, // This was the string identified by ensureCorrectEdit for replacement\n        correctedNewString, // This was the string identified by ensureCorrectEdit as the replacement\n      );\n      expect(patchedContent).toBe(expectedFinalContent);\n    });\n  });\n\n  describe('execute', () => {\n    const testFile = 'execute_me.txt';\n    let filePath: string;\n\n    beforeEach(() => {\n      filePath = path.join(rootDir, testFile);\n      // Default for execute tests, can be overridden\n      mockEnsureCorrectEdit.mockImplementation(async (_, content, params) => {\n        let occurrences = 0;\n        if (params.old_string && content) {\n          let index = content.indexOf(params.old_string);\n          while (index !== -1) {\n            occurrences++;\n            index = content.indexOf(params.old_string, index + 1);\n          }\n        } else if (params.old_string === '') {\n          occurrences = 0;\n        }\n        return { params, occurrences };\n      });\n    });\n\n    it('should throw error if file path is not absolute', async () => {\n      const params: EditToolParams = {\n        file_path: 'relative.txt',\n        old_string: 'old',\n        new_string: 'new',\n      };\n      expect(() => tool.build(params)).toThrow(/File path must be absolute/);\n    });\n\n    it('should throw error if file path is empty', async () => {\n      const params: EditToolParams = {\n        file_path: '',\n        old_string: 'old',\n        new_string: 'new',\n      };\n      expect(() => tool.build(params)).toThrow(\n        /The 'file_path' parameter must be non-empty./,\n      );\n    });\n\n    it('should edit an existing file and return diff with fileName', async () => {\n      const initialContent = 'This is some old text.';\n      const newContent = 'This is some new text.'; // old -> new\n      fs.writeFileSync(filePath, initialContent, 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n      };\n\n      // Specific mock for this test's execution path in calculateEdit\n      // ensureCorrectEdit is NOT called by calculateEdit, only by shouldConfirmExecute\n      // So, the default mockEnsureCorrectEdit should correctly return 1 occurrence for 'old' in initialContent\n\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toMatch(/Successfully modified file/);\n      expect(fs.readFileSync(filePath, 'utf8')).toBe(newContent);\n      const display = result.returnDisplay as FileDiff;\n      expect(display.fileDiff).toMatch(initialContent);\n      expect(display.fileDiff).toMatch(newContent);\n      expect(display.fileName).toBe(testFile);\n    });\n\n    it('should create a new file if old_string is empty and file does not exist, and return created message', async () => {\n      const newFileName = 'brand_new_file.txt';\n      const newFilePath = path.join(rootDir, newFileName);\n      const fileContent = 'Content for the new file.';\n      const params: EditToolParams = {\n        file_path: newFilePath,\n        old_string: '',\n        new_string: fileContent,\n      };\n\n      (mockConfig.getApprovalMode as Mock).mockReturnValueOnce(\n        ApprovalMode.AUTO_EDIT,\n      );\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toMatch(/Created new file/);\n      expect(fs.existsSync(newFilePath)).toBe(true);\n      expect(fs.readFileSync(newFilePath, 'utf8')).toBe(fileContent);\n      expect(result.returnDisplay).toBe(`Created ${newFileName}`);\n    });\n\n    it('should return error if old_string is not found in file', async () => {\n      fs.writeFileSync(filePath, 'Some content.', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'nonexistent',\n        new_string: 'replacement',\n      };\n      // The default mockEnsureCorrectEdit will return 0 occurrences for 'nonexistent'\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.llmContent).toMatch(\n        /0 occurrences found for old_string in/,\n      );\n      expect(result.returnDisplay).toMatch(\n        /Failed to edit, could not find the string to replace./,\n      );\n    });\n\n    it('should return error if multiple occurrences of old_string are found', async () => {\n      fs.writeFileSync(filePath, 'multiple old old strings', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n      };\n      // The default mockEnsureCorrectEdit will return 2 occurrences for 'old'\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.llmContent).toMatch(\n        /Expected 1 occurrence but found 2 for old_string in file/,\n      );\n      expect(result.returnDisplay).toMatch(\n        /Failed to edit, expected 1 occurrence but found 2/,\n      );\n    });\n\n    it('should successfully replace multiple occurrences when expected_replacements specified', async () => {\n      fs.writeFileSync(filePath, 'old text old text old text', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n        expected_replacements: 3,\n      };\n\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toMatch(/Successfully modified file/);\n      expect(fs.readFileSync(filePath, 'utf8')).toBe(\n        'new text new text new text',\n      );\n      const display = result.returnDisplay as FileDiff;\n      expect(display.fileDiff).toMatch(/old text old text old text/);\n      expect(display.fileDiff).toMatch(/new text new text new text/);\n      expect(display.fileName).toBe(testFile);\n    });\n\n    it('should return error if expected_replacements does not match actual occurrences', async () => {\n      fs.writeFileSync(filePath, 'old text old text', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n        expected_replacements: 3, // Expecting 3 but only 2 exist\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.llmContent).toMatch(\n        /Expected 3 occurrences but found 2 for old_string in file/,\n      );\n      expect(result.returnDisplay).toMatch(\n        /Failed to edit, expected 3 occurrences but found 2/,\n      );\n    });\n\n    it('should return error if trying to create a file that already exists (empty old_string)', async () => {\n      fs.writeFileSync(filePath, 'Existing content', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: '',\n        new_string: 'new content',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.llmContent).toMatch(/File already exists, cannot create/);\n      expect(result.returnDisplay).toMatch(\n        /Attempted to create a file that already exists/,\n      );\n    });\n\n    it('should include modification message when proposed content is modified', async () => {\n      const initialContent = 'This is some old text.';\n      fs.writeFileSync(filePath, initialContent, 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n        modified_by_user: true,\n      };\n\n      (mockConfig.getApprovalMode as Mock).mockReturnValueOnce(\n        ApprovalMode.AUTO_EDIT,\n      );\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toMatch(\n        /User modified the `new_string` content/,\n      );\n    });\n\n    it('should not include modification message when proposed content is not modified', async () => {\n      const initialContent = 'This is some old text.';\n      fs.writeFileSync(filePath, initialContent, 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n        modified_by_user: false,\n      };\n\n      (mockConfig.getApprovalMode as Mock).mockReturnValueOnce(\n        ApprovalMode.AUTO_EDIT,\n      );\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).not.toMatch(\n        /User modified the `new_string` content/,\n      );\n    });\n\n    it('should not include modification message when modified_by_user is not provided', async () => {\n      const initialContent = 'This is some old text.';\n      fs.writeFileSync(filePath, initialContent, 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n      };\n\n      (mockConfig.getApprovalMode as Mock).mockReturnValueOnce(\n        ApprovalMode.AUTO_EDIT,\n      );\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).not.toMatch(\n        /User modified the `new_string` content/,\n      );\n    });\n\n    it('should return error if old_string and new_string are identical', async () => {\n      const initialContent = 'This is some identical text.';\n      fs.writeFileSync(filePath, initialContent, 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'identical',\n        new_string: 'identical',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.llmContent).toMatch(/No changes to apply/);\n      expect(result.returnDisplay).toMatch(/No changes to apply/);\n    });\n\n    it('should return EDIT_NO_CHANGE error if replacement results in identical content', async () => {\n      // This can happen if ensureCorrectEdit finds a fuzzy match, but the literal\n      // string replacement with `replaceAll` results in no change.\n      const initialContent = 'line 1\\nline  2\\nline 3'; // Note the double space\n      fs.writeFileSync(filePath, initialContent, 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        // old_string has a single space, so it won't be found by replaceAll\n        old_string: 'line 1\\nline 2\\nline 3',\n        new_string: 'line 1\\nnew line 2\\nline 3',\n      };\n\n      // Mock ensureCorrectEdit to simulate it finding a match (e.g., via fuzzy matching)\n      // but it doesn't correct the old_string to the literal content.\n      mockEnsureCorrectEdit.mockResolvedValueOnce({ params, occurrences: 1 });\n\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.error?.type).toBe(ToolErrorType.EDIT_NO_CHANGE);\n      expect(result.returnDisplay).toMatch(\n        /No changes to apply. The new content is identical to the current content./,\n      );\n      // Ensure the file was not actually changed\n      expect(fs.readFileSync(filePath, 'utf8')).toBe(initialContent);\n    });\n  });\n\n  describe('Error Scenarios', () => {\n    const testFile = 'error_test.txt';\n    let filePath: string;\n\n    beforeEach(() => {\n      filePath = path.join(rootDir, testFile);\n    });\n\n    it('should return FILE_NOT_FOUND error', async () => {\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'any',\n        new_string: 'new',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.error?.type).toBe(ToolErrorType.FILE_NOT_FOUND);\n    });\n\n    it('should return ATTEMPT_TO_CREATE_EXISTING_FILE error', async () => {\n      fs.writeFileSync(filePath, 'existing content', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: '',\n        new_string: 'new content',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.error?.type).toBe(\n        ToolErrorType.ATTEMPT_TO_CREATE_EXISTING_FILE,\n      );\n    });\n\n    it('should return NO_OCCURRENCE_FOUND error', async () => {\n      fs.writeFileSync(filePath, 'content', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'not-found',\n        new_string: 'new',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.error?.type).toBe(ToolErrorType.EDIT_NO_OCCURRENCE_FOUND);\n    });\n\n    it('should return EXPECTED_OCCURRENCE_MISMATCH error', async () => {\n      fs.writeFileSync(filePath, 'one one two', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'one',\n        new_string: 'new',\n        expected_replacements: 3,\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.error?.type).toBe(\n        ToolErrorType.EDIT_EXPECTED_OCCURRENCE_MISMATCH,\n      );\n    });\n\n    it('should return NO_CHANGE error', async () => {\n      fs.writeFileSync(filePath, 'content', 'utf8');\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'content',\n        new_string: 'content',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.error?.type).toBe(ToolErrorType.EDIT_NO_CHANGE);\n    });\n\n    it('should throw INVALID_PARAMETERS error for relative path', async () => {\n      const params: EditToolParams = {\n        file_path: 'relative/path.txt',\n        old_string: 'a',\n        new_string: 'b',\n      };\n      expect(() => tool.build(params)).toThrow();\n    });\n\n    it('should return FILE_WRITE_FAILURE on write error', async () => {\n      fs.writeFileSync(filePath, 'content', 'utf8');\n      // Make file readonly to trigger a write error\n      fs.chmodSync(filePath, '444');\n\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'content',\n        new_string: 'new content',\n      };\n      const invocation = tool.build(params);\n      const result = await invocation.execute(new AbortController().signal);\n      expect(result.error?.type).toBe(ToolErrorType.FILE_WRITE_FAILURE);\n    });\n  });\n\n  describe('getDescription', () => {\n    it('should return \"No file changes to...\" if old_string and new_string are the same', () => {\n      const testFileName = 'test.txt';\n      const params: EditToolParams = {\n        file_path: path.join(rootDir, testFileName),\n        old_string: 'identical_string',\n        new_string: 'identical_string',\n      };\n      const invocation = tool.build(params);\n      // shortenPath will be called internally, resulting in just the file name\n      expect(invocation.getDescription()).toBe(\n        `No file changes to ${testFileName}`,\n      );\n    });\n\n    it('should return a snippet of old and new strings if they are different', () => {\n      const testFileName = 'test.txt';\n      const params: EditToolParams = {\n        file_path: path.join(rootDir, testFileName),\n        old_string: 'this is the old string value',\n        new_string: 'this is the new string value',\n      };\n      const invocation = tool.build(params);\n      // shortenPath will be called internally, resulting in just the file name\n      // The snippets are truncated at 30 chars + '...'\n      expect(invocation.getDescription()).toBe(\n        `${testFileName}: this is the old string value => this is the new string value`,\n      );\n    });\n\n    it('should handle very short strings correctly in the description', () => {\n      const testFileName = 'short.txt';\n      const params: EditToolParams = {\n        file_path: path.join(rootDir, testFileName),\n        old_string: 'old',\n        new_string: 'new',\n      };\n      const invocation = tool.build(params);\n      expect(invocation.getDescription()).toBe(`${testFileName}: old => new`);\n    });\n\n    it('should truncate long strings in the description', () => {\n      const testFileName = 'long.txt';\n      const params: EditToolParams = {\n        file_path: path.join(rootDir, testFileName),\n        old_string:\n          'this is a very long old string that will definitely be truncated',\n        new_string:\n          'this is a very long new string that will also be truncated',\n      };\n      const invocation = tool.build(params);\n      expect(invocation.getDescription()).toBe(\n        `${testFileName}: this is a very long old string... => this is a very long new string...`,\n      );\n    });\n  });\n\n  describe('workspace boundary validation', () => {\n    it('should validate paths are within workspace root', () => {\n      const validPath = {\n        file_path: path.join(rootDir, 'file.txt'),\n        old_string: 'old',\n        new_string: 'new',\n      };\n      expect(tool.validateToolParams(validPath)).toBeNull();\n    });\n\n    it('should reject paths outside workspace root', () => {\n      const invalidPath = {\n        file_path: '/etc/passwd',\n        old_string: 'root',\n        new_string: 'hacked',\n      };\n      const error = tool.validateToolParams(invalidPath);\n      expect(error).toContain(\n        'File path must be within one of the workspace directories',\n      );\n      expect(error).toContain(rootDir);\n    });\n  });\n\n  describe('IDE mode', () => {\n    const testFile = 'edit_me.txt';\n    let filePath: string;\n    let ideClient: any;\n\n    beforeEach(() => {\n      filePath = path.join(rootDir, testFile);\n      ideClient = {\n        openDiff: vi.fn(),\n        getConnectionStatus: vi.fn().mockReturnValue({\n          status: IDEConnectionStatus.Connected,\n        }),\n      };\n      (mockConfig as any).getIdeMode = () => true;\n      (mockConfig as any).getIdeClient = () => ideClient;\n    });\n\n    it('should call ideClient.openDiff and update params on confirmation', async () => {\n      const initialContent = 'some old content here';\n      const newContent = 'some new content here';\n      const modifiedContent = 'some modified content here';\n      fs.writeFileSync(filePath, initialContent);\n      const params: EditToolParams = {\n        file_path: filePath,\n        old_string: 'old',\n        new_string: 'new',\n      };\n      mockEnsureCorrectEdit.mockResolvedValueOnce({\n        params: { ...params, old_string: 'old', new_string: 'new' },\n        occurrences: 1,\n      });\n      ideClient.openDiff.mockResolvedValueOnce({\n        status: 'accepted',\n        content: modifiedContent,\n      });\n\n      const invocation = tool.build(params);\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n\n      expect(ideClient.openDiff).toHaveBeenCalledWith(filePath, newContent);\n\n      if (confirmation && 'onConfirm' in confirmation) {\n        await confirmation.onConfirm(ToolConfirmationOutcome.ProceedOnce);\n      }\n\n      expect(params.old_string).toBe(initialContent);\n      expect(params.new_string).toBe(modifiedContent);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/edit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/glob.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/glob.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/grep.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/grep.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/ls.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3665,3668],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3665,3668],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4139,4142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4139,4142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4765,4768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4765,4768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":166,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5086,5089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5086,5089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":197,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6217,6220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6217,6220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":208,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6570,6573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6570,6573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":226,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7230,7233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7230,7233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":237,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7583,7586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7583,7586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":238,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7635,7638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7635,7638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8350,8353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8350,8353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":266,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8703,8706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8703,8706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":267,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8758,8761],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8758,8761],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":314,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10702,10705],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10702,10705],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":332,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":332,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11214,11217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11214,11217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":376,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12985,12988],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12985,12988],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":390,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13431,13434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13431,13434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":468,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":468,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16190,16193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16190,16193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":479,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":479,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16510,16513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16510,16513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \n\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\nimport fs from 'fs';\nimport path from 'path';\n\nvi.mock('fs', () => ({\n  default: {\n    statSync: vi.fn(),\n    readdirSync: vi.fn(),\n  },\n  statSync: vi.fn(),\n  readdirSync: vi.fn(),\n  mkdirSync: vi.fn(),\n}));\nimport { LSTool } from './ls.js';\nimport { Config } from '../config/config.js';\nimport { WorkspaceContext } from '../utils/workspaceContext.js';\nimport { FileDiscoveryService } from '../services/fileDiscoveryService.js';\nimport { ToolErrorType } from './tool-error.js';\n\ndescribe('LSTool', () => {\n  let lsTool: LSTool;\n  let mockConfig: Config;\n  let mockWorkspaceContext: WorkspaceContext;\n  let mockFileService: FileDiscoveryService;\n  const mockPrimaryDir = '/home/user/project';\n  const mockSecondaryDir = '/home/user/other-project';\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n\n    // Mock WorkspaceContext\n    mockWorkspaceContext = {\n      getDirectories: vi\n        .fn()\n        .mockReturnValue([mockPrimaryDir, mockSecondaryDir]),\n      isPathWithinWorkspace: vi\n        .fn()\n        .mockImplementation(\n          (path) =>\n            path.startsWith(mockPrimaryDir) ||\n            path.startsWith(mockSecondaryDir),\n        ),\n      addDirectory: vi.fn(),\n    } as unknown as WorkspaceContext;\n\n    // Mock FileService\n    mockFileService = {\n      shouldGitIgnoreFile: vi.fn().mockReturnValue(false),\n      shouldGeminiIgnoreFile: vi.fn().mockReturnValue(false),\n    } as unknown as FileDiscoveryService;\n\n    // Mock Config\n    mockConfig = {\n      getTargetDir: vi.fn().mockReturnValue(mockPrimaryDir),\n      getWorkspaceContext: vi.fn().mockReturnValue(mockWorkspaceContext),\n      getFileService: vi.fn().mockReturnValue(mockFileService),\n      getFileFilteringOptions: vi.fn().mockReturnValue({\n        respectGitIgnore: true,\n        respectGeminiIgnore: true,\n      }),\n    } as unknown as Config;\n\n    lsTool = new LSTool(mockConfig);\n  });\n\n  describe('parameter validation', () => {\n    it('should accept valid absolute paths within workspace', () => {\n      const params = {\n        path: '/home/user/project/src',\n      };\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      const invocation = lsTool.build(params);\n      expect(invocation).toBeDefined();\n    });\n\n    it('should reject relative paths', () => {\n      const params = {\n        path: './src',\n      };\n\n      expect(() => lsTool.build(params)).toThrow(\n        'Path must be absolute: ./src',\n      );\n    });\n\n    it('should reject paths outside workspace with clear error message', () => {\n      const params = {\n        path: '/etc/passwd',\n      };\n\n      expect(() => lsTool.build(params)).toThrow(\n        'Path must be within one of the workspace directories: /home/user/project, /home/user/other-project',\n      );\n    });\n\n    it('should accept paths in secondary workspace directory', () => {\n      const params = {\n        path: '/home/user/other-project/lib',\n      };\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      const invocation = lsTool.build(params);\n      expect(invocation).toBeDefined();\n    });\n  });\n\n  describe('execute', () => {\n    it('should list files in a directory', async () => {\n      const testPath = '/home/user/project/src';\n      const mockFiles = ['file1.ts', 'file2.ts', 'subdir'];\n      const mockStats = {\n        isDirectory: vi.fn(),\n        mtime: new Date(),\n        size: 1024,\n      };\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        const pathStr = path.toString();\n        if (pathStr === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        // For individual files\n        if (pathStr.toString().endsWith('subdir')) {\n          return { ...mockStats, isDirectory: () => true, size: 0 } as fs.Stats;\n        }\n        return { ...mockStats, isDirectory: () => false } as fs.Stats;\n      });\n\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('[DIR] subdir');\n      expect(result.llmContent).toContain('file1.ts');\n      expect(result.llmContent).toContain('file2.ts');\n      expect(result.returnDisplay).toBe('Listed 3 item(s).');\n    });\n\n    it('should list files from secondary workspace directory', async () => {\n      const testPath = '/home/user/other-project/lib';\n      const mockFiles = ['module1.js', 'module2.js'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        if (path.toString() === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 2048,\n        } as fs.Stats;\n      });\n\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('module1.js');\n      expect(result.llmContent).toContain('module2.js');\n      expect(result.returnDisplay).toBe('Listed 2 item(s).');\n    });\n\n    it('should handle empty directories', async () => {\n      const testPath = '/home/user/project/empty';\n\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      vi.mocked(fs.readdirSync).mockReturnValue([]);\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toBe(\n        'Directory /home/user/project/empty is empty.',\n      );\n      expect(result.returnDisplay).toBe('Directory is empty.');\n    });\n\n    it('should respect ignore patterns', async () => {\n      const testPath = '/home/user/project/src';\n      const mockFiles = ['test.js', 'test.spec.js', 'index.js'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        const pathStr = path.toString();\n        if (pathStr === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 1024,\n        } as fs.Stats;\n      });\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n\n      const invocation = lsTool.build({\n        path: testPath,\n        ignore: ['*.spec.js'],\n      });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('test.js');\n      expect(result.llmContent).toContain('index.js');\n      expect(result.llmContent).not.toContain('test.spec.js');\n      expect(result.returnDisplay).toBe('Listed 2 item(s).');\n    });\n\n    it('should respect gitignore patterns', async () => {\n      const testPath = '/home/user/project/src';\n      const mockFiles = ['file1.js', 'file2.js', 'ignored.js'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        const pathStr = path.toString();\n        if (pathStr === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 1024,\n        } as fs.Stats;\n      });\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n      (mockFileService.shouldGitIgnoreFile as any).mockImplementation(\n        (path: string) => path.includes('ignored.js'),\n      );\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('file1.js');\n      expect(result.llmContent).toContain('file2.js');\n      expect(result.llmContent).not.toContain('ignored.js');\n      expect(result.returnDisplay).toBe('Listed 2 item(s). (1 git-ignored)');\n    });\n\n    it('should respect geminiignore patterns', async () => {\n      const testPath = '/home/user/project/src';\n      const mockFiles = ['file1.js', 'file2.js', 'private.js'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        const pathStr = path.toString();\n        if (pathStr === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 1024,\n        } as fs.Stats;\n      });\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n      (mockFileService.shouldGeminiIgnoreFile as any).mockImplementation(\n        (path: string) => path.includes('private.js'),\n      );\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('file1.js');\n      expect(result.llmContent).toContain('file2.js');\n      expect(result.llmContent).not.toContain('private.js');\n      expect(result.returnDisplay).toBe('Listed 2 item(s). (1 gemini-ignored)');\n    });\n\n    it('should handle non-directory paths', async () => {\n      const testPath = '/home/user/project/file.txt';\n\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => false,\n      } as fs.Stats);\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('Path is not a directory');\n      expect(result.returnDisplay).toBe('Error: Path is not a directory.');\n      expect(result.error?.type).toBe(ToolErrorType.PATH_IS_NOT_A_DIRECTORY);\n    });\n\n    it('should handle non-existent paths', async () => {\n      const testPath = '/home/user/project/does-not-exist';\n\n      vi.mocked(fs.statSync).mockImplementation(() => {\n        throw new Error('ENOENT: no such file or directory');\n      });\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('Error listing directory');\n      expect(result.returnDisplay).toBe('Error: Failed to list directory.');\n      expect(result.error?.type).toBe(ToolErrorType.LS_EXECUTION_ERROR);\n    });\n\n    it('should sort directories first, then files alphabetically', async () => {\n      const testPath = '/home/user/project/src';\n      const mockFiles = ['z-file.ts', 'a-dir', 'b-file.ts', 'c-dir'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        if (path.toString() === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        if (path.toString().endsWith('-dir')) {\n          return {\n            isDirectory: () => true,\n            mtime: new Date(),\n            size: 0,\n          } as fs.Stats;\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 1024,\n        } as fs.Stats;\n      });\n\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      const lines = (\n        typeof result.llmContent === 'string' ? result.llmContent : ''\n      ).split('\\n');\n      const entries = lines.slice(1).filter((line: string) => line.trim()); // Skip header\n      expect(entries[0]).toBe('[DIR] a-dir');\n      expect(entries[1]).toBe('[DIR] c-dir');\n      expect(entries[2]).toBe('b-file.ts');\n      expect(entries[3]).toBe('z-file.ts');\n    });\n\n    it('should handle permission errors gracefully', async () => {\n      const testPath = '/home/user/project/restricted';\n\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      vi.mocked(fs.readdirSync).mockImplementation(() => {\n        throw new Error('EACCES: permission denied');\n      });\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('Error listing directory');\n      expect(result.llmContent).toContain('permission denied');\n      expect(result.returnDisplay).toBe('Error: Failed to list directory.');\n      expect(result.error?.type).toBe(ToolErrorType.LS_EXECUTION_ERROR);\n    });\n\n    it('should throw for invalid params at build time', async () => {\n      expect(() => lsTool.build({ path: '../outside' })).toThrow(\n        'Path must be absolute: ../outside',\n      );\n    });\n\n    it('should handle errors accessing individual files during listing', async () => {\n      const testPath = '/home/user/project/src';\n      const mockFiles = ['accessible.ts', 'inaccessible.ts'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        if (path.toString() === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        if (path.toString().endsWith('inaccessible.ts')) {\n          throw new Error('EACCES: permission denied');\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 1024,\n        } as fs.Stats;\n      });\n\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n\n      // Spy on console.error to verify it's called\n      const consoleErrorSpy = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => {});\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      // Should still list the accessible file\n      expect(result.llmContent).toContain('accessible.ts');\n      expect(result.llmContent).not.toContain('inaccessible.ts');\n      expect(result.returnDisplay).toBe('Listed 1 item(s).');\n\n      // Verify error was logged\n      expect(consoleErrorSpy).toHaveBeenCalledWith(\n        expect.stringContaining('Error accessing'),\n      );\n\n      consoleErrorSpy.mockRestore();\n    });\n  });\n\n  describe('getDescription', () => {\n    it('should return shortened relative path', () => {\n      const params = {\n        path: `${mockPrimaryDir}/deeply/nested/directory`,\n      };\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      const invocation = lsTool.build(params);\n      const description = invocation.getDescription();\n      expect(description).toBe(path.join('deeply', 'nested', 'directory'));\n    });\n\n    it('should handle paths in secondary workspace', () => {\n      const params = {\n        path: `${mockSecondaryDir}/lib`,\n      };\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      const invocation = lsTool.build(params);\n      const description = invocation.getDescription();\n      expect(description).toBe(path.join('..', 'other-project', 'lib'));\n    });\n  });\n\n  describe('workspace boundary validation', () => {\n    it('should accept paths in primary workspace directory', () => {\n      const params = { path: `${mockPrimaryDir}/src` };\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      expect(lsTool.build(params)).toBeDefined();\n    });\n\n    it('should accept paths in secondary workspace directory', () => {\n      const params = { path: `${mockSecondaryDir}/lib` };\n      vi.mocked(fs.statSync).mockReturnValue({\n        isDirectory: () => true,\n      } as fs.Stats);\n      expect(lsTool.build(params)).toBeDefined();\n    });\n\n    it('should reject paths outside all workspace directories', () => {\n      const params = { path: '/etc/passwd' };\n      expect(() => lsTool.build(params)).toThrow(\n        'Path must be within one of the workspace directories',\n      );\n    });\n\n    it('should list files from secondary workspace directory', async () => {\n      const testPath = `${mockSecondaryDir}/tests`;\n      const mockFiles = ['test1.spec.ts', 'test2.spec.ts'];\n\n      vi.mocked(fs.statSync).mockImplementation((path: any) => {\n        if (path.toString() === testPath) {\n          return { isDirectory: () => true } as fs.Stats;\n        }\n        return {\n          isDirectory: () => false,\n          mtime: new Date(),\n          size: 512,\n        } as fs.Stats;\n      });\n\n      vi.mocked(fs.readdirSync).mockReturnValue(mockFiles as any);\n\n      const invocation = lsTool.build({ path: testPath });\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.llmContent).toContain('test1.spec.ts');\n      expect(result.llmContent).toContain('test2.spec.ts');\n      expect(result.returnDisplay).toBe('Listed 2 item(s).');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/ls.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/mcp-client-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/mcp-client-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/mcp-client.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":325,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":325,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10088,10091],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10088,10091],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":344,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":344,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10698,10701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10698,10701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { afterEach, describe, expect, it, vi } from 'vitest';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport {\n  populateMcpServerCommand,\n  createTransport,\n  isEnabled,\n  hasValidTypes,\n  McpClient,\n  hasNetworkTransport,\n} from './mcp-client.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport * as SdkClientStdioLib from '@modelcontextprotocol/sdk/client/stdio.js';\nimport * as ClientLib from '@modelcontextprotocol/sdk/client/index.js';\nimport * as GenAiLib from '@google/genai';\nimport { GoogleCredentialProvider } from '../mcp/google-auth-provider.js';\nimport { AuthProviderType } from '../config/config.js';\nimport { PromptRegistry } from '../prompts/prompt-registry.js';\nimport { ToolRegistry } from './tool-registry.js';\nimport { WorkspaceContext } from '../utils/workspaceContext.js';\n\nvi.mock('@modelcontextprotocol/sdk/client/stdio.js');\nvi.mock('@modelcontextprotocol/sdk/client/index.js');\nvi.mock('@google/genai');\nvi.mock('../mcp/oauth-provider.js');\nvi.mock('../mcp/oauth-token-storage.js');\n\ndescribe('mcp-client', () => {\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('McpClient', () => {\n    it('should discover tools', async () => {\n      const mockedClient = {\n        connect: vi.fn(),\n        discover: vi.fn(),\n        disconnect: vi.fn(),\n        getStatus: vi.fn(),\n        registerCapabilities: vi.fn(),\n        setRequestHandler: vi.fn(),\n      };\n      vi.mocked(ClientLib.Client).mockReturnValue(\n        mockedClient as unknown as ClientLib.Client,\n      );\n      vi.spyOn(SdkClientStdioLib, 'StdioClientTransport').mockReturnValue(\n        {} as SdkClientStdioLib.StdioClientTransport,\n      );\n      const mockedMcpToTool = vi.mocked(GenAiLib.mcpToTool).mockReturnValue({\n        tool: () => ({\n          functionDeclarations: [\n            {\n              name: 'testFunction',\n            },\n          ],\n        }),\n      } as unknown as GenAiLib.CallableTool);\n      const mockedToolRegistry = {\n        registerTool: vi.fn(),\n      } as unknown as ToolRegistry;\n      const client = new McpClient(\n        'test-server',\n        {\n          command: 'test-command',\n        },\n        mockedToolRegistry,\n        {} as PromptRegistry,\n        {} as WorkspaceContext,\n        false,\n      );\n      await client.connect();\n      await client.discover();\n      expect(mockedMcpToTool).toHaveBeenCalledOnce();\n    });\n\n    it('should skip tools if a parameter is missing a type', async () => {\n      const consoleWarnSpy = vi\n        .spyOn(console, 'warn')\n        .mockImplementation(() => {});\n      const mockedClient = {\n        connect: vi.fn(),\n        discover: vi.fn(),\n        disconnect: vi.fn(),\n        getStatus: vi.fn(),\n        registerCapabilities: vi.fn(),\n        setRequestHandler: vi.fn(),\n        tool: vi.fn(),\n      };\n      vi.mocked(ClientLib.Client).mockReturnValue(\n        mockedClient as unknown as ClientLib.Client,\n      );\n      vi.spyOn(SdkClientStdioLib, 'StdioClientTransport').mockReturnValue(\n        {} as SdkClientStdioLib.StdioClientTransport,\n      );\n      vi.mocked(GenAiLib.mcpToTool).mockReturnValue({\n        tool: () =>\n          Promise.resolve({\n            functionDeclarations: [\n              {\n                name: 'validTool',\n                parametersJsonSchema: {\n                  type: 'object',\n                  properties: {\n                    param1: { type: 'string' },\n                  },\n                },\n              },\n              {\n                name: 'invalidTool',\n                parametersJsonSchema: {\n                  type: 'object',\n                  properties: {\n                    param1: { description: 'a param with no type' },\n                  },\n                },\n              },\n            ],\n          }),\n      } as unknown as GenAiLib.CallableTool);\n      const mockedToolRegistry = {\n        registerTool: vi.fn(),\n      } as unknown as ToolRegistry;\n      const client = new McpClient(\n        'test-server',\n        {\n          command: 'test-command',\n        },\n        mockedToolRegistry,\n        {} as PromptRegistry,\n        {} as WorkspaceContext,\n        false,\n      );\n      await client.connect();\n      await client.discover();\n      expect(mockedToolRegistry.registerTool).toHaveBeenCalledOnce();\n      expect(consoleWarnSpy).toHaveBeenCalledOnce();\n      expect(consoleWarnSpy).toHaveBeenCalledWith(\n        `Skipping tool 'invalidTool' from MCP server 'test-server' because it has ` +\n          `missing types in its parameter schema. Please file an issue with the owner of the MCP server.`,\n      );\n      consoleWarnSpy.mockRestore();\n    });\n\n    it('should handle errors when discovering prompts', async () => {\n      const consoleErrorSpy = vi\n        .spyOn(console, 'error')\n        .mockImplementation(() => {});\n      const mockedClient = {\n        connect: vi.fn(),\n        discover: vi.fn(),\n        disconnect: vi.fn(),\n        getStatus: vi.fn(),\n        registerCapabilities: vi.fn(),\n        setRequestHandler: vi.fn(),\n        getServerCapabilities: vi.fn().mockReturnValue({ prompts: {} }),\n        request: vi.fn().mockRejectedValue(new Error('Test error')),\n      };\n      vi.mocked(ClientLib.Client).mockReturnValue(\n        mockedClient as unknown as ClientLib.Client,\n      );\n      vi.spyOn(SdkClientStdioLib, 'StdioClientTransport').mockReturnValue(\n        {} as SdkClientStdioLib.StdioClientTransport,\n      );\n      vi.mocked(GenAiLib.mcpToTool).mockReturnValue({\n        tool: () => Promise.resolve({ functionDeclarations: [] }),\n      } as unknown as GenAiLib.CallableTool);\n      const client = new McpClient(\n        'test-server',\n        {\n          command: 'test-command',\n        },\n        {} as ToolRegistry,\n        {} as PromptRegistry,\n        {} as WorkspaceContext,\n        false,\n      );\n      await client.connect();\n      await expect(client.discover()).rejects.toThrow(\n        'No prompts or tools found on the server.',\n      );\n      expect(consoleErrorSpy).toHaveBeenCalledWith(\n        `Error discovering prompts from test-server: Test error`,\n      );\n      consoleErrorSpy.mockRestore();\n    });\n  });\n  describe('appendMcpServerCommand', () => {\n    it('should do nothing if no MCP servers or command are configured', () => {\n      const out = populateMcpServerCommand({}, undefined);\n      expect(out).toEqual({});\n    });\n\n    it('should discover tools via mcpServerCommand', () => {\n      const commandString = 'command --arg1 value1';\n      const out = populateMcpServerCommand({}, commandString);\n      expect(out).toEqual({\n        mcp: {\n          command: 'command',\n          args: ['--arg1', 'value1'],\n        },\n      });\n    });\n\n    it('should handle error if mcpServerCommand parsing fails', () => {\n      expect(() => populateMcpServerCommand({}, 'derp && herp')).toThrowError();\n    });\n  });\n\n  describe('createTransport', () => {\n    describe('should connect via httpUrl', () => {\n      it('without headers', async () => {\n        const transport = await createTransport(\n          'test-server',\n          {\n            httpUrl: 'http://test-server',\n          },\n          false,\n        );\n\n        expect(transport).toEqual(\n          new StreamableHTTPClientTransport(new URL('http://test-server'), {}),\n        );\n      });\n\n      it('with headers', async () => {\n        const transport = await createTransport(\n          'test-server',\n          {\n            httpUrl: 'http://test-server',\n            headers: { Authorization: 'derp' },\n          },\n          false,\n        );\n\n        expect(transport).toEqual(\n          new StreamableHTTPClientTransport(new URL('http://test-server'), {\n            requestInit: {\n              headers: { Authorization: 'derp' },\n            },\n          }),\n        );\n      });\n    });\n\n    describe('should connect via url', () => {\n      it('without headers', async () => {\n        const transport = await createTransport(\n          'test-server',\n          {\n            url: 'http://test-server',\n          },\n          false,\n        );\n        expect(transport).toEqual(\n          new SSEClientTransport(new URL('http://test-server'), {}),\n        );\n      });\n\n      it('with headers', async () => {\n        const transport = await createTransport(\n          'test-server',\n          {\n            url: 'http://test-server',\n            headers: { Authorization: 'derp' },\n          },\n          false,\n        );\n\n        expect(transport).toEqual(\n          new SSEClientTransport(new URL('http://test-server'), {\n            requestInit: {\n              headers: { Authorization: 'derp' },\n            },\n          }),\n        );\n      });\n    });\n\n    it('should connect via command', async () => {\n      const mockedTransport = vi\n        .spyOn(SdkClientStdioLib, 'StdioClientTransport')\n        .mockReturnValue({} as SdkClientStdioLib.StdioClientTransport);\n\n      await createTransport(\n        'test-server',\n        {\n          command: 'test-command',\n          args: ['--foo', 'bar'],\n          env: { FOO: 'bar' },\n          cwd: 'test/cwd',\n        },\n        false,\n      );\n\n      expect(mockedTransport).toHaveBeenCalledWith({\n        command: 'test-command',\n        args: ['--foo', 'bar'],\n        cwd: 'test/cwd',\n        env: { ...process.env, FOO: 'bar' },\n        stderr: 'pipe',\n      });\n    });\n\n    describe('useGoogleCredentialProvider', () => {\n      it('should use GoogleCredentialProvider when specified', async () => {\n        const transport = await createTransport(\n          'test-server',\n          {\n            httpUrl: 'http://test.googleapis.com',\n            authProviderType: AuthProviderType.GOOGLE_CREDENTIALS,\n            oauth: {\n              scopes: ['scope1'],\n            },\n          },\n          false,\n        );\n\n        expect(transport).toBeInstanceOf(StreamableHTTPClientTransport);\n         \n        const authProvider = (transport as any)._authProvider;\n        expect(authProvider).toBeInstanceOf(GoogleCredentialProvider);\n      });\n\n      it('should use GoogleCredentialProvider with SSE transport', async () => {\n        const transport = await createTransport(\n          'test-server',\n          {\n            url: 'http://test.googleapis.com',\n            authProviderType: AuthProviderType.GOOGLE_CREDENTIALS,\n            oauth: {\n              scopes: ['scope1'],\n            },\n          },\n          false,\n        );\n\n        expect(transport).toBeInstanceOf(SSEClientTransport);\n         \n        const authProvider = (transport as any)._authProvider;\n        expect(authProvider).toBeInstanceOf(GoogleCredentialProvider);\n      });\n\n      it('should throw an error if no URL is provided with GoogleCredentialProvider', async () => {\n        await expect(\n          createTransport(\n            'test-server',\n            {\n              authProviderType: AuthProviderType.GOOGLE_CREDENTIALS,\n              oauth: {\n                scopes: ['scope1'],\n              },\n            },\n            false,\n          ),\n        ).rejects.toThrow(\n          'URL must be provided in the config for Google Credentials provider',\n        );\n      });\n    });\n  });\n  describe('isEnabled', () => {\n    const funcDecl = { name: 'myTool' };\n    const serverName = 'myServer';\n\n    it('should return true if no include or exclude lists are provided', () => {\n      const mcpServerConfig = {};\n      expect(isEnabled(funcDecl, serverName, mcpServerConfig)).toBe(true);\n    });\n\n    it('should return false if the tool is in the exclude list', () => {\n      const mcpServerConfig = { excludeTools: ['myTool'] };\n      expect(isEnabled(funcDecl, serverName, mcpServerConfig)).toBe(false);\n    });\n\n    it('should return true if the tool is in the include list', () => {\n      const mcpServerConfig = { includeTools: ['myTool'] };\n      expect(isEnabled(funcDecl, serverName, mcpServerConfig)).toBe(true);\n    });\n\n    it('should return true if the tool is in the include list with parentheses', () => {\n      const mcpServerConfig = { includeTools: ['myTool()'] };\n      expect(isEnabled(funcDecl, serverName, mcpServerConfig)).toBe(true);\n    });\n\n    it('should return false if the include list exists but does not contain the tool', () => {\n      const mcpServerConfig = { includeTools: ['anotherTool'] };\n      expect(isEnabled(funcDecl, serverName, mcpServerConfig)).toBe(false);\n    });\n\n    it('should return false if the tool is in both the include and exclude lists', () => {\n      const mcpServerConfig = {\n        includeTools: ['myTool'],\n        excludeTools: ['myTool'],\n      };\n      expect(isEnabled(funcDecl, serverName, mcpServerConfig)).toBe(false);\n    });\n\n    it('should return false if the function declaration has no name', () => {\n      const namelessFuncDecl = {};\n      const mcpServerConfig = {};\n      expect(isEnabled(namelessFuncDecl, serverName, mcpServerConfig)).toBe(\n        false,\n      );\n    });\n  });\n\n  describe('hasValidTypes', () => {\n    it('should return true for a valid schema with anyOf', () => {\n      const schema = {\n        anyOf: [{ type: 'string' }, { type: 'number' }],\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return false for an invalid schema with anyOf', () => {\n      const schema = {\n        anyOf: [{ type: 'string' }, { description: 'no type' }],\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return true for a valid schema with allOf', () => {\n      const schema = {\n        allOf: [\n          { type: 'string' },\n          { type: 'object', properties: { foo: { type: 'string' } } },\n        ],\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return false for an invalid schema with allOf', () => {\n      const schema = {\n        allOf: [{ type: 'string' }, { description: 'no type' }],\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return true for a valid schema with oneOf', () => {\n      const schema = {\n        oneOf: [{ type: 'string' }, { type: 'number' }],\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return false for an invalid schema with oneOf', () => {\n      const schema = {\n        oneOf: [{ type: 'string' }, { description: 'no type' }],\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return true for a valid schema with nested subschemas', () => {\n      const schema = {\n        anyOf: [\n          { type: 'string' },\n          {\n            allOf: [\n              { type: 'object', properties: { a: { type: 'string' } } },\n              { type: 'object', properties: { b: { type: 'number' } } },\n            ],\n          },\n        ],\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return false for an invalid schema with nested subschemas', () => {\n      const schema = {\n        anyOf: [\n          { type: 'string' },\n          {\n            allOf: [\n              { type: 'object', properties: { a: { type: 'string' } } },\n              { description: 'no type' },\n            ],\n          },\n        ],\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return true for a schema with a type and subschemas', () => {\n      const schema = {\n        type: 'string',\n        anyOf: [{ minLength: 1 }, { maxLength: 5 }],\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return false for a schema with no type and no subschemas', () => {\n      const schema = {\n        description: 'a schema with no type',\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return true for a valid schema', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          param1: { type: 'string' },\n        },\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return false if a parameter is missing a type', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          param1: { description: 'a param with no type' },\n        },\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return false if a nested parameter is missing a type', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          param1: {\n            type: 'object',\n            properties: {\n              nestedParam: {\n                description: 'a nested param with no type',\n              },\n            },\n          },\n        },\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return false if an array item is missing a type', () => {\n      const schema = {\n        type: 'object',\n        properties: {\n          param1: {\n            type: 'array',\n            items: {\n              description: 'an array item with no type',\n            },\n          },\n        },\n      };\n      expect(hasValidTypes(schema)).toBe(false);\n    });\n\n    it('should return true for a schema with no properties', () => {\n      const schema = {\n        type: 'object',\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n\n    it('should return true for a schema with an empty properties object', () => {\n      const schema = {\n        type: 'object',\n        properties: {},\n      };\n      expect(hasValidTypes(schema)).toBe(true);\n    });\n  });\n\n  describe('hasNetworkTransport', () => {\n    it('should return true if only url is provided', () => {\n      const config = { url: 'http://example.com' };\n      expect(hasNetworkTransport(config)).toBe(true);\n    });\n\n    it('should return true if only httpUrl is provided', () => {\n      const config = { httpUrl: 'http://example.com' };\n      expect(hasNetworkTransport(config)).toBe(true);\n    });\n\n    it('should return true if both url and httpUrl are provided', () => {\n      const config = {\n        url: 'http://example.com/sse',\n        httpUrl: 'http://example.com/http',\n      };\n      expect(hasNetworkTransport(config)).toBe(true);\n    });\n\n    it('should return false if neither url nor httpUrl is provided', () => {\n      const config = { command: 'do-something' };\n      expect(hasNetworkTransport(config)).toBe(false);\n    });\n\n    it('should return false for an empty config object', () => {\n      const config = {};\n      expect(hasNetworkTransport(config)).toBe(false);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/mcp-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/mcp-tool.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[840,843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[840,843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[932,935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[932,935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2847,2850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2847,2850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":615,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":615,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19568,19571],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19568,19571],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":624,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":624,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19941,19944],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19941,19944],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":655,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":655,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21231,21234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21231,21234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":679,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":679,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22091,22094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22091,22094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":702,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":702,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22881,22884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22881,22884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":729,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":729,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23841,23844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23841,23844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \nimport {\n  describe,\n  it,\n  expect,\n  vi,\n  beforeEach,\n  afterEach,\n  Mocked,\n} from 'vitest';\nimport { safeJsonStringify } from '../utils/safeJsonStringify.js';\nimport { DiscoveredMCPTool, generateValidName } from './mcp-tool.js'; // Added getStringifiedResultForDisplay\nimport { ToolResult, ToolConfirmationOutcome } from './tools.js'; // Added ToolConfirmationOutcome\nimport { CallableTool, Part } from '@google/genai';\nimport { ToolErrorType } from './tool-error.js';\n\n// Mock @google/genai mcpToTool and CallableTool\n// We only need to mock the parts of CallableTool that DiscoveredMCPTool uses.\nconst mockCallTool = vi.fn();\nconst mockToolMethod = vi.fn();\n\nconst mockCallableToolInstance: Mocked<CallableTool> = {\n  tool: mockToolMethod as any, // Not directly used by DiscoveredMCPTool instance methods\n  callTool: mockCallTool as any,\n  // Add other methods if DiscoveredMCPTool starts using them\n};\n\ndescribe('generateValidName', () => {\n  it('should return a valid name for a simple function', () => {\n    expect(generateValidName('myFunction')).toBe('myFunction');\n  });\n\n  it('should replace invalid characters with underscores', () => {\n    expect(generateValidName('invalid-name with spaces')).toBe(\n      'invalid-name_with_spaces',\n    );\n  });\n\n  it('should truncate long names', () => {\n    expect(generateValidName('x'.repeat(80))).toBe(\n      'xxxxxxxxxxxxxxxxxxxxxxxxxxxx___xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n    );\n  });\n\n  it('should handle names with only invalid characters', () => {\n    expect(generateValidName('!@#$%^&*()')).toBe('__________');\n  });\n\n  it('should handle names that are exactly 63 characters long', () => {\n    expect(generateValidName('a'.repeat(63)).length).toBe(63);\n  });\n\n  it('should handle names that are exactly 64 characters long', () => {\n    expect(generateValidName('a'.repeat(64)).length).toBe(63);\n  });\n\n  it('should handle names that are longer than 64 characters', () => {\n    expect(generateValidName('a'.repeat(80)).length).toBe(63);\n  });\n});\n\ndescribe('DiscoveredMCPTool', () => {\n  const serverName = 'mock-mcp-server';\n  const serverToolName = 'actual-server-tool-name';\n  const baseDescription = 'A test MCP tool.';\n  const inputSchema: Record<string, unknown> = {\n    type: 'object' as const,\n    properties: { param: { type: 'string' } },\n    required: ['param'],\n  };\n\n  let tool: DiscoveredMCPTool;\n\n  beforeEach(() => {\n    mockCallTool.mockClear();\n    mockToolMethod.mockClear();\n    tool = new DiscoveredMCPTool(\n      mockCallableToolInstance,\n      serverName,\n      serverToolName,\n      baseDescription,\n      inputSchema,\n    );\n    // Clear allowlist before each relevant test, especially for shouldConfirmExecute\n    const invocation = tool.build({ param: 'mock' }) as any;\n    invocation.constructor.allowlist.clear();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('constructor', () => {\n    it('should set properties correctly', () => {\n      expect(tool.name).toBe(serverToolName);\n      expect(tool.schema.name).toBe(serverToolName);\n      expect(tool.schema.description).toBe(baseDescription);\n      expect(tool.schema.parameters).toBeUndefined();\n      expect(tool.schema.parametersJsonSchema).toEqual(inputSchema);\n      expect(tool.serverToolName).toBe(serverToolName);\n      expect(tool.timeout).toBeUndefined();\n    });\n\n    it('should accept and store a custom timeout', () => {\n      const customTimeout = 5000;\n      const toolWithTimeout = new DiscoveredMCPTool(\n        mockCallableToolInstance,\n        serverName,\n        serverToolName,\n        baseDescription,\n        inputSchema,\n        customTimeout,\n      );\n      expect(toolWithTimeout.timeout).toBe(customTimeout);\n    });\n  });\n\n  describe('execute', () => {\n    it('should call mcpTool.callTool with correct parameters and format display output', async () => {\n      const params = { param: 'testValue' };\n      const mockToolSuccessResultObject = {\n        success: true,\n        details: 'executed',\n      };\n      const mockFunctionResponseContent = [\n        {\n          type: 'text',\n          text: JSON.stringify(mockToolSuccessResultObject),\n        },\n      ];\n      const mockMcpToolResponseParts: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: { content: mockFunctionResponseContent },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(mockMcpToolResponseParts);\n\n      const invocation = tool.build(params);\n      const toolResult: ToolResult = await invocation.execute(\n        new AbortController().signal,\n      );\n\n      expect(mockCallTool).toHaveBeenCalledWith([\n        { name: serverToolName, args: params },\n      ]);\n\n      const stringifiedResponseContent = JSON.stringify(\n        mockToolSuccessResultObject,\n      );\n      expect(toolResult.llmContent).toEqual([\n        { text: stringifiedResponseContent },\n      ]);\n      expect(toolResult.returnDisplay).toBe(stringifiedResponseContent);\n    });\n\n    it('should handle empty result from getStringifiedResultForDisplay', async () => {\n      const params = { param: 'testValue' };\n      const mockMcpToolResponsePartsEmpty: Part[] = [];\n      mockCallTool.mockResolvedValue(mockMcpToolResponsePartsEmpty);\n      const invocation = tool.build(params);\n      const toolResult: ToolResult = await invocation.execute(\n        new AbortController().signal,\n      );\n      expect(toolResult.returnDisplay).toBe('```json\\n[]\\n```');\n      expect(toolResult.llmContent).toEqual([\n        { text: '[Error: Could not parse tool response]' },\n      ]);\n    });\n\n    it('should propagate rejection if mcpTool.callTool rejects', async () => {\n      const params = { param: 'failCase' };\n      const expectedError = new Error('MCP call failed');\n      mockCallTool.mockRejectedValue(expectedError);\n\n      const invocation = tool.build(params);\n      await expect(\n        invocation.execute(new AbortController().signal),\n      ).rejects.toThrow(expectedError);\n    });\n\n    it.each([\n      { isErrorValue: true, description: 'true (bool)' },\n      { isErrorValue: 'true', description: '\"true\" (str)' },\n    ])(\n      'should return a structured error if MCP tool reports an error',\n      async ({ isErrorValue }) => {\n        const tool = new DiscoveredMCPTool(\n          mockCallableToolInstance,\n          serverName,\n          serverToolName,\n          baseDescription,\n          inputSchema,\n        );\n        const params = { param: 'isErrorTrueCase' };\n        const functionCall = {\n          name: serverToolName,\n          args: params,\n        };\n\n        const errorResponse = { isError: isErrorValue };\n        const mockMcpToolResponseParts: Part[] = [\n          {\n            functionResponse: {\n              name: serverToolName,\n              response: { error: errorResponse },\n            },\n          },\n        ];\n        mockCallTool.mockResolvedValue(mockMcpToolResponseParts);\n        const expectedErrorMessage = `MCP tool '${\n          serverToolName\n        }' reported tool error for function call: ${safeJsonStringify(\n          functionCall,\n        )} with response: ${safeJsonStringify(mockMcpToolResponseParts)}`;\n        const invocation = tool.build(params);\n        const result = await invocation.execute(new AbortController().signal);\n\n        expect(result.error?.type).toBe(ToolErrorType.MCP_TOOL_ERROR);\n        expect(result.llmContent).toBe(expectedErrorMessage);\n        expect(result.returnDisplay).toContain(\n          `Error: MCP tool '${serverToolName}' reported an error.`,\n        );\n      },\n    );\n\n    it.each([\n      { isErrorValue: false, description: 'false (bool)' },\n      { isErrorValue: 'false', description: '\"false\" (str)' },\n    ])(\n      'should consider a ToolResult with isError ${description} to be a success',\n      async ({ isErrorValue }) => {\n        const tool = new DiscoveredMCPTool(\n          mockCallableToolInstance,\n          serverName,\n          serverToolName,\n          baseDescription,\n          inputSchema,\n        );\n        const params = { param: 'isErrorFalseCase' };\n        const mockToolSuccessResultObject = {\n          success: true,\n          details: 'executed',\n        };\n        const mockFunctionResponseContent = [\n          {\n            type: 'text',\n            text: JSON.stringify(mockToolSuccessResultObject),\n          },\n        ];\n\n        const errorResponse = { isError: isErrorValue };\n        const mockMcpToolResponseParts: Part[] = [\n          {\n            functionResponse: {\n              name: serverToolName,\n              response: {\n                error: errorResponse,\n                content: mockFunctionResponseContent,\n              },\n            },\n          },\n        ];\n        mockCallTool.mockResolvedValue(mockMcpToolResponseParts);\n\n        const invocation = tool.build(params);\n        const toolResult = await invocation.execute(\n          new AbortController().signal,\n        );\n\n        const stringifiedResponseContent = JSON.stringify(\n          mockToolSuccessResultObject,\n        );\n        expect(toolResult.llmContent).toEqual([\n          { text: stringifiedResponseContent },\n        ]);\n        expect(toolResult.returnDisplay).toBe(stringifiedResponseContent);\n      },\n    );\n\n    it('should handle a simple text response correctly', async () => {\n      const params = { param: 'test' };\n      const successMessage = 'This is a success message.';\n\n      // Simulate the response from the GenAI SDK, which wraps the MCP\n      // response in a functionResponse Part.\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              // The `content` array contains MCP ContentBlocks.\n              content: [{ type: 'text', text: successMessage }],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      // 1. Assert that the llmContent sent to the scheduler is a clean Part array.\n      expect(toolResult.llmContent).toEqual([{ text: successMessage }]);\n\n      // 2. Assert that the display output is the simple text message.\n      expect(toolResult.returnDisplay).toBe(successMessage);\n\n      // 3. Verify that the underlying callTool was made correctly.\n      expect(mockCallTool).toHaveBeenCalledWith([\n        { name: serverToolName, args: params },\n      ]);\n    });\n\n    it('should handle an AudioBlock response', async () => {\n      const params = { param: 'play' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                {\n                  type: 'audio',\n                  data: 'BASE64_AUDIO_DATA',\n                  mimeType: 'audio/mp3',\n                },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([\n        {\n          text: `[Tool '${serverToolName}' provided the following audio data with mime-type: audio/mp3]`,\n        },\n        {\n          inlineData: {\n            mimeType: 'audio/mp3',\n            data: 'BASE64_AUDIO_DATA',\n          },\n        },\n      ]);\n      expect(toolResult.returnDisplay).toBe('[Audio: audio/mp3]');\n    });\n\n    it('should handle a ResourceLinkBlock response', async () => {\n      const params = { param: 'get' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                {\n                  type: 'resource_link',\n                  uri: 'file:///path/to/thing',\n                  name: 'resource-name',\n                  title: 'My Resource',\n                },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([\n        {\n          text: 'Resource Link: My Resource at file:///path/to/thing',\n        },\n      ]);\n      expect(toolResult.returnDisplay).toBe(\n        '[Link to My Resource: file:///path/to/thing]',\n      );\n    });\n\n    it('should handle an embedded text ResourceBlock response', async () => {\n      const params = { param: 'get' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                {\n                  type: 'resource',\n                  resource: {\n                    uri: 'file:///path/to/text.txt',\n                    text: 'This is the text content.',\n                    mimeType: 'text/plain',\n                  },\n                },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([\n        { text: 'This is the text content.' },\n      ]);\n      expect(toolResult.returnDisplay).toBe('This is the text content.');\n    });\n\n    it('should handle an embedded binary ResourceBlock response', async () => {\n      const params = { param: 'get' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                {\n                  type: 'resource',\n                  resource: {\n                    uri: 'file:///path/to/data.bin',\n                    blob: 'BASE64_BINARY_DATA',\n                    mimeType: 'application/octet-stream',\n                  },\n                },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([\n        {\n          text: `[Tool '${serverToolName}' provided the following embedded resource with mime-type: application/octet-stream]`,\n        },\n        {\n          inlineData: {\n            mimeType: 'application/octet-stream',\n            data: 'BASE64_BINARY_DATA',\n          },\n        },\n      ]);\n      expect(toolResult.returnDisplay).toBe(\n        '[Embedded Resource: application/octet-stream]',\n      );\n    });\n\n    it('should handle a mix of content block types', async () => {\n      const params = { param: 'complex' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                { type: 'text', text: 'First part.' },\n                {\n                  type: 'image',\n                  data: 'BASE64_IMAGE_DATA',\n                  mimeType: 'image/jpeg',\n                },\n                { type: 'text', text: 'Second part.' },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([\n        { text: 'First part.' },\n        {\n          text: `[Tool '${serverToolName}' provided the following image data with mime-type: image/jpeg]`,\n        },\n        {\n          inlineData: {\n            mimeType: 'image/jpeg',\n            data: 'BASE64_IMAGE_DATA',\n          },\n        },\n        { text: 'Second part.' },\n      ]);\n      expect(toolResult.returnDisplay).toBe(\n        'First part.\\n[Image: image/jpeg]\\nSecond part.',\n      );\n    });\n\n    it('should ignore unknown content block types', async () => {\n      const params = { param: 'test' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                { type: 'text', text: 'Valid part.' },\n                { type: 'future_block', data: 'some-data' },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([{ text: 'Valid part.' }]);\n      expect(toolResult.returnDisplay).toBe(\n        'Valid part.\\n[Unknown content type: future_block]',\n      );\n    });\n\n    it('should handle a complex mix of content block types', async () => {\n      const params = { param: 'super-complex' };\n      const sdkResponse: Part[] = [\n        {\n          functionResponse: {\n            name: serverToolName,\n            response: {\n              content: [\n                { type: 'text', text: 'Here is a resource.' },\n                {\n                  type: 'resource_link',\n                  uri: 'file:///path/to/resource',\n                  name: 'resource-name',\n                  title: 'My Resource',\n                },\n                {\n                  type: 'resource',\n                  resource: {\n                    uri: 'file:///path/to/text.txt',\n                    text: 'Embedded text content.',\n                    mimeType: 'text/plain',\n                  },\n                },\n                {\n                  type: 'image',\n                  data: 'BASE64_IMAGE_DATA',\n                  mimeType: 'image/jpeg',\n                },\n              ],\n            },\n          },\n        },\n      ];\n      mockCallTool.mockResolvedValue(sdkResponse);\n\n      const invocation = tool.build(params);\n      const toolResult = await invocation.execute(new AbortController().signal);\n\n      expect(toolResult.llmContent).toEqual([\n        { text: 'Here is a resource.' },\n        {\n          text: 'Resource Link: My Resource at file:///path/to/resource',\n        },\n        { text: 'Embedded text content.' },\n        {\n          text: `[Tool '${serverToolName}' provided the following image data with mime-type: image/jpeg]`,\n        },\n        {\n          inlineData: {\n            mimeType: 'image/jpeg',\n            data: 'BASE64_IMAGE_DATA',\n          },\n        },\n      ]);\n      expect(toolResult.returnDisplay).toBe(\n        'Here is a resource.\\n[Link to My Resource: file:///path/to/resource]\\nEmbedded text content.\\n[Image: image/jpeg]',\n      );\n    });\n  });\n\n  describe('shouldConfirmExecute', () => {\n    it('should return false if trust is true', async () => {\n      const trustedTool = new DiscoveredMCPTool(\n        mockCallableToolInstance,\n        serverName,\n        serverToolName,\n        baseDescription,\n        inputSchema,\n        undefined,\n        true,\n      );\n      const invocation = trustedTool.build({ param: 'mock' });\n      expect(\n        await invocation.shouldConfirmExecute(new AbortController().signal),\n      ).toBe(false);\n    });\n\n    it('should return false if server is allowlisted', async () => {\n      const invocation = tool.build({ param: 'mock' }) as any;\n      invocation.constructor.allowlist.add(serverName);\n      expect(\n        await invocation.shouldConfirmExecute(new AbortController().signal),\n      ).toBe(false);\n    });\n\n    it('should return false if tool is allowlisted', async () => {\n      const toolAllowlistKey = `${serverName}.${serverToolName}`;\n      const invocation = tool.build({ param: 'mock' }) as any;\n      invocation.constructor.allowlist.add(toolAllowlistKey);\n      expect(\n        await invocation.shouldConfirmExecute(new AbortController().signal),\n      ).toBe(false);\n    });\n\n    it('should return confirmation details if not trusted and not allowlisted', async () => {\n      const invocation = tool.build({ param: 'mock' });\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).not.toBe(false);\n      if (confirmation && confirmation.type === 'mcp') {\n        // Type guard for ToolMcpConfirmationDetails\n        expect(confirmation.type).toBe('mcp');\n        expect(confirmation.serverName).toBe(serverName);\n        expect(confirmation.toolName).toBe(serverToolName);\n      } else if (confirmation) {\n        // Handle other possible confirmation types if necessary, or strengthen test if only MCP is expected\n        throw new Error(\n          'Confirmation was not of expected type MCP or was false',\n        );\n      } else {\n        throw new Error(\n          'Confirmation details not in expected format or was false',\n        );\n      }\n    });\n\n    it('should add server to allowlist on ProceedAlwaysServer', async () => {\n      const invocation = tool.build({ param: 'mock' }) as any;\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).not.toBe(false);\n      if (\n        confirmation &&\n        typeof confirmation === 'object' &&\n        'onConfirm' in confirmation &&\n        typeof confirmation.onConfirm === 'function'\n      ) {\n        await confirmation.onConfirm(\n          ToolConfirmationOutcome.ProceedAlwaysServer,\n        );\n        expect(invocation.constructor.allowlist.has(serverName)).toBe(true);\n      } else {\n        throw new Error(\n          'Confirmation details or onConfirm not in expected format',\n        );\n      }\n    });\n\n    it('should add tool to allowlist on ProceedAlwaysTool', async () => {\n      const toolAllowlistKey = `${serverName}.${serverToolName}`;\n      const invocation = tool.build({ param: 'mock' }) as any;\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).not.toBe(false);\n      if (\n        confirmation &&\n        typeof confirmation === 'object' &&\n        'onConfirm' in confirmation &&\n        typeof confirmation.onConfirm === 'function'\n      ) {\n        await confirmation.onConfirm(ToolConfirmationOutcome.ProceedAlwaysTool);\n        expect(invocation.constructor.allowlist.has(toolAllowlistKey)).toBe(\n          true,\n        );\n      } else {\n        throw new Error(\n          'Confirmation details or onConfirm not in expected format',\n        );\n      }\n    });\n\n    it('should handle Cancel confirmation outcome', async () => {\n      const invocation = tool.build({ param: 'mock' }) as any;\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).not.toBe(false);\n      if (\n        confirmation &&\n        typeof confirmation === 'object' &&\n        'onConfirm' in confirmation &&\n        typeof confirmation.onConfirm === 'function'\n      ) {\n        // Cancel should not add anything to allowlist\n        await confirmation.onConfirm(ToolConfirmationOutcome.Cancel);\n        expect(invocation.constructor.allowlist.has(serverName)).toBe(false);\n        expect(\n          invocation.constructor.allowlist.has(\n            `${serverName}.${serverToolName}`,\n          ),\n        ).toBe(false);\n      } else {\n        throw new Error(\n          'Confirmation details or onConfirm not in expected format',\n        );\n      }\n    });\n\n    it('should handle ProceedOnce confirmation outcome', async () => {\n      const invocation = tool.build({ param: 'mock' }) as any;\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(confirmation).not.toBe(false);\n      if (\n        confirmation &&\n        typeof confirmation === 'object' &&\n        'onConfirm' in confirmation &&\n        typeof confirmation.onConfirm === 'function'\n      ) {\n        // ProceedOnce should not add anything to allowlist\n        await confirmation.onConfirm(ToolConfirmationOutcome.ProceedOnce);\n        expect(invocation.constructor.allowlist.has(serverName)).toBe(false);\n        expect(\n          invocation.constructor.allowlist.has(\n            `${serverName}.${serverToolName}`,\n          ),\n        ).toBe(false);\n      } else {\n        throw new Error(\n          'Confirmation details or onConfirm not in expected format',\n        );\n      }\n    });\n  });\n\n  describe('DiscoveredMCPToolInvocation', () => {\n    it('should return the stringified params from getDescription', () => {\n      const params = { param: 'testValue', param2: 'anotherOne' };\n      const invocation = tool.build(params);\n      const description = invocation.getDescription();\n      expect(description).toBe('{\"param\":\"testValue\",\"param2\":\"anotherOne\"}');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/mcp-tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/memoryTool.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":305,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11417,11420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11417,11420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13030,13033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13030,13033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":371,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":371,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13948,13951],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13948,13951],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":394,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":394,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14743,14746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14743,14746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { vi, describe, it, expect, beforeEach, afterEach, Mock } from 'vitest';\nimport {\n  MemoryTool,\n  setGeminiMdFilename,\n  getCurrentGeminiMdFilename,\n  getAllGeminiMdFilenames,\n  DEFAULT_CONTEXT_FILENAME,\n} from './memoryTool.js';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as os from 'os';\nimport { ToolConfirmationOutcome } from './tools.js';\nimport { ToolErrorType } from './tool-error.js';\n\n// Mock dependencies\nvi.mock(import('fs/promises'), async (importOriginal) => {\n  const actual = await importOriginal();\n  return {\n    ...actual,\n    mkdir: vi.fn(),\n    readFile: vi.fn(),\n  };\n});\n\nvi.mock('fs', () => ({\n  mkdirSync: vi.fn(),\n}));\n\nvi.mock('os');\n\nconst MEMORY_SECTION_HEADER = '## Gemini Added Memories';\n\n// Define a type for our fsAdapter to ensure consistency\ninterface FsAdapter {\n  readFile: (path: string, encoding: 'utf-8') => Promise<string>;\n  writeFile: (path: string, data: string, encoding: 'utf-8') => Promise<void>;\n  mkdir: (\n    path: string,\n    options: { recursive: boolean },\n  ) => Promise<string | undefined>;\n}\n\ndescribe('MemoryTool', () => {\n  const mockAbortSignal = new AbortController().signal;\n\n  const mockFsAdapter: {\n    readFile: Mock<FsAdapter['readFile']>;\n    writeFile: Mock<FsAdapter['writeFile']>;\n    mkdir: Mock<FsAdapter['mkdir']>;\n  } = {\n    readFile: vi.fn(),\n    writeFile: vi.fn(),\n    mkdir: vi.fn(),\n  };\n\n  beforeEach(() => {\n    vi.mocked(os.homedir).mockReturnValue(path.join('/mock', 'home'));\n    mockFsAdapter.readFile.mockReset();\n    mockFsAdapter.writeFile.mockReset().mockResolvedValue(undefined);\n    mockFsAdapter.mkdir\n      .mockReset()\n      .mockResolvedValue(undefined as string | undefined);\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n    // Reset GEMINI_MD_FILENAME to its original value after each test\n    setGeminiMdFilename(DEFAULT_CONTEXT_FILENAME);\n  });\n\n  describe('setGeminiMdFilename', () => {\n    it('should update currentGeminiMdFilename when a valid new name is provided', () => {\n      const newName = 'CUSTOM_CONTEXT.md';\n      setGeminiMdFilename(newName);\n      expect(getCurrentGeminiMdFilename()).toBe(newName);\n    });\n\n    it('should not update currentGeminiMdFilename if the new name is empty or whitespace', () => {\n      const initialName = getCurrentGeminiMdFilename(); // Get current before trying to change\n      setGeminiMdFilename('  ');\n      expect(getCurrentGeminiMdFilename()).toBe(initialName);\n\n      setGeminiMdFilename('');\n      expect(getCurrentGeminiMdFilename()).toBe(initialName);\n    });\n\n    it('should handle an array of filenames', () => {\n      const newNames = ['CUSTOM_CONTEXT.md', 'ANOTHER_CONTEXT.md'];\n      setGeminiMdFilename(newNames);\n      expect(getCurrentGeminiMdFilename()).toBe('CUSTOM_CONTEXT.md');\n      expect(getAllGeminiMdFilenames()).toEqual(newNames);\n    });\n  });\n\n  describe('performAddMemoryEntry (static method)', () => {\n    let testFilePath: string;\n\n    beforeEach(() => {\n      testFilePath = path.join(\n        os.homedir(),\n        '.gemini',\n        DEFAULT_CONTEXT_FILENAME,\n      );\n    });\n\n    it('should create section and save a fact if file does not exist', async () => {\n      mockFsAdapter.readFile.mockRejectedValue({ code: 'ENOENT' }); // Simulate file not found\n      const fact = 'The sky is blue';\n      await MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter);\n\n      expect(mockFsAdapter.mkdir).toHaveBeenCalledWith(\n        path.dirname(testFilePath),\n        {\n          recursive: true,\n        },\n      );\n      expect(mockFsAdapter.writeFile).toHaveBeenCalledOnce();\n      const writeFileCall = mockFsAdapter.writeFile.mock.calls[0];\n      expect(writeFileCall[0]).toBe(testFilePath);\n      const expectedContent = `${MEMORY_SECTION_HEADER}\\n- ${fact}\\n`;\n      expect(writeFileCall[1]).toBe(expectedContent);\n      expect(writeFileCall[2]).toBe('utf-8');\n    });\n\n    it('should create section and save a fact if file is empty', async () => {\n      mockFsAdapter.readFile.mockResolvedValue(''); // Simulate empty file\n      const fact = 'The sky is blue';\n      await MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter);\n      const writeFileCall = mockFsAdapter.writeFile.mock.calls[0];\n      const expectedContent = `${MEMORY_SECTION_HEADER}\\n- ${fact}\\n`;\n      expect(writeFileCall[1]).toBe(expectedContent);\n    });\n\n    it('should add a fact to an existing section', async () => {\n      const initialContent = `Some preamble.\\n\\n${MEMORY_SECTION_HEADER}\\n- Existing fact 1\\n`;\n      mockFsAdapter.readFile.mockResolvedValue(initialContent);\n      const fact = 'New fact 2';\n      await MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter);\n\n      expect(mockFsAdapter.writeFile).toHaveBeenCalledOnce();\n      const writeFileCall = mockFsAdapter.writeFile.mock.calls[0];\n      const expectedContent = `Some preamble.\\n\\n${MEMORY_SECTION_HEADER}\\n- Existing fact 1\\n- ${fact}\\n`;\n      expect(writeFileCall[1]).toBe(expectedContent);\n    });\n\n    it('should add a fact to an existing empty section', async () => {\n      const initialContent = `Some preamble.\\n\\n${MEMORY_SECTION_HEADER}\\n`; // Empty section\n      mockFsAdapter.readFile.mockResolvedValue(initialContent);\n      const fact = 'First fact in section';\n      await MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter);\n\n      expect(mockFsAdapter.writeFile).toHaveBeenCalledOnce();\n      const writeFileCall = mockFsAdapter.writeFile.mock.calls[0];\n      const expectedContent = `Some preamble.\\n\\n${MEMORY_SECTION_HEADER}\\n- ${fact}\\n`;\n      expect(writeFileCall[1]).toBe(expectedContent);\n    });\n\n    it('should add a fact when other ## sections exist and preserve spacing', async () => {\n      const initialContent = `${MEMORY_SECTION_HEADER}\\n- Fact 1\\n\\n## Another Section\\nSome other text.`;\n      mockFsAdapter.readFile.mockResolvedValue(initialContent);\n      const fact = 'Fact 2';\n      await MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter);\n\n      expect(mockFsAdapter.writeFile).toHaveBeenCalledOnce();\n      const writeFileCall = mockFsAdapter.writeFile.mock.calls[0];\n      // Note: The implementation ensures a single newline at the end if content exists.\n      const expectedContent = `${MEMORY_SECTION_HEADER}\\n- Fact 1\\n- ${fact}\\n\\n## Another Section\\nSome other text.\\n`;\n      expect(writeFileCall[1]).toBe(expectedContent);\n    });\n\n    it('should correctly trim and add a fact that starts with a dash', async () => {\n      mockFsAdapter.readFile.mockResolvedValue(`${MEMORY_SECTION_HEADER}\\n`);\n      const fact = '- - My fact with dashes';\n      await MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter);\n      const writeFileCall = mockFsAdapter.writeFile.mock.calls[0];\n      const expectedContent = `${MEMORY_SECTION_HEADER}\\n- My fact with dashes\\n`;\n      expect(writeFileCall[1]).toBe(expectedContent);\n    });\n\n    it('should handle error from fsAdapter.writeFile', async () => {\n      mockFsAdapter.readFile.mockResolvedValue('');\n      mockFsAdapter.writeFile.mockRejectedValue(new Error('Disk full'));\n      const fact = 'This will fail';\n      await expect(\n        MemoryTool.performAddMemoryEntry(fact, testFilePath, mockFsAdapter),\n      ).rejects.toThrow('[MemoryTool] Failed to add memory entry: Disk full');\n    });\n  });\n\n  describe('execute (instance method)', () => {\n    let memoryTool: MemoryTool;\n    let performAddMemoryEntrySpy: Mock<typeof MemoryTool.performAddMemoryEntry>;\n\n    beforeEach(() => {\n      memoryTool = new MemoryTool();\n      // Spy on the static method for these tests\n      performAddMemoryEntrySpy = vi\n        .spyOn(MemoryTool, 'performAddMemoryEntry')\n        .mockResolvedValue(undefined) as Mock<\n        typeof MemoryTool.performAddMemoryEntry\n      >;\n      // Cast needed as spyOn returns MockInstance\n    });\n\n    it('should have correct name, displayName, description, and schema', () => {\n      expect(memoryTool.name).toBe('save_memory');\n      expect(memoryTool.displayName).toBe('Save Memory');\n      expect(memoryTool.description).toContain(\n        'Saves a specific piece of information',\n      );\n      expect(memoryTool.schema).toBeDefined();\n      expect(memoryTool.schema.name).toBe('save_memory');\n      expect(memoryTool.schema.parametersJsonSchema).toStrictEqual({\n        type: 'object',\n        properties: {\n          fact: {\n            type: 'string',\n            description:\n              'The specific fact or piece of information to remember. Should be a clear, self-contained statement.',\n          },\n        },\n        required: ['fact'],\n      });\n    });\n\n    it('should call performAddMemoryEntry with correct parameters and return success', async () => {\n      const params = { fact: 'The sky is blue' };\n      const invocation = memoryTool.build(params);\n      const result = await invocation.execute(mockAbortSignal);\n      // Use getCurrentGeminiMdFilename for the default expectation before any setGeminiMdFilename calls in a test\n      const expectedFilePath = path.join(\n        os.homedir(),\n        '.gemini',\n        getCurrentGeminiMdFilename(), // This will be DEFAULT_CONTEXT_FILENAME unless changed by a test\n      );\n\n      // For this test, we expect the actual fs methods to be passed\n      const expectedFsArgument = {\n        readFile: fs.readFile,\n        writeFile: fs.writeFile,\n        mkdir: fs.mkdir,\n      };\n\n      expect(performAddMemoryEntrySpy).toHaveBeenCalledWith(\n        params.fact,\n        expectedFilePath,\n        expectedFsArgument,\n      );\n      const successMessage = `Okay, I've remembered that: \"${params.fact}\"`;\n      expect(result.llmContent).toBe(\n        JSON.stringify({ success: true, message: successMessage }),\n      );\n      expect(result.returnDisplay).toBe(successMessage);\n    });\n\n    it('should return an error if fact is empty', async () => {\n      const params = { fact: ' ' }; // Empty fact\n      expect(memoryTool.validateToolParams(params)).toBe(\n        'Parameter \"fact\" must be a non-empty string.',\n      );\n      expect(() => memoryTool.build(params)).toThrow(\n        'Parameter \"fact\" must be a non-empty string.',\n      );\n    });\n\n    it('should handle errors from performAddMemoryEntry', async () => {\n      const params = { fact: 'This will fail' };\n      const underlyingError = new Error(\n        '[MemoryTool] Failed to add memory entry: Disk full',\n      );\n      performAddMemoryEntrySpy.mockRejectedValue(underlyingError);\n\n      const invocation = memoryTool.build(params);\n      const result = await invocation.execute(mockAbortSignal);\n\n      expect(result.llmContent).toBe(\n        JSON.stringify({\n          success: false,\n          error: `Failed to save memory. Detail: ${underlyingError.message}`,\n        }),\n      );\n      expect(result.returnDisplay).toBe(\n        `Error saving memory: ${underlyingError.message}`,\n      );\n      expect(result.error?.type).toBe(\n        ToolErrorType.MEMORY_TOOL_EXECUTION_ERROR,\n      );\n    });\n  });\n\n  describe('shouldConfirmExecute', () => {\n    let memoryTool: MemoryTool;\n\n    beforeEach(() => {\n      memoryTool = new MemoryTool();\n      // Clear the allowlist before each test\n      const invocation = memoryTool.build({ fact: 'mock-fact' });\n       \n      (invocation.constructor as any).allowlist.clear();\n      // Mock fs.readFile to return empty string (file doesn't exist)\n      vi.mocked(fs.readFile).mockResolvedValue('');\n    });\n\n    it('should return confirmation details when memory file is not allowlisted', async () => {\n      const params = { fact: 'Test fact' };\n      const invocation = memoryTool.build(params);\n      const result = await invocation.shouldConfirmExecute(mockAbortSignal);\n\n      expect(result).toBeDefined();\n      expect(result).not.toBe(false);\n\n      if (result && result.type === 'edit') {\n        const expectedPath = path.join('~', '.gemini', 'GEMINI.md');\n        expect(result.title).toBe(`Confirm Memory Save: ${expectedPath}`);\n        expect(result.fileName).toContain(path.join('mock', 'home', '.gemini'));\n        expect(result.fileName).toContain('GEMINI.md');\n        expect(result.fileDiff).toContain('Index: GEMINI.md');\n        expect(result.fileDiff).toContain('+## Gemini Added Memories');\n        expect(result.fileDiff).toContain('+- Test fact');\n        expect(result.originalContent).toBe('');\n        expect(result.newContent).toContain('## Gemini Added Memories');\n        expect(result.newContent).toContain('- Test fact');\n      }\n    });\n\n    it('should return false when memory file is already allowlisted', async () => {\n      const params = { fact: 'Test fact' };\n      const memoryFilePath = path.join(\n        os.homedir(),\n        '.gemini',\n        getCurrentGeminiMdFilename(),\n      );\n\n      const invocation = memoryTool.build(params);\n      // Add the memory file to the allowlist\n       \n      (invocation.constructor as any).allowlist.add(memoryFilePath);\n\n      const result = await invocation.shouldConfirmExecute(mockAbortSignal);\n\n      expect(result).toBe(false);\n    });\n\n    it('should add memory file to allowlist when ProceedAlways is confirmed', async () => {\n      const params = { fact: 'Test fact' };\n      const memoryFilePath = path.join(\n        os.homedir(),\n        '.gemini',\n        getCurrentGeminiMdFilename(),\n      );\n\n      const invocation = memoryTool.build(params);\n      const result = await invocation.shouldConfirmExecute(mockAbortSignal);\n\n      expect(result).toBeDefined();\n      expect(result).not.toBe(false);\n\n      if (result && result.type === 'edit') {\n        // Simulate the onConfirm callback\n        await result.onConfirm(ToolConfirmationOutcome.ProceedAlways);\n\n        // Check that the memory file was added to the allowlist\n        expect(\n           \n          (invocation.constructor as any).allowlist.has(memoryFilePath),\n        ).toBe(true);\n      }\n    });\n\n    it('should not add memory file to allowlist when other outcomes are confirmed', async () => {\n      const params = { fact: 'Test fact' };\n      const memoryFilePath = path.join(\n        os.homedir(),\n        '.gemini',\n        getCurrentGeminiMdFilename(),\n      );\n\n      const invocation = memoryTool.build(params);\n      const result = await invocation.shouldConfirmExecute(mockAbortSignal);\n\n      expect(result).toBeDefined();\n      expect(result).not.toBe(false);\n\n      if (result && result.type === 'edit') {\n        // Simulate the onConfirm callback with different outcomes\n        await result.onConfirm(ToolConfirmationOutcome.ProceedOnce);\n         \n        const allowlist = (invocation.constructor as any).allowlist;\n        expect(allowlist.has(memoryFilePath)).toBe(false);\n\n        await result.onConfirm(ToolConfirmationOutcome.Cancel);\n        expect(allowlist.has(memoryFilePath)).toBe(false);\n      }\n    });\n\n    it('should handle existing memory file with content', async () => {\n      const params = { fact: 'New fact' };\n      const existingContent =\n        'Some existing content.\\n\\n## Gemini Added Memories\\n- Old fact\\n';\n\n      // Mock fs.readFile to return existing content\n      vi.mocked(fs.readFile).mockResolvedValue(existingContent);\n\n      const invocation = memoryTool.build(params);\n      const result = await invocation.shouldConfirmExecute(mockAbortSignal);\n\n      expect(result).toBeDefined();\n      expect(result).not.toBe(false);\n\n      if (result && result.type === 'edit') {\n        const expectedPath = path.join('~', '.gemini', 'GEMINI.md');\n        expect(result.title).toBe(`Confirm Memory Save: ${expectedPath}`);\n        expect(result.fileDiff).toContain('Index: GEMINI.md');\n        expect(result.fileDiff).toContain('+- New fact');\n        expect(result.originalContent).toBe(existingContent);\n        expect(result.newContent).toContain('- Old fact');\n        expect(result.newContent).toContain('- New fact');\n      }\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/memoryTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/modifiable-tool.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/modifiable-tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/read-file.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/read-file.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/read-many-files.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/read-many-files.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/ripGrep.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/ripGrep.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/shell.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":377,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12373,12376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12373,12376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  afterEach,\n  type Mock,\n} from 'vitest';\n\nconst mockShellExecutionService = vi.hoisted(() => vi.fn());\nvi.mock('../services/shellExecutionService.js', () => ({\n  ShellExecutionService: { execute: mockShellExecutionService },\n}));\nvi.mock('fs');\nvi.mock('os');\nvi.mock('crypto');\nvi.mock('../utils/summarizer.js');\n\nimport { isCommandAllowed } from '../utils/shell-utils.js';\nimport { ShellTool } from './shell.js';\nimport { type Config } from '../config/config.js';\nimport {\n  type ShellExecutionResult,\n  type ShellOutputEvent,\n} from '../services/shellExecutionService.js';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { EOL } from 'os';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport * as summarizer from '../utils/summarizer.js';\nimport { ToolConfirmationOutcome } from './tools.js';\nimport { OUTPUT_UPDATE_INTERVAL_MS } from './shell.js';\nimport { createMockWorkspaceContext } from '../test-utils/mockWorkspaceContext.js';\n\ndescribe('ShellTool', () => {\n  let shellTool: ShellTool;\n  let mockConfig: Config;\n  let mockShellOutputCallback: (event: ShellOutputEvent) => void;\n  let resolveExecutionPromise: (result: ShellExecutionResult) => void;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n\n    mockConfig = {\n      getCoreTools: vi.fn().mockReturnValue([]),\n      getExcludeTools: vi.fn().mockReturnValue([]),\n      getDebugMode: vi.fn().mockReturnValue(false),\n      getTargetDir: vi.fn().mockReturnValue('/test/dir'),\n      getSummarizeToolOutputConfig: vi.fn().mockReturnValue(undefined),\n      getWorkspaceContext: () => createMockWorkspaceContext('.'),\n      getGeminiClient: vi.fn(),\n      getShouldUseNodePtyShell: vi.fn().mockReturnValue(false),\n    } as unknown as Config;\n\n    shellTool = new ShellTool(mockConfig);\n\n    vi.mocked(os.platform).mockReturnValue('linux');\n    vi.mocked(os.tmpdir).mockReturnValue('/tmp');\n    (vi.mocked(crypto.randomBytes) as Mock).mockReturnValue(\n      Buffer.from('abcdef', 'hex'),\n    );\n\n    // Capture the output callback to simulate streaming events from the service\n    mockShellExecutionService.mockImplementation((_cmd, _cwd, callback) => {\n      mockShellOutputCallback = callback;\n      return {\n        pid: 12345,\n        result: new Promise((resolve) => {\n          resolveExecutionPromise = resolve;\n        }),\n      };\n    });\n  });\n\n  describe('isCommandAllowed', () => {\n    it('should allow a command if no restrictions are provided', () => {\n      (mockConfig.getCoreTools as Mock).mockReturnValue(undefined);\n      (mockConfig.getExcludeTools as Mock).mockReturnValue(undefined);\n      expect(isCommandAllowed('ls -l', mockConfig).allowed).toBe(true);\n    });\n\n    it('should block a command with command substitution using $()', () => {\n      expect(isCommandAllowed('echo $(rm -rf /)', mockConfig).allowed).toBe(\n        false,\n      );\n    });\n  });\n\n  describe('build', () => {\n    it('should return an invocation for a valid command', () => {\n      const invocation = shellTool.build({ command: 'ls -l' });\n      expect(invocation).toBeDefined();\n    });\n\n    it('should throw an error for an empty command', () => {\n      expect(() => shellTool.build({ command: ' ' })).toThrow(\n        'Command cannot be empty.',\n      );\n    });\n\n    it('should throw an error for a non-existent directory', () => {\n      vi.mocked(fs.existsSync).mockReturnValue(false);\n      expect(() =>\n        shellTool.build({ command: 'ls', directory: 'rel/path' }),\n      ).toThrow(\n        \"Directory 'rel/path' is not a registered workspace directory.\",\n      );\n    });\n  });\n\n  describe('execute', () => {\n    const mockAbortSignal = new AbortController().signal;\n\n    const resolveShellExecution = (\n      result: Partial<ShellExecutionResult> = {},\n    ) => {\n      const fullResult: ShellExecutionResult = {\n        rawOutput: Buffer.from(result.output || ''),\n        output: 'Success',\n        exitCode: 0,\n        signal: null,\n        error: null,\n        aborted: false,\n        pid: 12345,\n        executionMethod: 'child_process',\n        ...result,\n      };\n      resolveExecutionPromise(fullResult);\n    };\n\n    it('should wrap command on linux and parse pgrep output', async () => {\n      const invocation = shellTool.build({ command: 'my-command &' });\n      const promise = invocation.execute(mockAbortSignal);\n      resolveShellExecution({ pid: 54321 });\n\n      vi.mocked(fs.existsSync).mockReturnValue(true);\n      vi.mocked(fs.readFileSync).mockReturnValue(`54321${EOL}54322${EOL}`); // Service PID and background PID\n\n      const result = await promise;\n\n      const tmpFile = path.join(os.tmpdir(), 'shell_pgrep_abcdef.tmp');\n      const wrappedCommand = `{ my-command & }; __code=$?; pgrep -g 0 >${tmpFile} 2>&1; exit $__code;`;\n      expect(mockShellExecutionService).toHaveBeenCalledWith(\n        wrappedCommand,\n        expect.any(String),\n        expect.any(Function),\n        mockAbortSignal,\n        false,\n        undefined,\n        undefined,\n      );\n      expect(result.llmContent).toContain('Background PIDs: 54322');\n      expect(vi.mocked(fs.unlinkSync)).toHaveBeenCalledWith(tmpFile);\n    });\n\n    it('should not wrap command on windows', async () => {\n      vi.mocked(os.platform).mockReturnValue('win32');\n      const invocation = shellTool.build({ command: 'dir' });\n      const promise = invocation.execute(mockAbortSignal);\n      resolveShellExecution({\n        rawOutput: Buffer.from(''),\n        output: '',\n        exitCode: 0,\n        signal: null,\n        error: null,\n        aborted: false,\n        pid: 12345,\n        executionMethod: 'child_process',\n      });\n      await promise;\n      expect(mockShellExecutionService).toHaveBeenCalledWith(\n        'dir',\n        expect.any(String),\n        expect.any(Function),\n        mockAbortSignal,\n        false,\n        undefined,\n        undefined,\n      );\n    });\n\n    it('should format error messages correctly', async () => {\n      const error = new Error('wrapped command failed');\n      const invocation = shellTool.build({ command: 'user-command' });\n      const promise = invocation.execute(mockAbortSignal);\n      resolveShellExecution({\n        error,\n        exitCode: 1,\n        output: 'err',\n        rawOutput: Buffer.from('err'),\n        signal: null,\n        aborted: false,\n        pid: 12345,\n        executionMethod: 'child_process',\n      });\n\n      const result = await promise;\n      expect(result.llmContent).toContain('Error: wrapped command failed');\n      expect(result.llmContent).not.toContain('pgrep');\n    });\n\n    it('should throw an error for invalid parameters', () => {\n      expect(() => shellTool.build({ command: '' })).toThrow(\n        'Command cannot be empty.',\n      );\n    });\n\n    it('should throw an error for invalid directory', () => {\n      vi.mocked(fs.existsSync).mockReturnValue(false);\n      expect(() =>\n        shellTool.build({ command: 'ls', directory: 'nonexistent' }),\n      ).toThrow(\n        `Directory 'nonexistent' is not a registered workspace directory.`,\n      );\n    });\n\n    it('should summarize output when configured', async () => {\n      (mockConfig.getSummarizeToolOutputConfig as Mock).mockReturnValue({\n        [shellTool.name]: { tokenBudget: 1000 },\n      });\n      vi.mocked(summarizer.summarizeToolOutput).mockResolvedValue(\n        'summarized output',\n      );\n\n      const invocation = shellTool.build({ command: 'ls' });\n      const promise = invocation.execute(mockAbortSignal);\n      resolveExecutionPromise({\n        output: 'long output',\n        rawOutput: Buffer.from('long output'),\n        exitCode: 0,\n        signal: null,\n        error: null,\n        aborted: false,\n        pid: 12345,\n        executionMethod: 'child_process',\n      });\n\n      const result = await promise;\n\n      expect(summarizer.summarizeToolOutput).toHaveBeenCalledWith(\n        expect.any(String),\n        mockConfig.getGeminiClient(),\n        mockAbortSignal,\n        1000,\n      );\n      expect(result.llmContent).toBe('summarized output');\n      expect(result.returnDisplay).toBe('long output');\n    });\n\n    it('should clean up the temp file on synchronous execution error', async () => {\n      const error = new Error('sync spawn error');\n      mockShellExecutionService.mockImplementation(() => {\n        throw error;\n      });\n      vi.mocked(fs.existsSync).mockReturnValue(true); // Pretend the file exists\n\n      const invocation = shellTool.build({ command: 'a-command' });\n      await expect(invocation.execute(mockAbortSignal)).rejects.toThrow(error);\n\n      const tmpFile = path.join(os.tmpdir(), 'shell_pgrep_abcdef.tmp');\n      expect(vi.mocked(fs.unlinkSync)).toHaveBeenCalledWith(tmpFile);\n    });\n\n    describe('Streaming to `updateOutput`', () => {\n      let updateOutputMock: Mock;\n      beforeEach(() => {\n        vi.useFakeTimers({ toFake: ['Date'] });\n        updateOutputMock = vi.fn();\n      });\n      afterEach(() => {\n        vi.useRealTimers();\n      });\n\n      it('should throttle text output updates', async () => {\n        const invocation = shellTool.build({ command: 'stream' });\n        const promise = invocation.execute(mockAbortSignal, updateOutputMock);\n\n        // First chunk, should be throttled.\n        mockShellOutputCallback({\n          type: 'data',\n          chunk: 'hello ',\n        });\n        expect(updateOutputMock).not.toHaveBeenCalled();\n\n        // Advance time past the throttle interval.\n        await vi.advanceTimersByTimeAsync(OUTPUT_UPDATE_INTERVAL_MS + 1);\n\n        // Send a second chunk. THIS event triggers the update with the CUMULATIVE content.\n        mockShellOutputCallback({\n          type: 'data',\n          chunk: 'hello world',\n        });\n\n        // It should have been called once now with the combined output.\n        expect(updateOutputMock).toHaveBeenCalledOnce();\n        expect(updateOutputMock).toHaveBeenCalledWith('hello world');\n\n        resolveExecutionPromise({\n          rawOutput: Buffer.from(''),\n          output: '',\n          exitCode: 0,\n          signal: null,\n          error: null,\n          aborted: false,\n          pid: 12345,\n          executionMethod: 'child_process',\n        });\n        await promise;\n      });\n\n      it('should immediately show binary detection message and throttle progress', async () => {\n        const invocation = shellTool.build({ command: 'cat img' });\n        const promise = invocation.execute(mockAbortSignal, updateOutputMock);\n\n        mockShellOutputCallback({ type: 'binary_detected' });\n        expect(updateOutputMock).toHaveBeenCalledOnce();\n        expect(updateOutputMock).toHaveBeenCalledWith(\n          '[Binary output detected. Halting stream...]',\n        );\n\n        mockShellOutputCallback({\n          type: 'binary_progress',\n          bytesReceived: 1024,\n        });\n        expect(updateOutputMock).toHaveBeenCalledOnce();\n\n        // Advance time past the throttle interval.\n        await vi.advanceTimersByTimeAsync(OUTPUT_UPDATE_INTERVAL_MS + 1);\n\n        // Send a SECOND progress event. This one will trigger the flush.\n        mockShellOutputCallback({\n          type: 'binary_progress',\n          bytesReceived: 2048,\n        });\n\n        // Now it should be called a second time with the latest progress.\n        expect(updateOutputMock).toHaveBeenCalledTimes(2);\n        expect(updateOutputMock).toHaveBeenLastCalledWith(\n          '[Receiving binary output... 2.0 KB received]',\n        );\n\n        resolveExecutionPromise({\n          rawOutput: Buffer.from(''),\n          output: '',\n          exitCode: 0,\n          signal: null,\n          error: null,\n          aborted: false,\n          pid: 12345,\n          executionMethod: 'child_process',\n        });\n        await promise;\n      });\n    });\n  });\n\n  describe('shouldConfirmExecute', () => {\n    it('should request confirmation for a new command and whitelist it on \"Always\"', async () => {\n      const params = { command: 'npm install' };\n      const invocation = shellTool.build(params);\n      const confirmation = await invocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n\n      expect(confirmation).not.toBe(false);\n      expect(confirmation && confirmation.type).toBe('exec');\n\n       \n      await (confirmation as any).onConfirm(\n        ToolConfirmationOutcome.ProceedAlways,\n      );\n\n      // Should now be whitelisted\n      const secondInvocation = shellTool.build({ command: 'npm test' });\n      const secondConfirmation = await secondInvocation.shouldConfirmExecute(\n        new AbortController().signal,\n      );\n      expect(secondConfirmation).toBe(false);\n    });\n\n    it('should throw an error if validation fails', () => {\n      expect(() => shellTool.build({ command: '' })).toThrow();\n    });\n  });\n\n  describe('getDescription', () => {\n    it('should return the windows description when on windows', () => {\n      vi.mocked(os.platform).mockReturnValue('win32');\n      const shellTool = new ShellTool(mockConfig);\n      expect(shellTool.description).toMatchSnapshot();\n    });\n\n    it('should return the non-windows description when not on windows', () => {\n      vi.mocked(os.platform).mockReturnValue('linux');\n      const shellTool = new ShellTool(mockConfig);\n      expect(shellTool.description).toMatchSnapshot();\n    });\n  });\n});\n\ndescribe('build', () => {\n  it('should return an invocation for valid directory', () => {\n    const config = {\n      getCoreTools: () => undefined,\n      getExcludeTools: () => undefined,\n      getTargetDir: () => '/root',\n      getWorkspaceContext: () =>\n        createMockWorkspaceContext('/root', ['/users/test']),\n    } as unknown as Config;\n    const shellTool = new ShellTool(config);\n    const invocation = shellTool.build({\n      command: 'ls',\n      directory: 'test',\n    });\n    expect(invocation).toBeDefined();\n  });\n\n  it('should throw an error for directory outside workspace', () => {\n    const config = {\n      getCoreTools: () => undefined,\n      getExcludeTools: () => undefined,\n      getTargetDir: () => '/root',\n      getWorkspaceContext: () =>\n        createMockWorkspaceContext('/root', ['/users/test']),\n    } as unknown as Config;\n    const shellTool = new ShellTool(config);\n    expect(() =>\n      shellTool.build({\n        command: 'ls',\n        directory: 'test2',\n      }),\n    ).toThrow('is not a registered workspace directory');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/shell.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/tool-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/tool-registry.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1528,1531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1528,1531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":148,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4316,4319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4316,4319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8421,8424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8421,8424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":286,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8805,8808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8805,8808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":294,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9022,9025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9022,9025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":336,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10364,10367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10364,10367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":367,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11353,11356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11353,11356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \nimport {\n  describe,\n  it,\n  expect,\n  vi,\n  beforeEach,\n  afterEach,\n  Mocked,\n} from 'vitest';\nimport { Config, ConfigParameters, ApprovalMode } from '../config/config.js';\nimport { ToolRegistry, DiscoveredTool } from './tool-registry.js';\nimport { DiscoveredMCPTool } from './mcp-tool.js';\nimport { FunctionDeclaration, CallableTool, mcpToTool } from '@google/genai';\nimport { spawn } from 'node:child_process';\n\nimport fs from 'node:fs';\nimport { MockTool } from '../test-utils/tools.js';\n\nimport { McpClientManager } from './mcp-client-manager.js';\nimport { ToolErrorType } from './tool-error.js';\n\nvi.mock('node:fs');\n\n// Mock ./mcp-client.js to control its behavior within tool-registry tests\nvi.mock('./mcp-client.js', async () => {\n  const originalModule = await vi.importActual('./mcp-client.js');\n  return {\n    ...originalModule,\n  };\n});\n\n// Mock node:child_process\nvi.mock('node:child_process', async () => {\n  const actual = await vi.importActual('node:child_process');\n  return {\n    ...actual,\n    execSync: vi.fn(),\n    spawn: vi.fn(),\n  };\n});\n\n// Mock MCP SDK Client and Transports\nconst mockMcpClientConnect = vi.fn();\nconst mockMcpClientOnError = vi.fn();\nconst mockStdioTransportClose = vi.fn();\nconst mockSseTransportClose = vi.fn();\n\nvi.mock('@modelcontextprotocol/sdk/client/index.js', () => {\n  const MockClient = vi.fn().mockImplementation(() => ({\n    connect: mockMcpClientConnect,\n    set onerror(handler: any) {\n      mockMcpClientOnError(handler);\n    },\n  }));\n  return { Client: MockClient };\n});\n\nvi.mock('@modelcontextprotocol/sdk/client/stdio.js', () => {\n  const MockStdioClientTransport = vi.fn().mockImplementation(() => ({\n    stderr: {\n      on: vi.fn(),\n    },\n    close: mockStdioTransportClose,\n  }));\n  return { StdioClientTransport: MockStdioClientTransport };\n});\n\nvi.mock('@modelcontextprotocol/sdk/client/sse.js', () => {\n  const MockSSEClientTransport = vi.fn().mockImplementation(() => ({\n    close: mockSseTransportClose,\n  }));\n  return { SSEClientTransport: MockSSEClientTransport };\n});\n\n// Mock @google/genai mcpToTool\nvi.mock('@google/genai', async () => {\n  const actualGenai =\n    await vi.importActual<typeof import('@google/genai')>('@google/genai');\n  return {\n    ...actualGenai,\n    mcpToTool: vi.fn().mockImplementation(() => ({\n      tool: vi.fn().mockResolvedValue({ functionDeclarations: [] }),\n      callTool: vi.fn(),\n    })),\n  };\n});\n\n// Helper to create a mock CallableTool for specific test needs\nconst createMockCallableTool = (\n  toolDeclarations: FunctionDeclaration[],\n): Mocked<CallableTool> => ({\n  tool: vi.fn().mockResolvedValue({ functionDeclarations: toolDeclarations }),\n  callTool: vi.fn(),\n});\n\nconst baseConfigParams: ConfigParameters = {\n  cwd: '/tmp',\n  model: 'test-model',\n  embeddingModel: 'test-embedding-model',\n  sandbox: undefined,\n  targetDir: '/test/dir',\n  debugMode: false,\n  userMemory: '',\n  geminiMdFileCount: 0,\n  approvalMode: ApprovalMode.DEFAULT,\n  sessionId: 'test-session-id',\n};\n\ndescribe('ToolRegistry', () => {\n  let config: Config;\n  let toolRegistry: ToolRegistry;\n  let mockConfigGetToolDiscoveryCommand: ReturnType<typeof vi.spyOn>;\n\n  beforeEach(() => {\n    vi.mocked(fs.existsSync).mockReturnValue(true);\n    vi.mocked(fs.statSync).mockReturnValue({\n      isDirectory: () => true,\n    } as fs.Stats);\n    config = new Config(baseConfigParams);\n    toolRegistry = new ToolRegistry(config);\n    vi.spyOn(console, 'warn').mockImplementation(() => {});\n    vi.spyOn(console, 'error').mockImplementation(() => {});\n    vi.spyOn(console, 'debug').mockImplementation(() => {});\n    vi.spyOn(console, 'log').mockImplementation(() => {});\n\n    mockMcpClientConnect.mockReset().mockResolvedValue(undefined);\n    mockStdioTransportClose.mockReset();\n    mockSseTransportClose.mockReset();\n    vi.mocked(mcpToTool).mockClear();\n    vi.mocked(mcpToTool).mockReturnValue(createMockCallableTool([]));\n\n    mockConfigGetToolDiscoveryCommand = vi.spyOn(\n      config,\n      'getToolDiscoveryCommand',\n    );\n    vi.spyOn(config, 'getMcpServers');\n    vi.spyOn(config, 'getMcpServerCommand');\n    vi.spyOn(config, 'getPromptRegistry').mockReturnValue({\n      clear: vi.fn(),\n      removePromptsByServer: vi.fn(),\n    } as any);\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('registerTool', () => {\n    it('should register a new tool', () => {\n      const tool = new MockTool();\n      toolRegistry.registerTool(tool);\n      expect(toolRegistry.getTool('mock-tool')).toBe(tool);\n    });\n  });\n\n  describe('getAllTools', () => {\n    it('should return all registered tools sorted alphabetically by displayName', () => {\n      // Register tools with displayNames in non-alphabetical order\n      const toolC = new MockTool('c-tool', 'Tool C');\n      const toolA = new MockTool('a-tool', 'Tool A');\n      const toolB = new MockTool('b-tool', 'Tool B');\n\n      toolRegistry.registerTool(toolC);\n      toolRegistry.registerTool(toolA);\n      toolRegistry.registerTool(toolB);\n\n      const allTools = toolRegistry.getAllTools();\n      const displayNames = allTools.map((t) => t.displayName);\n\n      // Assert that the returned array is sorted by displayName\n      expect(displayNames).toEqual(['Tool A', 'Tool B', 'Tool C']);\n    });\n  });\n\n  describe('getToolsByServer', () => {\n    it('should return an empty array if no tools match the server name', () => {\n      toolRegistry.registerTool(new MockTool());\n      expect(toolRegistry.getToolsByServer('any-mcp-server')).toEqual([]);\n    });\n\n    it('should return only tools matching the server name, sorted by name', async () => {\n      const server1Name = 'mcp-server-uno';\n      const server2Name = 'mcp-server-dos';\n      const mockCallable = {} as CallableTool;\n      const mcpTool1_c = new DiscoveredMCPTool(\n        mockCallable,\n        server1Name,\n        'zebra-tool',\n        'd1',\n        {},\n      );\n      const mcpTool1_a = new DiscoveredMCPTool(\n        mockCallable,\n        server1Name,\n        'apple-tool',\n        'd2',\n        {},\n      );\n      const mcpTool1_b = new DiscoveredMCPTool(\n        mockCallable,\n        server1Name,\n        'banana-tool',\n        'd3',\n        {},\n      );\n\n      const mcpTool2 = new DiscoveredMCPTool(\n        mockCallable,\n        server2Name,\n        'tool-on-server2',\n        'd4',\n        {},\n      );\n      const nonMcpTool = new MockTool('regular-tool');\n\n      toolRegistry.registerTool(mcpTool1_c);\n      toolRegistry.registerTool(mcpTool1_a);\n      toolRegistry.registerTool(mcpTool1_b);\n      toolRegistry.registerTool(mcpTool2);\n      toolRegistry.registerTool(nonMcpTool);\n\n      const toolsFromServer1 = toolRegistry.getToolsByServer(server1Name);\n      const toolNames = toolsFromServer1.map((t) => t.name);\n\n      // Assert that the array has the correct tools and is sorted by name\n      expect(toolsFromServer1).toHaveLength(3);\n      expect(toolNames).toEqual(['apple-tool', 'banana-tool', 'zebra-tool']);\n\n      // Assert that all returned tools are indeed from the correct server\n      for (const tool of toolsFromServer1) {\n        expect((tool as DiscoveredMCPTool).serverName).toBe(server1Name);\n      }\n\n      // Assert that the other server's tools are returned correctly\n      const toolsFromServer2 = toolRegistry.getToolsByServer(server2Name);\n      expect(toolsFromServer2).toHaveLength(1);\n      expect(toolsFromServer2[0].name).toBe(mcpTool2.name);\n    });\n  });\n\n  describe('discoverTools', () => {\n    it('should will preserve tool parametersJsonSchema during discovery from command', async () => {\n      const discoveryCommand = 'my-discovery-command';\n      mockConfigGetToolDiscoveryCommand.mockReturnValue(discoveryCommand);\n\n      const unsanitizedToolDeclaration: FunctionDeclaration = {\n        name: 'tool-with-bad-format',\n        description: 'A tool with an invalid format property',\n        parametersJsonSchema: {\n          type: 'object',\n          properties: {\n            some_string: {\n              type: 'string',\n              format: 'uuid', // This is an unsupported format\n            },\n          },\n        },\n      };\n\n      const mockSpawn = vi.mocked(spawn);\n      const mockChildProcess = {\n        stdout: { on: vi.fn() },\n        stderr: { on: vi.fn() },\n        on: vi.fn(),\n      };\n      mockSpawn.mockReturnValue(mockChildProcess as any);\n\n      // Simulate stdout data\n      mockChildProcess.stdout.on.mockImplementation((event, callback) => {\n        if (event === 'data') {\n          callback(\n            Buffer.from(\n              JSON.stringify([\n                { function_declarations: [unsanitizedToolDeclaration] },\n              ]),\n            ),\n          );\n        }\n        return mockChildProcess as any;\n      });\n\n      // Simulate process close\n      mockChildProcess.on.mockImplementation((event, callback) => {\n        if (event === 'close') {\n          callback(0);\n        }\n        return mockChildProcess as any;\n      });\n\n      await toolRegistry.discoverAllTools();\n\n      const discoveredTool = toolRegistry.getTool('tool-with-bad-format');\n      expect(discoveredTool).toBeDefined();\n\n      const registeredParams = (discoveredTool as DiscoveredTool).schema\n        .parametersJsonSchema;\n      expect(registeredParams).toStrictEqual({\n        type: 'object',\n        properties: {\n          some_string: {\n            type: 'string',\n            format: 'uuid',\n          },\n        },\n      });\n    });\n\n    it('should return a DISCOVERED_TOOL_EXECUTION_ERROR on tool failure', async () => {\n      const discoveryCommand = 'my-discovery-command';\n      mockConfigGetToolDiscoveryCommand.mockReturnValue(discoveryCommand);\n      vi.spyOn(config, 'getToolCallCommand').mockReturnValue('my-call-command');\n\n      const toolDeclaration: FunctionDeclaration = {\n        name: 'failing-tool',\n        description: 'A tool that fails',\n        parametersJsonSchema: {\n          type: 'object',\n          properties: {},\n        },\n      };\n\n      const mockSpawn = vi.mocked(spawn);\n      // --- Discovery Mock ---\n      const discoveryProcess = {\n        stdout: { on: vi.fn(), removeListener: vi.fn() },\n        stderr: { on: vi.fn(), removeListener: vi.fn() },\n        on: vi.fn(),\n      };\n      mockSpawn.mockReturnValueOnce(discoveryProcess as any);\n\n      discoveryProcess.stdout.on.mockImplementation((event, callback) => {\n        if (event === 'data') {\n          callback(\n            Buffer.from(\n              JSON.stringify([{ functionDeclarations: [toolDeclaration] }]),\n            ),\n          );\n        }\n      });\n      discoveryProcess.on.mockImplementation((event, callback) => {\n        if (event === 'close') {\n          callback(0);\n        }\n      });\n\n      await toolRegistry.discoverAllTools();\n      const discoveredTool = toolRegistry.getTool('failing-tool');\n      expect(discoveredTool).toBeDefined();\n\n      // --- Execution Mock ---\n      const executionProcess = {\n        stdout: { on: vi.fn(), removeListener: vi.fn() },\n        stderr: { on: vi.fn(), removeListener: vi.fn() },\n        stdin: { write: vi.fn(), end: vi.fn() },\n        on: vi.fn(),\n        connected: true,\n        disconnect: vi.fn(),\n        removeListener: vi.fn(),\n      };\n      mockSpawn.mockReturnValueOnce(executionProcess as any);\n\n      executionProcess.stderr.on.mockImplementation((event, callback) => {\n        if (event === 'data') {\n          callback(Buffer.from('Something went wrong'));\n        }\n      });\n      executionProcess.on.mockImplementation((event, callback) => {\n        if (event === 'close') {\n          callback(1); // Non-zero exit code\n        }\n      });\n\n      const invocation = (discoveredTool as DiscoveredTool).build({});\n      const result = await invocation.execute(new AbortController().signal);\n\n      expect(result.error?.type).toBe(\n        ToolErrorType.DISCOVERED_TOOL_EXECUTION_ERROR,\n      );\n      expect(result.llmContent).toContain('Stderr: Something went wrong');\n      expect(result.llmContent).toContain('Exit Code: 1');\n    });\n\n    it('should discover tools using MCP servers defined in getMcpServers', async () => {\n      const discoverSpy = vi.spyOn(\n        McpClientManager.prototype,\n        'discoverAllMcpTools',\n      );\n      mockConfigGetToolDiscoveryCommand.mockReturnValue(undefined);\n      vi.spyOn(config, 'getMcpServerCommand').mockReturnValue(undefined);\n      const mcpServerConfigVal = {\n        'my-mcp-server': {\n          command: 'mcp-server-cmd',\n          args: ['--port', '1234'],\n          trust: true,\n        },\n      };\n      vi.spyOn(config, 'getMcpServers').mockReturnValue(mcpServerConfigVal);\n\n      await toolRegistry.discoverAllTools();\n\n      expect(discoverSpy).toHaveBeenCalled();\n    });\n  });\n\n  describe('DiscoveredToolInvocation', () => {\n    it('should return the stringified params from getDescription', () => {\n      const tool = new DiscoveredTool(config, 'test-tool', 'A test tool', {});\n      const params = { param: 'testValue' };\n      const invocation = tool.build(params);\n      const description = invocation.getDescription();\n      expect(description).toBe(JSON.stringify(params));\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/tool-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/upsert_code_block.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[525,528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[525,528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[655,658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[655,658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[725,728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[725,728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[734,737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[734,737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[744,747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[744,747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1049,1052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1049,1052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1159,1162],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1159,1162],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1167,1170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1167,1170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1246,1249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1246,1249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { describe, it, expect, vi } from 'vitest';\nimport { UpsertCodeBlockTool } from './upsert_code_block.js';\n\n// Mock fs and ast adapter to avoid real file IO and ts-morph\nvi.mock('fs', () => ({\n  existsSync: (_p: string) => true,\n  readFileSync: (_p: string) => 'const a = 1;',\n  writeFileSync: (_p: string, _c: string) => {},\n}));\nvi.mock('../ast/adapter.js', () => ({\n  createProject: () => ({}),\n  parseFileWithProject: (_proj: any, _filePath: string) => ({ sourceFile: { getText: () => 'const a = 1;' }, text: 'const a = 1;' }),\n  dumpSourceFileText: (_sf: any) => 'const a = 2;'\n}));\nvi.mock('diff', () => ({ createPatch: (_: any, __: any, ___: any) => 'patch' }));\n\ndescribe('UpsertCodeBlockTool (unit)', () => {\n  it('inserts or updates a simple JS block (preview)', async () => {\n    const params = {\n      file_path: '/tmp/foo.ts',\n      block_name: 'a',\n      content: 'const a = 2;',\n      block_type: 'variable',\n      preview: true,\n    } as any;\n\n  const tool = new UpsertCodeBlockTool();\n   \n  const inv = (tool as unknown as { createInvocation: (p: any) => any }).createInvocation(params);\n   \n  const abortSignal = (new (globalThis as any).AbortController()).signal;\n  const res = await inv.execute(abortSignal);\n    expect(res.llmContent).toBeDefined();\n    expect(res.returnDisplay).toBeDefined();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/upsert_code_block.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":508,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":508,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14783,14786],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14783,14786],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Diff from 'diff';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { SourceFile, Node } from 'ts-morph';\nimport * as astAdapter from '../ast/adapter.js';\nimport { DEFAULT_DIFF_OPTIONS, getDiffStat } from './diffOptions.js';\nimport {\n  BaseDeclarativeTool,\n  BaseToolInvocation,\n  Kind,\n  ToolInvocation,\n  ToolResult,\n  ToolResultDisplay,\n} from './tools.js';\n\n/**\n * Parameters for the UpsertCodeBlock tool.\n */\nexport interface UpsertCodeBlockToolParams {\n  /**\n   * The absolute path to the file to modify.\n   */\n  file_path: string;\n\n  /**\n   * The name of the block (e.g., function, class, const) to find.\n   */\n  block_name: string;\n\n  /**\n   * The new content for the block.\n   */\n  content: string;\n\n  /**\n   * The type of block to upsert (function, class, variable, interface, type).\n   * If not specified, will auto-detect from content.\n   */\n  block_type?:\n    | 'function'\n    | 'class'\n    | 'variable'\n    | 'interface'\n    | 'type'\n    | 'auto';\n\n  /**\n   * Position preference for new blocks: 'top', 'bottom', 'after_imports', 'before_exports'.\n   * Default: 'bottom'\n   */\n  insert_position?: 'top' | 'bottom' | 'after_imports' | 'before_exports';\n\n  /**\n   * Whether to preserve existing formatting and comments around the block.\n   * Default: true\n   */\n  preserve_formatting?: boolean;\n}\n\ninterface BlockInfo {\n  name: string;\n  type: 'function' | 'class' | 'variable' | 'interface' | 'type';\n  node: Node;\n  startLine: number;\n  endLine: number;\n}\n\nclass UpsertCodeBlockToolInvocation extends BaseToolInvocation<\n  UpsertCodeBlockToolParams,\n  ToolResult\n> {\n  constructor(params: UpsertCodeBlockToolParams) {\n    super(params);\n  }\n\n  getDescription(): string {\n    return `Upserting ${this.params.block_type || 'auto-detected'} block '${this.params.block_name}' in ${this.params.file_path}`;\n  }\n\n  async execute(_abortSignal: AbortSignal): Promise<ToolResult> {\n    try {\n      // Validate parameters\n      const validation = this.validateParams();\n      if (!validation.isValid) {\n        return {\n          llmContent: `Parameter validation failed: ${validation.error}`,\n          returnDisplay: ` Error: ${validation.error}`,\n        };\n      }\n\n      // Check if file exists and is readable\n      if (!fs.existsSync(this.params.file_path)) {\n        return {\n          llmContent: `File not found: ${this.params.file_path}`,\n          returnDisplay: ` File not found: ${this.params.file_path}`,\n        };\n      }\n\n      // Determine file type and use appropriate parser\n      const fileExtension = path.extname(this.params.file_path).toLowerCase();\n\n      if (fileExtension === '.py') {\n        return await this.handlePythonFile();\n      } else if (['.ts', '.js', '.tsx', '.jsx'].includes(fileExtension)) {\n        return await this.handleTypeScriptFile();\n      } else {\n        return await this.handlePlainTextFile();\n      }\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return {\n        llmContent: `Execution failed: ${errorMessage}`,\n        returnDisplay: ` Execution failed: ${errorMessage}`,\n      };\n    }\n  }\n\n  private validateParams(): { isValid: boolean; error?: string } {\n    if (!this.params.file_path || !path.isAbsolute(this.params.file_path)) {\n      return { isValid: false, error: 'file_path must be an absolute path' };\n    }\n\n    if (!this.params.block_name || this.params.block_name.trim().length === 0) {\n      return { isValid: false, error: 'block_name cannot be empty' };\n    }\n\n    if (!this.params.content || this.params.content.trim().length === 0) {\n      return { isValid: false, error: 'content cannot be empty' };\n    }\n\n    // Validate block_name doesn't contain invalid characters\n    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(this.params.block_name)) {\n      return { isValid: false, error: 'block_name must be a valid identifier' };\n    }\n\n    return { isValid: true };\n  }\n\n  private async handlePythonFile(): Promise<ToolResult> {\n    // For Python files, use string-based parsing since ts-morph doesn't support Python\n    try {\n      const originalContent = fs.readFileSync(this.params.file_path, 'utf-8');\n      const lines = originalContent.split('\\n');\n\n      const blockInfo = this.findPythonBlock(lines);\n      const blockType =\n        this.params.block_type ||\n        this.detectPythonBlockType(this.params.content);\n\n      let newContent: string;\n      let operation: string;\n\n      if (blockInfo) {\n        // Replace existing block\n        newContent = this.replacePythonBlock(\n          lines,\n          blockInfo,\n          this.params.content,\n        );\n        operation = 'updated';\n      } else {\n        // Insert new block\n        newContent = this.insertPythonBlock(lines, this.params.content);\n        operation = 'inserted';\n      }\n\n      // Write back to file\n      fs.writeFileSync(this.params.file_path, newContent, 'utf-8');\n\n      const message = `Successfully ${operation} ${blockType} '${this.params.block_name}' in ${this.params.file_path}`;\n\n      const fileName = path.basename(this.params.file_path);\n      const fileDiff = Diff.createPatch(\n        fileName,\n        originalContent,\n        newContent,\n        'Current',\n        'Proposed',\n        DEFAULT_DIFF_OPTIONS,\n      );\n      const diffStat = getDiffStat(\n        fileName,\n        originalContent,\n        this.params.content,\n        newContent,\n      );\n\n      const displayResult: ToolResultDisplay = {\n        fileDiff,\n        fileName,\n        originalContent,\n        newContent,\n        diffStat,\n      };\n\n      return {\n        llmContent: message,\n        returnDisplay: displayResult,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return {\n        llmContent: `Python file processing failed: ${errorMessage}`,\n        returnDisplay: ` Python processing failed: ${errorMessage}`,\n      };\n    }\n  }\n\n  private async handleTypeScriptFile(): Promise<ToolResult> {\n    const project = astAdapter.createProject();\n\n    try {\n      // Read the file content\n      const parsed = astAdapter.parseFileWithProject(\n        project,\n        this.params.file_path,\n      );\n      if (parsed.error || !parsed.sourceFile) {\n        throw new Error(parsed.error || 'Failed to parse file');\n      }\n      const originalContent = parsed.text || '';\n      const sourceFile = parsed.sourceFile;\n\n      const existingBlocks = this.findTypeScriptBlocks(sourceFile);\n      const targetBlock = existingBlocks.find(\n        (block) => block.name === this.params.block_name,\n      );\n\n      let operation: string;\n\n      if (targetBlock) {\n        // Replace existing block\n        this.replaceTypeScriptBlock(sourceFile, targetBlock);\n        operation = 'updated';\n      } else {\n        // Insert new block\n        this.insertTypeScriptBlock(sourceFile);\n        operation = 'inserted';\n      }\n\n      // Save the modified content\n      const newContent = astAdapter.dumpSourceFileText(sourceFile);\n      fs.writeFileSync(this.params.file_path, newContent, 'utf-8');\n\n      const blockType =\n        this.params.block_type ||\n        this.detectTypeScriptBlockType(this.params.content);\n      const message = `Successfully ${operation} ${blockType} '${this.params.block_name}' in ${this.params.file_path}`;\n\n      const fileName = path.basename(this.params.file_path);\n      const fileDiff = Diff.createPatch(\n        fileName,\n        originalContent,\n        newContent,\n        'Current',\n        'Proposed',\n        DEFAULT_DIFF_OPTIONS,\n      );\n      const diffStat = getDiffStat(\n        fileName,\n        originalContent,\n        this.params.content,\n        newContent,\n      );\n\n      const displayResult: ToolResultDisplay = {\n        fileDiff,\n        fileName,\n        originalContent,\n        newContent,\n        diffStat,\n      };\n\n      return {\n        llmContent: message,\n        returnDisplay: displayResult,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return {\n        llmContent: `TypeScript file processing failed: ${errorMessage}`,\n        returnDisplay: ` TypeScript processing failed: ${errorMessage}`,\n      };\n    }\n  }\n\n  private async handlePlainTextFile(): Promise<ToolResult> {\n    try {\n      const originalContent = fs.readFileSync(this.params.file_path, 'utf-8');\n\n      // For plain text files, simply append or replace based on simple pattern matching\n      const lines = originalContent.split('\\n');\n      const blockPattern = new RegExp(\n        `^\\\\s(?:def|class|function|const|let|var)\\\\s${this.params.block_name}\\b`,\n      );\n\n      let blockStartIndex = -1;\n      let blockEndIndex = -1;\n\n      // Find existing block\n      for (let i = 0; i < lines.length; i++) {\n        if (blockPattern.test(lines[i])) {\n          blockStartIndex = i;\n          // Find end of block (simple heuristic)\n          for (let j = i + 1; j < lines.length; j++) {\n            if (\n              lines[j].trim() === '' ||\n              lines[j].match(/^\\s*(?:def|class|function|const|let|var)\\s/)\n            ) {\n              blockEndIndex = j - 1;\n              break;\n            }\n          }\n          if (blockEndIndex === -1) {\n            blockEndIndex = lines.length - 1;\n          }\n          break;\n        }\n      }\n\n      let newContent: string;\n      let operation: string;\n\n      if (blockStartIndex !== -1) {\n        // Replace existing block\n        const beforeBlock = lines.slice(0, blockStartIndex);\n        const afterBlock = lines.slice(blockEndIndex + 1);\n        newContent = [...beforeBlock, this.params.content, ...afterBlock].join(\n          '\\n',\n        );\n        operation = 'updated';\n      } else {\n        // Append new block\n        newContent = originalContent + '\\n\\n' + this.params.content;\n        operation = 'inserted';\n      }\n\n      fs.writeFileSync(this.params.file_path, newContent, 'utf-8');\n\n      const message = `Successfully ${operation} block '${this.params.block_name}' in ${this.params.file_path}`;\n\n      const fileName = path.basename(this.params.file_path);\n      const fileDiff = Diff.createPatch(\n        fileName,\n        originalContent,\n        newContent,\n        'Current',\n        'Proposed',\n        DEFAULT_DIFF_OPTIONS,\n      );\n      const diffStat = getDiffStat(\n        fileName,\n        originalContent,\n        this.params.content,\n        newContent,\n      );\n\n      const displayResult: ToolResultDisplay = {\n        fileDiff,\n        fileName,\n        originalContent,\n        newContent,\n        diffStat,\n      };\n\n      return {\n        llmContent: message,\n        returnDisplay: displayResult,\n      };\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      return {\n        llmContent: `Plain text file processing failed: ${errorMessage}`,\n        returnDisplay: ` Plain text processing failed: ${errorMessage}`,\n      };\n    }\n  }\n\n  // Python-specific methods\n  private findPythonBlock(\n    lines: string[],\n  ): { startLine: number; endLine: number; indent: number } | null {\n    const blockPatterns = [\n  new RegExp(`^(\\\\s*)def\\\\s+${this.params.block_name}\\\\s*\\\\(`),\n  new RegExp(`^(\\\\s*)class\\\\s+${this.params.block_name}\\\\s*[:(]`),\n  new RegExp(`^(\\\\s*)${this.params.block_name}\\\\s*=\\\\s*`),\n    ];\n\n    for (let i = 0; i < lines.length; i++) {\n      for (const pattern of blockPatterns) {\n        const match = lines[i].match(pattern);\n        if (match) {\n          const startLine = i;\n          const indent = match[1].length;\n\n          // Find end of block by looking for next statement at same or lower indentation\n          let endLine = lines.length - 1;\n          for (let j = i + 1; j < lines.length; j++) {\n            const line = lines[j];\n            if (line.trim() === '') continue; // Skip empty lines\n\n            const lineIndent = line.length - line.trimStart().length;\n            if (lineIndent <= indent && line.trim() !== '') {\n              endLine = j - 1;\n              break;\n            }\n          }\n\n          return { startLine, endLine, indent };\n        }\n      }\n    }\n\n    return null;\n  }\n\n  private detectPythonBlockType(content: string): string {\n    const trimmed = content.trim();\n    if (trimmed.startsWith('def ')) return 'function';\n    if (trimmed.startsWith('class ')) return 'class';\n    if (trimmed.includes(' = ')) return 'variable';\n    return 'code block';\n  }\n\n  private replacePythonBlock(\n    lines: string[],\n    blockInfo: { startLine: number; endLine: number },\n    newContent: string,\n  ): string {\n    const beforeBlock = lines.slice(0, blockInfo.startLine);\n    const afterBlock = lines.slice(blockInfo.endLine + 1);\n\n    return [...beforeBlock, newContent, ...afterBlock].join('\\n');\n  }\n\n  private insertPythonBlock(lines: string[], newContent: string): string {\n    const insertPos = this.params.insert_position || 'bottom';\n\n    switch (insertPos) {\n      case 'top':\n        return [newContent, '', ...lines].join('\\n');\n\n      case 'after_imports': {\n        // Find last import statement\n        let lastImportIndex = -1;\n        for (let i = 0; i < lines.length; i++) {\n          if (lines[i].match(/^(import|from)\\s+/)) {\n            lastImportIndex = i;\n          }\n        }\n        if (lastImportIndex !== -1) {\n          const beforeImports = lines.slice(0, lastImportIndex + 1);\n          const afterImports = lines.slice(lastImportIndex + 1);\n          return [...beforeImports, '', newContent, ...afterImports].join('\\n');\n        }\n        // Fall through to bottom if no imports found\n      }\n      case 'bottom':\n      default:\n        return [...lines, '', newContent].join('\\n');\n    }\n  }\n\n  // TypeScript-specific methods\n  private findTypeScriptBlocks(sourceFile: SourceFile): BlockInfo[] {\n    const blocks: BlockInfo[] = [];\n\n    // Functions\n    sourceFile.getFunctions().forEach((func) => {\n      const name = func.getName();\n      if (name) {\n        blocks.push({\n          name,\n          type: 'function',\n          node: func,\n          startLine: func.getStartLineNumber(),\n          endLine: func.getEndLineNumber(),\n        });\n      }\n    });\n\n    // Classes\n    sourceFile.getClasses().forEach((cls) => {\n      const name = cls.getName();\n      if (name) {\n        blocks.push({\n          name,\n          type: 'class',\n          node: cls,\n          startLine: cls.getStartLineNumber(),\n          endLine: cls.getEndLineNumber(),\n        });\n      }\n    });\n\n    // Variables (const, let, var)\n    sourceFile.getVariableStatements().forEach((stmt) => {\n  stmt.getDeclarations().forEach((decl: any) => {\n        const name = decl.getName();\n        blocks.push({\n          name,\n          type: 'variable',\n          node: stmt,\n          startLine: stmt.getStartLineNumber(),\n          endLine: stmt.getEndLineNumber(),\n        });\n      });\n    });\n\n    // Interfaces\n    sourceFile.getInterfaces().forEach((iface) => {\n      const name = iface.getName();\n      blocks.push({\n        name,\n        type: 'interface',\n        node: iface,\n        startLine: iface.getStartLineNumber(),\n        endLine: iface.getEndLineNumber(),\n      });\n    });\n\n    // Type aliases\n    sourceFile.getTypeAliases().forEach((typeAlias) => {\n      const name = typeAlias.getName();\n      blocks.push({\n        name,\n        type: 'type',\n        node: typeAlias,\n        startLine: typeAlias.getStartLineNumber(),\n        endLine: typeAlias.getEndLineNumber(),\n      });\n    });\n\n    return blocks;\n  }\n\n  private detectTypeScriptBlockType(content: string): string {\n    const trimmed = content.trim();\n    if (trimmed.startsWith('function ') || trimmed.includes(') {'))\n      return 'function';\n    if (trimmed.startsWith('class ')) return 'class';\n    if (trimmed.startsWith('interface ')) return 'interface';\n    if (trimmed.startsWith('type ') && trimmed.includes(' = ')) return 'type';\n    if (\n      trimmed.startsWith('const ') ||\n      trimmed.startsWith('let ') ||\n      trimmed.startsWith('var ')\n    )\n      return 'variable';\n    return 'code block';\n  }\n\n  private replaceTypeScriptBlock(\n    sourceFile: SourceFile,\n    blockInfo: BlockInfo,\n  ): void {\n    // Get the leading and trailing trivia (comments, whitespace) if preserve_formatting is true\n    const preserveFormatting = this.params.preserve_formatting !== false;\n\n    if (preserveFormatting) {\n      // For now, simple replacement - could be enhanced to preserve trivia\n      blockInfo.node.replaceWithText(this.params.content);\n    } else {\n      blockInfo.node.replaceWithText(this.params.content);\n    }\n  }\n\n  private insertTypeScriptBlock(sourceFile: SourceFile): void {\n    const insertPos = this.params.insert_position || 'bottom';\n\n    switch (insertPos) {\n      case 'top':\n        sourceFile.insertStatements(0, this.params.content);\n        break;\n\n      case 'after_imports': {\n        const imports = sourceFile.getImportDeclarations();\n        const lastImportIndex =\n          imports.length > 0\n            ? sourceFile.getStatements().indexOf(imports[imports.length - 1]) +\n              1\n            : 0;\n        sourceFile.insertStatements(lastImportIndex, this.params.content);\n        break;\n      }\n\n      case 'before_exports': {\n        const exports = sourceFile.getExportDeclarations();\n        const firstExportIndex =\n          exports.length > 0\n            ? sourceFile.getStatements().indexOf(exports[0])\n            : sourceFile.getStatements().length;\n        sourceFile.insertStatements(firstExportIndex, this.params.content);\n        break;\n      }\n\n      case 'bottom':\n      default:\n        sourceFile.addStatements(this.params.content);\n        break;\n    }\n  }\n}\n\n/**\n * Enhanced implementation of the UpsertCodeBlock tool with robust AST parsing,\n * multi-language support, and intelligent block detection.\n *\n * Features:\n * - Multi-language support (Python, TypeScript/JavaScript, plain text)\n * - Intelligent block detection and replacement\n * - Configurable insertion positions\n * - Preservation of formatting and comments\n * - Comprehensive error handling and validation\n * - Defensive programming patterns following Crisalida conventions\n */\nexport class UpsertCodeBlockTool extends BaseDeclarativeTool<\n  UpsertCodeBlockToolParams,\n  ToolResult\n> {\n  static readonly Name = 'upsert_code_block';\n\n  constructor() {\n    super(\n      UpsertCodeBlockTool.Name,\n      'UpsertCodeBlock',\n      'Intelligently inserts or updates code blocks (functions, classes, variables, etc.) in files using proper AST parsing and language-specific logic. Supports Python, TypeScript/JavaScript, and plain text files with configurable positioning and formatting preservation.',\n      Kind.Edit,\n      {\n        properties: {\n          file_path: {\n            description:\n              \"The absolute path to the file to modify. Must start with '/'.\",\n            type: 'string',\n          },\n          block_name: {\n            description:\n              'The name of the block (e.g., function, class, variable) to find and replace. Must be a valid identifier.',\n            type: 'string',\n          },\n          content: {\n            description:\n              'The new, complete content for the code block. Should include proper indentation and syntax.',\n            type: 'string',\n          },\n          block_type: {\n            description:\n              'The type of block to upsert. If not specified, will auto-detect from content.',\n            type: 'string',\n            enum: [\n              'function',\n              'class',\n              'variable',\n              'interface',\n              'type',\n              'auto',\n            ],\n          },\n          insert_position: {\n            description:\n              'Position preference for new blocks when inserting (not replacing).',\n            type: 'string',\n            enum: ['top', 'bottom', 'after_imports', 'before_exports'],\n          },\n          preserve_formatting: {\n            description:\n              'Whether to preserve existing formatting and comments around the block.',\n            type: 'boolean',\n          },\n        },\n        required: ['file_path', 'block_name', 'content'],\n        type: 'object',\n      },\n    );\n  }\n\n  protected createInvocation(\n    params: UpsertCodeBlockToolParams,\n  ): ToolInvocation<UpsertCodeBlockToolParams, ToolResult> {\n    return new UpsertCodeBlockToolInvocation(params);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/web-fetch.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/web-fetch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/web-search.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/web-search.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/write-file.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/tools/write-file.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/LruCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/backupUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/bfsFileSearch.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/bfsFileSearch.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[422,425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[422,425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { FileDiscoveryService } from '../services/fileDiscoveryService.js';\nimport { FileFilteringOptions } from '../config/config.js';\n// Simple console logger for now.\n// TODO: Integrate with a more robust server-side logger.\nconst logger = {\n   \n  debug: (...args: any[]) => console.debug('[DEBUG] [BfsFileSearch]', ...args),\n};\n\ninterface BfsFileSearchOptions {\n  fileName: string;\n  ignoreDirs?: string[];\n  maxDirs?: number;\n  debug?: boolean;\n  fileService?: FileDiscoveryService;\n  fileFilteringOptions?: FileFilteringOptions;\n}\n\n/**\n * Performs a breadth-first search for a specific file within a directory structure.\n *\n * @param rootDir The directory to start the search from.\n * @param options Configuration for the search.\n * @returns A promise that resolves to an array of paths where the file was found.\n */\nexport async function bfsFileSearch(\n  rootDir: string,\n  options: BfsFileSearchOptions,\n): Promise<string[]> {\n  const {\n    fileName,\n    ignoreDirs = [],\n    maxDirs = Infinity,\n    debug = false,\n    fileService,\n  } = options;\n  const foundFiles: string[] = [];\n  const queue: string[] = [rootDir];\n  const visited = new Set<string>();\n  let scannedDirCount = 0;\n  let queueHead = 0; // Pointer-based queue head to avoid expensive splice operations\n\n  // Convert ignoreDirs array to Set for O(1) lookup performance\n  const ignoreDirsSet = new Set(ignoreDirs);\n\n  // Process directories in parallel batches for maximum performance\n  const PARALLEL_BATCH_SIZE = 15; // Parallel processing batch size for optimal performance\n\n  while (queueHead < queue.length && scannedDirCount < maxDirs) {\n    // Fill batch with unvisited directories up to the desired size\n    const batchSize = Math.min(PARALLEL_BATCH_SIZE, maxDirs - scannedDirCount);\n    const currentBatch = [];\n    while (currentBatch.length < batchSize && queueHead < queue.length) {\n      const currentDir = queue[queueHead];\n      queueHead++;\n      if (!visited.has(currentDir)) {\n        visited.add(currentDir);\n        currentBatch.push(currentDir);\n      }\n    }\n    scannedDirCount += currentBatch.length;\n\n    if (currentBatch.length === 0) continue;\n\n    if (debug) {\n      logger.debug(\n        `Scanning [${scannedDirCount}/${maxDirs}]: batch of ${currentBatch.length}`,\n      );\n    }\n\n    // Read directories in parallel instead of one by one\n    const readPromises = currentBatch.map(async (currentDir) => {\n      try {\n        const entries = await fs.readdir(currentDir, { withFileTypes: true });\n        return { currentDir, entries };\n      } catch (error) {\n        // Warn user that a directory could not be read, as this affects search results.\n        const message = (error as Error)?.message ?? 'Unknown error';\n        console.warn(\n          `[WARN] Skipping unreadable directory: ${currentDir} (${message})`,\n        );\n        if (debug) {\n          logger.debug(`Full error for ${currentDir}:`, error);\n        }\n        return { currentDir, entries: [] };\n      }\n    });\n\n    const results = await Promise.all(readPromises);\n\n    for (const { currentDir, entries } of results) {\n      for (const entry of entries) {\n        const fullPath = path.join(currentDir, entry.name);\n        if (\n          fileService?.shouldIgnoreFile(fullPath, {\n            respectGitIgnore: options.fileFilteringOptions?.respectGitIgnore,\n            respectGeminiIgnore:\n              options.fileFilteringOptions?.respectGeminiIgnore,\n          })\n        ) {\n          continue;\n        }\n\n        if (entry.isDirectory()) {\n          if (!ignoreDirsSet.has(entry.name)) {\n            queue.push(fullPath);\n          }\n        } else if (entry.isFile() && entry.name === fileName) {\n          foundFiles.push(fullPath);\n        }\n      }\n    }\n  }\n\n  return foundFiles;\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/browser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/editCorrector.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[309,312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[309,312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[344,347],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[344,347],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[368,371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[368,371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[400,403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[400,403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":35,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[580,583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[580,583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[648,651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[648,651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[755,758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[755,758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[864,867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[864,867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":182,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":182,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6444,6447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6444,6447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":624,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":624,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24949,24952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24949,24952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \nimport {\n  vi,\n  describe,\n  it,\n  expect,\n  beforeEach,\n  Mock,\n  type Mocked,\n} from 'vitest';\nimport * as fs from 'fs';\nimport { EditTool } from '../tools/edit.js';\n\n// MOCKS\nlet callCount = 0;\nconst mockResponses: any[] = [];\n\nlet mockGenerateJson: any;\nlet mockStartChat: any;\nlet mockSendMessageStream: any;\n\nvi.mock('fs', () => ({\n  statSync: vi.fn(),\n  mkdirSync: vi.fn(),\n}));\n\nvi.mock('../core/client.js', () => ({\n  GeminiClient: vi.fn().mockImplementation(function (\n    this: any,\n    _config: Config,\n  ) {\n    this.generateJson = (...params: any[]) => mockGenerateJson(...params); // Corrected: use mockGenerateJson\n    this.startChat = (...params: any[]) => mockStartChat(...params); // Corrected: use mockStartChat\n    this.sendMessageStream = (...params: any[]) =>\n      mockSendMessageStream(...params); // Corrected: use mockSendMessageStream\n    return this;\n  }),\n}));\n// END MOCKS\n\nimport {\n  countOccurrences,\n  ensureCorrectEdit,\n  ensureCorrectFileContent,\n  unescapeStringForGeminiBug,\n  resetEditCorrectorCaches,\n} from './editCorrector.js';\nimport { GeminiClient } from '../core/client.js';\nimport type { Config } from '../config/config.js';\nimport { ToolRegistry } from '../tools/tool-registry.js';\n\nvi.mock('../tools/tool-registry.js');\n\ndescribe('editCorrector', () => {\n  describe('countOccurrences', () => {\n    it('should return 0 for empty string', () => {\n      expect(countOccurrences('', 'a')).toBe(0);\n    });\n    it('should return 0 for empty substring', () => {\n      expect(countOccurrences('abc', '')).toBe(0);\n    });\n    it('should return 0 if substring is not found', () => {\n      expect(countOccurrences('abc', 'd')).toBe(0);\n    });\n    it('should return 1 if substring is found once', () => {\n      expect(countOccurrences('abc', 'b')).toBe(1);\n    });\n    it('should return correct count for multiple occurrences', () => {\n      expect(countOccurrences('ababa', 'a')).toBe(3);\n      expect(countOccurrences('ababab', 'ab')).toBe(3);\n    });\n    it('should count non-overlapping occurrences', () => {\n      expect(countOccurrences('aaaaa', 'aa')).toBe(2);\n      expect(countOccurrences('ababab', 'aba')).toBe(1);\n    });\n    it('should correctly count occurrences when substring is longer', () => {\n      expect(countOccurrences('abc', 'abcdef')).toBe(0);\n    });\n    it('should be case-sensitive', () => {\n      expect(countOccurrences('abcABC', 'a')).toBe(1);\n      expect(countOccurrences('abcABC', 'A')).toBe(1);\n    });\n  });\n\n  describe('unescapeStringForGeminiBug', () => {\n    it('should unescape common sequences', () => {\n      expect(unescapeStringForGeminiBug('\\\\n')).toBe('\\n');\n      expect(unescapeStringForGeminiBug('\\\\t')).toBe('\\t');\n      expect(unescapeStringForGeminiBug(\"\\\\'\")).toBe(\"'\");\n      expect(unescapeStringForGeminiBug('\\\\\"')).toBe('\"');\n      expect(unescapeStringForGeminiBug('\\\\`')).toBe('`');\n    });\n    it('should handle multiple escaped sequences', () => {\n      expect(unescapeStringForGeminiBug('Hello\\\\nWorld\\\\tTest')).toBe(\n        'Hello\\nWorld\\tTest',\n      );\n    });\n    it('should not alter already correct sequences', () => {\n      expect(unescapeStringForGeminiBug('\\n')).toBe('\\n');\n      expect(unescapeStringForGeminiBug('Correct string')).toBe(\n        'Correct string',\n      );\n    });\n    it('should handle mixed correct and incorrect sequences', () => {\n      expect(unescapeStringForGeminiBug('\\\\nCorrect\\t\\\\`')).toBe(\n        '\\nCorrect\\t`',\n      );\n    });\n    it('should handle backslash followed by actual newline character', () => {\n      expect(unescapeStringForGeminiBug('\\\\\\n')).toBe('\\n');\n      expect(unescapeStringForGeminiBug('First line\\\\\\nSecond line')).toBe(\n        'First line\\nSecond line',\n      );\n    });\n    it('should handle multiple backslashes before an escapable character (aggressive unescaping)', () => {\n      expect(unescapeStringForGeminiBug('\\\\\\\\n')).toBe('\\n');\n      expect(unescapeStringForGeminiBug('\\\\\\\\\\\\t')).toBe('\\t');\n      expect(unescapeStringForGeminiBug('\\\\\\\\\\\\\\\\`')).toBe('`');\n    });\n    it('should return empty string for empty input', () => {\n      expect(unescapeStringForGeminiBug('')).toBe('');\n    });\n    it('should not alter strings with no targeted escape sequences', () => {\n      expect(unescapeStringForGeminiBug('abc def')).toBe('abc def');\n      expect(unescapeStringForGeminiBug('C:\\\\Folder\\\\File')).toBe(\n        'C:\\\\Folder\\\\File',\n      );\n    });\n    it('should correctly process strings with some targeted escapes', () => {\n      expect(unescapeStringForGeminiBug('C:\\\\Users\\\\name')).toBe(\n        'C:\\\\Users\\name',\n      );\n    });\n    it('should handle complex cases with mixed slashes and characters', () => {\n      expect(\n        unescapeStringForGeminiBug('\\\\\\\\\\\\\\nLine1\\\\\\nLine2\\\\tTab\\\\\\\\`Tick\\\\\"'),\n      ).toBe('\\nLine1\\nLine2\\tTab`Tick\"');\n    });\n    it('should handle escaped backslashes', () => {\n      expect(unescapeStringForGeminiBug('\\\\\\\\')).toBe('\\\\');\n      expect(unescapeStringForGeminiBug('C:\\\\\\\\Users')).toBe('C:\\\\Users');\n      expect(unescapeStringForGeminiBug('path\\\\\\\\to\\\\\\\\file')).toBe(\n        'path\\to\\\\file',\n      );\n    });\n    it('should handle escaped backslashes mixed with other escapes (aggressive unescaping)', () => {\n      expect(unescapeStringForGeminiBug('line1\\\\\\\\\\\\nline2')).toBe(\n        'line1\\nline2',\n      );\n      expect(unescapeStringForGeminiBug('quote\\\\\\\\\"text\\\\\\\\nline')).toBe(\n        'quote\"text\\nline',\n      );\n    });\n  });\n\n  describe('ensureCorrectEdit', () => {\n    let mockGeminiClientInstance: Mocked<GeminiClient>;\n    let mockToolRegistry: Mocked<ToolRegistry>;\n    let mockConfigInstance: Config;\n    const abortSignal = new AbortController().signal;\n\n    beforeEach(() => {\n      mockToolRegistry = new ToolRegistry({} as Config) as Mocked<ToolRegistry>;\n      const configParams = {\n        apiKey: 'test-api-key',\n        model: 'test-model',\n        sandbox: false as boolean | string,\n        targetDir: '/test',\n        debugMode: false,\n        question: undefined as string | undefined,\n        fullContext: false,\n        coreTools: undefined as string[] | undefined,\n        toolDiscoveryCommand: undefined as string | undefined,\n        toolCallCommand: undefined as string | undefined,\n        mcpServerCommand: undefined as string | undefined,\n        mcpServers: undefined as Record<string, any> | undefined,\n        userAgent: 'test-agent',\n        userMemory: '',\n        geminiMdFileCount: 0,\n        alwaysSkipModificationConfirmation: false,\n      };\n      mockConfigInstance = {\n        ...configParams,\n        getApiKey: vi.fn(() => configParams.apiKey),\n        getModel: vi.fn(() => configParams.model),\n        getSandbox: vi.fn(() => configParams.sandbox),\n        getTargetDir: vi.fn(() => configParams.targetDir),\n        getToolRegistry: vi.fn(() => mockToolRegistry),\n        getDebugMode: vi.fn(() => configParams.debugMode),\n        getQuestion: vi.fn(() => configParams.question),\n        getFullContext: vi.fn(() => configParams.fullContext),\n        getCoreTools: vi.fn(() => configParams.coreTools),\n        getToolDiscoveryCommand: vi.fn(() => configParams.toolDiscoveryCommand),\n        getToolCallCommand: vi.fn(() => configParams.toolCallCommand),\n        getMcpServerCommand: vi.fn(() => configParams.mcpServerCommand),\n        getMcpServers: vi.fn(() => configParams.mcpServers),\n        getUserAgent: vi.fn(() => configParams.userAgent),\n        getUserMemory: vi.fn(() => configParams.userMemory),\n        setUserMemory: vi.fn((mem: string) => {\n          configParams.userMemory = mem;\n        }),\n        getGeminiMdFileCount: vi.fn(() => configParams.geminiMdFileCount),\n        setGeminiMdFileCount: vi.fn((count: number) => {\n          configParams.geminiMdFileCount = count;\n        }),\n        getAlwaysSkipModificationConfirmation: vi.fn(\n          () => configParams.alwaysSkipModificationConfirmation,\n        ),\n        setAlwaysSkipModificationConfirmation: vi.fn((skip: boolean) => {\n          configParams.alwaysSkipModificationConfirmation = skip;\n        }),\n        getQuotaErrorOccurred: vi.fn().mockReturnValue(false),\n        setQuotaErrorOccurred: vi.fn(),\n      } as unknown as Config;\n\n      callCount = 0;\n      mockResponses.length = 0;\n      mockGenerateJson = vi\n        .fn()\n        .mockImplementation((_contents, _schema, signal) => {\n          // Check if the signal is aborted. If so, throw an error or return a specific response.\n          if (signal && signal.aborted) {\n            return Promise.reject(new Error('Aborted')); // Or some other specific error/response\n          }\n          const response = mockResponses[callCount];\n          callCount++;\n          if (response === undefined) return Promise.resolve({});\n          return Promise.resolve(response);\n        });\n      mockStartChat = vi.fn();\n      mockSendMessageStream = vi.fn();\n\n      mockGeminiClientInstance = new GeminiClient(\n        mockConfigInstance,\n      ) as Mocked<GeminiClient>;\n      mockGeminiClientInstance.getHistory = vi.fn().mockResolvedValue([]);\n      resetEditCorrectorCaches();\n    });\n\n    describe('Scenario Group 1: originalParams.old_string matches currentContent directly', () => {\n      it('Test 1.1: old_string (no literal \\\\), new_string (escaped by Gemini) -> new_string unescaped', async () => {\n        const currentContent = 'This is a test string to find me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find me',\n          new_string: 'replace with \\\\\"this\\\\\"',\n        };\n        mockResponses.push({\n          corrected_new_string_escaping: 'replace with \"this\"',\n        });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params.new_string).toBe('replace with \"this\"');\n        expect(result.params.old_string).toBe('find me');\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 1.2: old_string (no literal \\\\), new_string (correctly formatted) -> new_string unchanged', async () => {\n        const currentContent = 'This is a test string to find me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find me',\n          new_string: 'replace with this',\n        };\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(0);\n        expect(result.params.new_string).toBe('replace with this');\n        expect(result.params.old_string).toBe('find me');\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 1.3: old_string (with literal \\\\), new_string (escaped by Gemini) -> new_string unchanged (still escaped)', async () => {\n        const currentContent = 'This is a test string to find\\\\me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find\\\\me',\n          new_string: 'replace with \\\\\"this\\\\\"',\n        };\n        mockResponses.push({\n          corrected_new_string_escaping: 'replace with \"this\"',\n        });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params.new_string).toBe('replace with \"this\"');\n        expect(result.params.old_string).toBe('find\\\\me');\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 1.4: old_string (with literal \\\\), new_string (correctly formatted) -> new_string unchanged', async () => {\n        const currentContent = 'This is a test string to find\\\\me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find\\\\me',\n          new_string: 'replace with this',\n        };\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(0);\n        expect(result.params.new_string).toBe('replace with this');\n        expect(result.params.old_string).toBe('find\\\\me');\n        expect(result.occurrences).toBe(1);\n      });\n    });\n\n    describe('Scenario Group 2: originalParams.old_string does NOT match, but unescapeStringForGeminiBug(originalParams.old_string) DOES match', () => {\n      it('Test 2.1: old_string (over-escaped, no intended literal \\\\), new_string (escaped by Gemini) -> new_string unescaped', async () => {\n        const currentContent = 'This is a test string to find \"me\".';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find \\\\\"me\\\\\"',\n          new_string: 'replace with \\\\\"this\\\\\"',\n        };\n        mockResponses.push({ corrected_new_string: 'replace with \"this\"' });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params.new_string).toBe('replace with \"this\"');\n        expect(result.params.old_string).toBe('find \"me\"');\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 2.2: old_string (over-escaped, no intended literal \\\\), new_string (correctly formatted) -> new_string unescaped (harmlessly)', async () => {\n        const currentContent = 'This is a test string to find \"me\".';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find \\\\\"me\\\\\"',\n          new_string: 'replace with this',\n        };\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(0);\n        expect(result.params.new_string).toBe('replace with this');\n        expect(result.params.old_string).toBe('find \"me\"');\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 2.3: old_string (over-escaped, with intended literal \\\\), new_string (simple) -> new_string corrected', async () => {\n        const currentContent = 'This is a test string to find \\\\me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find \\\\\\\\me',\n          new_string: 'replace with foobar',\n        };\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(0);\n        expect(result.params.new_string).toBe('replace with foobar');\n        expect(result.params.old_string).toBe('find \\\\me');\n        expect(result.occurrences).toBe(1);\n      });\n    });\n\n    describe('Scenario Group 3: LLM Correction Path', () => {\n      it('Test 3.1: old_string (no literal \\\\), new_string (escaped by Gemini), LLM re-escapes new_string -> final new_string is double unescaped', async () => {\n        const currentContent = 'This is a test string to corrected find me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find me',\n          new_string: 'replace with \\\\\\\\\"this\\\\\\\\\"',\n        };\n        const llmNewString = 'LLM says replace with \"that\"';\n        mockResponses.push({ corrected_new_string_escaping: llmNewString });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params.new_string).toBe(llmNewString);\n        expect(result.params.old_string).toBe('find me');\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 3.2: old_string (with literal \\\\), new_string (escaped by Gemini), LLM re-escapes new_string -> final new_string is unescaped once', async () => {\n        const currentContent = 'This is a test string to corrected find me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find\\\\me',\n          new_string: 'replace with \\\\\\\\\"this\\\\\\\\\"',\n        };\n        const llmCorrectedOldString = 'corrected find me';\n        const llmNewString = 'LLM says replace with \"that\"';\n        mockResponses.push({ corrected_target_snippet: llmCorrectedOldString });\n        mockResponses.push({ corrected_new_string: llmNewString });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(2);\n        expect(result.params.new_string).toBe(llmNewString);\n        expect(result.params.old_string).toBe(llmCorrectedOldString);\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 3.3: old_string needs LLM, new_string is fine -> old_string corrected, new_string original', async () => {\n        const currentContent = 'This is a test string to be corrected.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'fiiind me',\n          new_string: 'replace with \"this\"',\n        };\n        const llmCorrectedOldString = 'to be corrected';\n        mockResponses.push({ corrected_target_snippet: llmCorrectedOldString });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params.new_string).toBe('replace with \"this\"');\n        expect(result.params.old_string).toBe(llmCorrectedOldString);\n        expect(result.occurrences).toBe(1);\n      });\n      it('Test 3.4: LLM correction path, correctNewString returns the originalNewString it was passed (which was unescaped) -> final new_string is unescaped', async () => {\n        const currentContent = 'This is a test string to corrected find me.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find me',\n          new_string: 'replace with \\\\\\\\\"this\\\\\\\\\"',\n        };\n        const newStringForLLMAndReturnedByLLM = 'replace with \"this\"';\n        mockResponses.push({\n          corrected_new_string_escaping: newStringForLLMAndReturnedByLLM,\n        });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params.new_string).toBe(newStringForLLMAndReturnedByLLM);\n        expect(result.occurrences).toBe(1);\n      });\n    });\n\n    describe('Scenario Group 4: No Match Found / Multiple Matches', () => {\n      it('Test 4.1: No version of old_string (original, unescaped, LLM-corrected) matches -> returns original params, 0 occurrences', async () => {\n        const currentContent = 'This content has nothing to find.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'nonexistent string',\n          new_string: 'some new string',\n        };\n        mockResponses.push({ corrected_target_snippet: 'still nonexistent' });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n        expect(result.params).toEqual(originalParams);\n        expect(result.occurrences).toBe(0);\n      });\n      it('Test 4.2: unescapedOldStringAttempt results in >1 occurrences -> returns original params, count occurrences', async () => {\n        const currentContent =\n          'This content has find \"me\" and also find \"me\" again.';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'find \"me\"',\n          new_string: 'some new string',\n        };\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(0);\n        expect(result.params).toEqual(originalParams);\n        expect(result.occurrences).toBe(2);\n      });\n    });\n\n    describe('Scenario Group 5: Specific unescapeStringForGeminiBug checks (integrated into ensureCorrectEdit)', () => {\n      it('Test 5.1: old_string needs LLM to become currentContent, new_string also needs correction', async () => {\n        const currentContent = 'const x = \"a\\nbc\\\\\"def\\\\\"';\n        const originalParams = {\n          file_path: '/test/file.txt',\n          old_string: 'const x = \\\\\"a\\\\nbc\\\\\\\\\"def\\\\\\\\\"',\n          new_string: 'const y = \\\\\"new\\\\nval\\\\\\\\\"content\\\\\\\\\"',\n        };\n        const expectedFinalNewString = 'const y = \"new\\nval\\\\\"content\\\\\"';\n        mockResponses.push({ corrected_target_snippet: currentContent });\n        mockResponses.push({ corrected_new_string: expectedFinalNewString });\n        const result = await ensureCorrectEdit(\n          '/test/file.txt',\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n        expect(mockGenerateJson).toHaveBeenCalledTimes(2);\n        expect(result.params.old_string).toBe(currentContent);\n        expect(result.params.new_string).toBe(expectedFinalNewString);\n        expect(result.occurrences).toBe(1);\n      });\n    });\n\n    describe('Scenario Group 6: Concurrent Edits', () => {\n      it('Test 6.1: should return early if file was modified by another process', async () => {\n        const filePath = '/test/file.txt';\n        const currentContent =\n          'This content has been modified by someone else.';\n        const originalParams = {\n          file_path: filePath,\n          old_string: 'nonexistent string',\n          new_string: 'some new string',\n        };\n\n        const now = Date.now();\n        const lastEditTime = now - 5000; // 5 seconds ago\n\n        // Mock the file's modification time to be recent\n        vi.spyOn(fs, 'statSync').mockReturnValue({\n          mtimeMs: now,\n        } as fs.Stats);\n\n        // Mock the last edit timestamp from our history to be in the past\n        const history = [\n          {\n            role: 'model',\n            parts: [\n              {\n                functionResponse: {\n                  name: EditTool.Name,\n                  id: `${EditTool.Name}-${lastEditTime}-123`,\n                  response: {\n                    output: {\n                      llmContent: `Successfully modified file: ${filePath}`,\n                    },\n                  },\n                },\n              },\n            ],\n          },\n        ];\n        (mockGeminiClientInstance.getHistory as Mock).mockResolvedValue(\n          history,\n        );\n\n        const result = await ensureCorrectEdit(\n          filePath,\n          currentContent,\n          originalParams,\n          mockGeminiClientInstance,\n          abortSignal,\n        );\n\n        expect(result.occurrences).toBe(0);\n        expect(result.params).toEqual(originalParams);\n      });\n    });\n  });\n\n  describe('ensureCorrectFileContent', () => {\n    let mockGeminiClientInstance: Mocked<GeminiClient>;\n    let mockToolRegistry: Mocked<ToolRegistry>;\n    let mockConfigInstance: Config;\n    const abortSignal = new AbortController().signal;\n\n    beforeEach(() => {\n      mockToolRegistry = new ToolRegistry({} as Config) as Mocked<ToolRegistry>;\n      const configParams = {\n        apiKey: 'test-api-key',\n        model: 'test-model',\n        sandbox: false as boolean | string,\n        targetDir: '/test',\n        debugMode: false,\n        question: undefined as string | undefined,\n        fullContext: false,\n        coreTools: undefined as string[] | undefined,\n        toolDiscoveryCommand: undefined as string | undefined,\n        toolCallCommand: undefined as string | undefined,\n        mcpServerCommand: undefined as string | undefined,\n        mcpServers: undefined as Record<string, any> | undefined,\n        userAgent: 'test-agent',\n        userMemory: '',\n        geminiMdFileCount: 0,\n        alwaysSkipModificationConfirmation: false,\n      };\n      mockConfigInstance = {\n        ...configParams,\n        getApiKey: vi.fn(() => configParams.apiKey),\n        getModel: vi.fn(() => configParams.model),\n        getSandbox: vi.fn(() => configParams.sandbox),\n        getTargetDir: vi.fn(() => configParams.targetDir),\n        getToolRegistry: vi.fn(() => mockToolRegistry),\n        getDebugMode: vi.fn(() => configParams.debugMode),\n        getQuestion: vi.fn(() => configParams.question),\n        getFullContext: vi.fn(() => configParams.fullContext),\n        getCoreTools: vi.fn(() => configParams.coreTools),\n        getToolDiscoveryCommand: vi.fn(() => configParams.toolDiscoveryCommand),\n        getToolCallCommand: vi.fn(() => configParams.toolCallCommand),\n        getMcpServerCommand: vi.fn(() => configParams.mcpServerCommand),\n        getMcpServers: vi.fn(() => configParams.mcpServers),\n        getUserAgent: vi.fn(() => configParams.userAgent),\n        getUserMemory: vi.fn(() => configParams.userMemory),\n        setUserMemory: vi.fn((mem: string) => {\n          configParams.userMemory = mem;\n        }),\n        getGeminiMdFileCount: vi.fn(() => configParams.geminiMdFileCount),\n        setGeminiMdFileCount: vi.fn((count: number) => {\n          configParams.geminiMdFileCount = count;\n        }),\n        getAlwaysSkipModificationConfirmation: vi.fn(\n          () => configParams.alwaysSkipModificationConfirmation,\n        ),\n        setAlwaysSkipModificationConfirmation: vi.fn((skip: boolean) => {\n          configParams.alwaysSkipModificationConfirmation = skip;\n        }),\n        getQuotaErrorOccurred: vi.fn().mockReturnValue(false),\n        setQuotaErrorOccurred: vi.fn(),\n      } as unknown as Config;\n\n      callCount = 0;\n      mockResponses.length = 0;\n      mockGenerateJson = vi\n        .fn()\n        .mockImplementation((_contents, _schema, signal) => {\n          if (signal && signal.aborted) {\n            return Promise.reject(new Error('Aborted'));\n          }\n          const response = mockResponses[callCount];\n          callCount++;\n          if (response === undefined) return Promise.resolve({});\n          return Promise.resolve(response);\n        });\n      mockStartChat = vi.fn();\n      mockSendMessageStream = vi.fn();\n\n      mockGeminiClientInstance = new GeminiClient(\n        mockConfigInstance,\n      ) as Mocked<GeminiClient>;\n      resetEditCorrectorCaches();\n    });\n\n    it('should return content unchanged if no escaping issues detected', async () => {\n      const content = 'This is normal content without escaping issues';\n      const result = await ensureCorrectFileContent(\n        content,\n        mockGeminiClientInstance,\n        abortSignal,\n      );\n      expect(result).toBe(content);\n      expect(mockGenerateJson).toHaveBeenCalledTimes(0);\n    });\n\n    it('should call correctStringEscaping for potentially escaped content', async () => {\n      const content = 'console.log(\\\\\"Hello World\\\\\");';\n      const correctedContent = 'console.log(\"Hello World\");';\n      mockResponses.push({\n        corrected_string_escaping: correctedContent,\n      });\n\n      const result = await ensureCorrectFileContent(\n        content,\n        mockGeminiClientInstance,\n        abortSignal,\n      );\n\n      expect(result).toBe(correctedContent);\n      expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle correctStringEscaping returning corrected content via correct property name', async () => {\n      // This test specifically verifies the property name fix\n      const content = 'const message = \\\\\"Hello\\\\nWorld\\\\\";';\n      const correctedContent = 'const message = \"Hello\\nWorld\";';\n\n      // Mock the response with the correct property name\n      mockResponses.push({\n        corrected_string_escaping: correctedContent,\n      });\n\n      const result = await ensureCorrectFileContent(\n        content,\n        mockGeminiClientInstance,\n        abortSignal,\n      );\n\n      expect(result).toBe(correctedContent);\n      expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n    });\n\n    it('should return original content if LLM correction fails', async () => {\n      const content = 'console.log(\\\\\"Hello World\\\\\");';\n      // Mock empty response to simulate LLM failure\n      mockResponses.push({});\n\n      const result = await ensureCorrectFileContent(\n        content,\n        mockGeminiClientInstance,\n        abortSignal,\n      );\n\n      expect(result).toBe(content);\n      expect(mockGenerateJson).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle various escape sequences that need correction', async () => {\n      const content =\n        'const obj = { name: \\\\\"John\\\\\", age: 30, bio: \\\\\"Developer\\\\nEngineer\\\\\" };';\n      const correctedContent =\n        'const obj = { name: \"John\", age: 30, bio: \"Developer\\nEngineer\" };';\n\n      mockResponses.push({\n        corrected_string_escaping: correctedContent,\n      });\n\n      const result = await ensureCorrectFileContent(\n        content,\n        mockGeminiClientInstance,\n        abortSignal,\n      );\n\n      expect(result).toBe(correctedContent);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/editCorrector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":330,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":330,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10737,10740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10737,10740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":335,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":335,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10934,10937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10934,10937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":376,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":376,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12098,12101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12098,12101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":429,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":429,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13550,13553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13550,13553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":476,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":476,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14981,14984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14981,14984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GenerateContentConfig } from '@google/genai';\nimport { GeminiClient } from '../core/client.js';\nimport { EditToolParams, EditTool } from '../tools/edit.js';\nimport { WriteFileTool } from '../tools/write-file.js';\nimport { ReadFileTool } from '../tools/read-file.js';\nimport { ReadManyFilesTool } from '../tools/read-many-files.js';\nimport { GrepTool } from '../tools/grep.js';\nimport { LruCache } from './LruCache.js';\nimport { DEFAULT_GEMINI_FLASH_LITE_MODEL } from '../config/models.js';\nimport {\n  isFunctionResponse,\n  isFunctionCall,\n} from '../utils/messageInspectors.js';\nimport * as fs from 'fs';\nimport { parseSourceToSourceFile } from '../ast/parser.js';\nimport { findNodes } from '../ast/finder.js';\n\nconst EditModel = DEFAULT_GEMINI_FLASH_LITE_MODEL;\nconst EditConfig: GenerateContentConfig = {\n  thinkingConfig: {\n    thinkingBudget: 0,\n  },\n};\n\nconst MAX_CACHE_SIZE = 50;\n\n// Cache for ensureCorrectEdit results\nconst editCorrectionCache = new LruCache<string, CorrectedEditResult>(\n  MAX_CACHE_SIZE,\n);\n\n// Cache for ensureCorrectFileContent results\nconst fileContentCorrectionCache = new LruCache<string, string>(MAX_CACHE_SIZE);\n\n/**\n * Defines the structure of the parameters within CorrectedEditResult\n */\ninterface CorrectedEditParams {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Defines the result structure for ensureCorrectEdit.\n */\nexport interface CorrectedEditResult {\n  params: CorrectedEditParams;\n  occurrences: number;\n}\n\n/**\n * Extracts the timestamp from the .id value, which is in format\n * <tool.name>-<timestamp>-<uuid>\n * @param fcnId the ID value of a functionCall or functionResponse object\n * @returns -1 if the timestamp could not be extracted, else the timestamp (as a number)\n */\nfunction getTimestampFromFunctionId(fcnId: string): number {\n  const idParts = fcnId.split('-');\n  if (idParts.length > 2) {\n    const timestamp = parseInt(idParts[1], 10);\n    if (!isNaN(timestamp)) {\n      return timestamp;\n    }\n  }\n  return -1;\n}\n\n/**\n * Will look through the gemini client history and determine when the most recent\n * edit to a target file occurred. If no edit happened, it will return -1\n * @param filePath the path to the file\n * @param client the geminiClient, so that we can get the history\n * @returns a DateTime (as a number) of when the last edit occurred, or -1 if no edit was found.\n */\nasync function findLastEditTimestamp(\n  filePath: string,\n  client: GeminiClient,\n): Promise<number> {\n  const history = (await client.getHistory()) ?? [];\n\n  // Tools that may reference the file path in their FunctionResponse `output`.\n  const toolsInResp = new Set([\n    WriteFileTool.Name,\n    EditTool.Name,\n    ReadManyFilesTool.Name,\n    GrepTool.Name,\n  ]);\n  // Tools that may reference the file path in their FunctionCall `args`.\n  const toolsInCall = new Set([...toolsInResp, ReadFileTool.Name]);\n\n  // Iterate backwards to find the most recent relevant action.\n  for (const entry of history.slice().reverse()) {\n    if (!entry.parts) continue;\n\n    for (const part of entry.parts) {\n      let id: string | undefined;\n      let content: unknown;\n\n      // Check for a relevant FunctionCall with the file path in its arguments.\n      if (\n        isFunctionCall(entry) &&\n        part.functionCall?.name &&\n        toolsInCall.has(part.functionCall.name)\n      ) {\n        id = part.functionCall.id;\n        content = part.functionCall.args;\n      }\n      // Check for a relevant FunctionResponse with the file path in its output.\n      else if (\n        isFunctionResponse(entry) &&\n        part.functionResponse?.name &&\n        toolsInResp.has(part.functionResponse.name)\n      ) {\n        const { response } = part.functionResponse;\n        if (response && !('error' in response) && 'output' in response) {\n          id = part.functionResponse.id;\n          content = response['output'];\n        }\n      }\n\n      if (!id || content === undefined) continue;\n\n      // Use the \"blunt hammer\" approach to find the file path in the content.\n      // Note that the tool response data is inconsistent in their formatting\n      // with successes and errors - so, we just check for the existence\n      // as the best guess to if error/failed occurred with the response.\n      const stringified = JSON.stringify(content);\n      if (\n        !stringified.includes('Error') && // only applicable for functionResponse\n        !stringified.includes('Failed') && // only applicable for functionResponse\n        stringified.includes(filePath)\n      ) {\n        return getTimestampFromFunctionId(id);\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Attempts to correct edit parameters if the original old_string is not found.\n * Uses an AST-first approach with multiple correction strategies before falling back to LLM.\n * Results are cached to avoid redundant processing.\n */\nexport async function ensureCorrectEdit(\n  filePath: string,\n  currentContent: string,\n  originalParams: EditToolParams,\n  client: GeminiClient,\n  abortSignal: AbortSignal,\n): Promise<CorrectedEditResult> {\n  const cacheKey = `${currentContent}---${originalParams.old_string}---${originalParams.new_string}`;\n  const cachedResult = editCorrectionCache.get(cacheKey);\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  const finalNewString = originalParams.new_string ?? '';\n  const newStringPotentiallyEscaped =\n    unescapeStringForGeminiBug(finalNewString) !== finalNewString;\n\n  const expectedReplacements = originalParams.expected_replacements ?? 1;\n  let finalOldString = originalParams.old_string ?? '';\n  let occurrences = countOccurrences(currentContent, finalOldString);\n\n  // Early return if we already have the expected number of occurrences\n  if (occurrences === expectedReplacements) {\n    return await finalizeResult(\n      originalParams,\n      finalOldString,\n      finalNewString,\n      occurrences,\n      newStringPotentiallyEscaped,\n      client,\n      abortSignal,\n      cacheKey\n    );\n  }\n\n  // AST-first correction with multiple strategies\n  // If the caller requested a specific occurrence (e.g. target_occurrence = 7)\n  // we MUST NOT apply AST-based corrections that can replace the original\n  // `old_string` with a large AST node text. Doing so collapses multiple\n  // simple repeated occurrences into a single match and breaks targeted\n  // replacements. In that case skip AST correction and rely on string-based\n  // heuristics (unescaping/trimming) which are safe for occurrence-aware ops.\n  const callerRequestedSpecificOccurrence =\n    originalParams && (originalParams as EditToolParams).target_occurrence !== undefined;\n\n  if (!callerRequestedSpecificOccurrence) {\n    const astCorrectionResult = await tryASTCorrection(\n      currentContent,\n      filePath,\n      finalOldString,\n      expectedReplacements\n    );\n\n    if (astCorrectionResult.success) {\n        if (astCorrectionResult.correctedOldString !== undefined && astCorrectionResult.occurrences !== undefined) {\n          // correctedOldString and occurrences are optional on the result type;\n          // narrow and cast to satisfy the compiler that they're present.\n          finalOldString = astCorrectionResult.correctedOldString as string;\n          occurrences = astCorrectionResult.occurrences as number;\n        }\n      \n      return await finalizeResult(\n        originalParams,\n        finalOldString,\n        finalNewString,\n        occurrences,\n        newStringPotentiallyEscaped,\n        client,\n        abortSignal,\n        cacheKey\n      );\n    }\n  }\n\n  // String-based corrections (unescaping, trimming)\n  const stringCorrectionResult = tryStringBasedCorrections(\n    currentContent,\n    finalOldString,\n    expectedReplacements\n  );\n\n  if (stringCorrectionResult.success) {\n    if (stringCorrectionResult.correctedOldString !== undefined && stringCorrectionResult.occurrences !== undefined) {\n      // same non-null assertion as above for string-based corrections\n      finalOldString = stringCorrectionResult.correctedOldString as string;\n      occurrences = stringCorrectionResult.occurrences as number;\n    }\n\n    return await finalizeResult(\n      originalParams,\n      finalOldString,\n      finalNewString,\n      occurrences,\n      newStringPotentiallyEscaped,\n      client,\n      abortSignal,\n      cacheKey\n    );\n  }\n\n  // Handle cases with too many occurrences\n  if (occurrences > expectedReplacements) {\n    return createResult(originalParams, finalOldString, finalNewString, occurrences, cacheKey);\n  }\n\n  // Fallback to LLM-based correction\n  return await tryLLMCorrection(\n    filePath,\n    currentContent,\n    originalParams,\n    finalOldString,\n    finalNewString,\n    expectedReplacements,\n    newStringPotentiallyEscaped,\n    client,\n    abortSignal,\n    cacheKey\n  );\n}\n\n/**\n * Comprehensive AST-based correction using multiple strategies\n */\nasync function tryASTCorrection(\n  currentContent: string,\n  filePath: string,\n  oldString: string,\n  expectedReplacements: number\n): Promise<{ success: boolean; correctedOldString?: string; occurrences?: number }> {\n  try {\n    const { sourceFile, error: parseErr } = parseSourceToSourceFile(\n      currentContent,\n      filePath ?? '/virtual-file.ts'\n    );\n    \n    if (!sourceFile || parseErr) {\n      return { success: false };\n    }\n\n    // Strategy 1: Direct text matching with node specificity\n    const directMatchResult = tryDirectNodeMatching(sourceFile, oldString, expectedReplacements, currentContent);\n    if (directMatchResult.success) {\n      return directMatchResult;\n    }\n\n    // Strategy 2: Unescaped string matching\n    const unescapedOldString = unescapeStringForGeminiBug(oldString);\n    if (unescapedOldString !== oldString) {\n      const unescapedMatchResult = tryDirectNodeMatching(sourceFile, unescapedOldString, expectedReplacements, currentContent);\n      if (unescapedMatchResult.success) {\n        return unescapedMatchResult;\n      }\n    }\n\n    // Strategy 3: Semantic node matching for common code patterns\n    const semanticResult = trySemanticNodeMatching(sourceFile, oldString, expectedReplacements, currentContent);\n    if (semanticResult.success) {\n      return semanticResult;\n    }\n\n    // Strategy 4: Fuzzy matching with whitespace normalization\n    const fuzzyResult = tryFuzzyNodeMatching(sourceFile, oldString, expectedReplacements, currentContent);\n    if (fuzzyResult.success) {\n      return fuzzyResult;\n    }\n\n    return { success: false };\n  } catch (_error) {\n    console.debug('AST correction failed:', _error);\n    return { success: false };\n  }\n}\n\n/**\n * Strategy 1: Direct node text matching with specificity ranking\n */\nfunction tryDirectNodeMatching(\n  sourceFile: any,\n  searchString: string,\n  expectedReplacements: number,\n  currentContent: string\n): { success: boolean; correctedOldString?: string; occurrences?: number } {\n  const candidates: Array<{ node: any; text: string; specificity: number }> = [];\n\n  for (const node of sourceFile.getDescendants()) {\n    try {\n      const nodeText = node.getText();\n      if (nodeText && nodeText.includes(searchString)) {\n        // Calculate specificity score (prefer smaller, more specific nodes)\n        const specificity = calculateNodeSpecificity(node, searchString, nodeText);\n        candidates.push({ node, text: nodeText, specificity });\n      }\n    } catch {\n      // Ignore problematic nodes\n    }\n  }\n\n  if (candidates.length === 0) {\n    return { success: false };\n  }\n\n  // Sort by specificity (higher score = more specific)\n  candidates.sort((a, b) => b.specificity - a.specificity);\n\n  // Try candidates in order of specificity\n  for (const candidate of candidates) {\n    const occurrences = countOccurrences(currentContent, candidate.text);\n    if (occurrences === expectedReplacements) {\n      return {\n        success: true,\n        correctedOldString: candidate.text,\n        occurrences\n      };\n    }\n  }\n\n  return { success: false };\n}\n\n/**\n * Strategy 3: Semantic node matching for common code patterns\n */\nfunction trySemanticNodeMatching(\n  sourceFile: any,\n  oldString: string,\n  expectedReplacements: number,\n  currentContent: string\n): { success: boolean; correctedOldString?: string; occurrences?: number } {\n  try {\n    // Look for specific node types that commonly contain the target string\n    const semanticQueries = [\n      '//FunctionDeclaration',\n      '//MethodDeclaration', \n      '//VariableStatement',\n      '//ClassDeclaration',\n      '//PropertyAssignment',\n      '//CallExpression',\n      '//StringLiteral',\n      '//TemplateExpression'\n    ];\n\n    for (const query of semanticQueries) {\n      try {\n        const nodes = findNodes(sourceFile, query);\n        for (const node of nodes) {\n          try {\n            const nodeText = node.getText();\n            if (nodeText && nodeText.includes(oldString)) {\n              const occurrences = countOccurrences(currentContent, nodeText);\n              if (occurrences === expectedReplacements) {\n                return {\n                  success: true,\n                  correctedOldString: nodeText,\n                  occurrences\n                };\n              }\n            }\n          } catch {\n            // Continue with next node\n          }\n        }\n      } catch {\n        // Continue with next query\n      }\n    }\n\n    return { success: false };\n  } catch {\n    return { success: false };\n  }\n}\n\n/**\n * Strategy 4: Fuzzy matching with whitespace and formatting normalization\n */\nfunction tryFuzzyNodeMatching(\n  sourceFile: any,\n  oldString: string,\n  expectedReplacements: number,\n  currentContent: string\n): { success: boolean; correctedOldString?: string; occurrences?: number } {\n  const normalizedTarget = normalizeWhitespace(oldString);\n  const candidates: Array<{ text: string; similarity: number }> = [];\n\n  for (const node of sourceFile.getDescendants()) {\n    try {\n      const nodeText = node.getText();\n      if (!nodeText) continue;\n\n      const normalizedNodeText = normalizeWhitespace(nodeText);\n      \n      // Check if normalized versions match or have high similarity\n      if (normalizedNodeText.includes(normalizedTarget)) {\n        const similarity = calculateStringSimilarity(normalizedTarget, normalizedNodeText);\n        if (similarity > 0.8) { // 80% similarity threshold\n          candidates.push({ text: nodeText, similarity });\n        }\n      }\n    } catch {\n      // Ignore problematic nodes\n    }\n  }\n\n  // Sort by similarity (highest first)\n  candidates.sort((a, b) => b.similarity - a.similarity);\n\n  for (const candidate of candidates) {\n    const occurrences = countOccurrences(currentContent, candidate.text);\n    if (occurrences === expectedReplacements) {\n      return {\n        success: true,\n        correctedOldString: candidate.text,\n        occurrences\n      };\n    }\n  }\n\n  return { success: false };\n}\n\n/**\n * Calculate node specificity score for ranking candidates\n */\nfunction calculateNodeSpecificity(node: any, searchString: string, nodeText: string): number {\n  let score = 0;\n\n  // Prefer smaller nodes (inverse relationship with length)\n  score += Math.max(0, 1000 - nodeText.length);\n\n  // Prefer nodes where the search string is a larger portion of the content\n  const searchRatio = searchString.length / nodeText.length;\n  score += searchRatio * 500;\n\n  // Prefer certain node types\n  try {\n    const kindName = node.getKindName ? node.getKindName() : '';\n    const preferredTypes = [\n      'VariableStatement', 'FunctionDeclaration', 'MethodDeclaration',\n      'PropertyAssignment', 'StringLiteral', 'CallExpression'\n    ];\n    if (preferredTypes.includes(kindName)) {\n      score += 200;\n    }\n  } catch {\n    // Ignore if we can't get kind name\n  }\n\n  // Prefer exact matches at word boundaries\n  const wordBoundaryRegex = new RegExp(`\\\\b${escapeRegExp(searchString)}\\\\b`);\n  if (wordBoundaryRegex.test(nodeText)) {\n    score += 300;\n  }\n\n  return score;\n}\n\n/**\n * String-based correction strategies\n */\nfunction tryStringBasedCorrections(\n  currentContent: string,\n  oldString: string,\n  expectedReplacements: number\n): { success: boolean; correctedOldString?: string; occurrences?: number } {\n  const strategies = [\n    // Unescaping\n    () => unescapeStringForGeminiBug(oldString),\n    // Trimming\n    () => oldString.trim(),\n    // Normalize line endings\n    () => oldString.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n'),\n    // Remove extra spaces\n    () => oldString.replace(/\\s+/g, ' '),\n    // Normalize quotes\n    () => oldString.replace(/[\"\"]/g, '\"').replace(/['']/g, \"'\"),\n  ];\n\n  for (const strategy of strategies) {\n    try {\n      const corrected = strategy();\n      if (corrected !== oldString) {\n        const occurrences = countOccurrences(currentContent, corrected);\n        if (occurrences === expectedReplacements) {\n          return {\n            success: true,\n            correctedOldString: corrected,\n            occurrences\n          };\n        }\n      }\n    } catch {\n      // Continue with next strategy\n    }\n  }\n\n  return { success: false };\n}\n\n/**\n * Fallback to LLM-based correction (existing logic)\n */\nasync function tryLLMCorrection(\n  filePath: string,\n  currentContent: string,\n  originalParams: EditToolParams,\n  finalOldString: string,\n  finalNewString: string,\n  expectedReplacements: number,\n  newStringPotentiallyEscaped: boolean,\n  client: GeminiClient,\n  abortSignal: AbortSignal,\n  cacheKey: string\n): Promise<CorrectedEditResult> {\n  let occurrences = countOccurrences(currentContent, finalOldString);\n\n  if (occurrences === 0) {\n    // Check for external file modifications\n    if (filePath) {\n      const lastEditedByUsTime = await findLastEditTimestamp(filePath, client);\n      if (lastEditedByUsTime > 0) {\n        const stats = fs.statSync(filePath);\n        const diff = stats.mtimeMs - lastEditedByUsTime;\n        if (diff > 2000) {\n          return createResult(originalParams, finalOldString, finalNewString, 0, cacheKey);\n        }\n      }\n    }\n\n    // Try LLM correction\n    const unescapedOldString = unescapeStringForGeminiBug(finalOldString);\n    // Ask LLM once for a corrected old string. Tests expect a single LLM call\n    // in the 'no match' case rather than multiple retries.\n    const llmCorrectedOldString = await correctOldStringMismatch(\n      client,\n      currentContent,\n      unescapedOldString,\n      abortSignal,\n    );\n    const llmOldOccurrences = countOccurrences(currentContent, llmCorrectedOldString);\n\n    if (llmOldOccurrences === expectedReplacements) {\n      finalOldString = llmCorrectedOldString;\n      occurrences = llmOldOccurrences;\n      if (newStringPotentiallyEscaped) {\n        // Ask the LLM once to adjust the replacement text to the corrected old\n        // string. Pass the ORIGINAL requested old_string so the LLM can reason\n        // about how the replacement should change relative to the original.\n        const correctedNewString = await correctNewString(\n          client,\n          // original_old_string should be the value originally requested\n          // (not the already-corrected one).\n          originalParams.old_string ?? finalOldString,\n          llmCorrectedOldString,\n          unescapeStringForGeminiBug(finalNewString),\n          abortSignal,\n        );\n        if (typeof correctedNewString === 'string' && correctedNewString.length > 0) {\n          finalNewString = correctedNewString;\n        }\n      }\n    } else {\n      return createResult(originalParams, finalOldString, finalNewString, 0, cacheKey);\n    }\n  }\n\n  // Apply trimming optimization\n  const { targetString, pair } = trimPairIfPossible(\n    finalOldString,\n    finalNewString,\n    currentContent,\n    expectedReplacements\n  );\n\n  return createResult(originalParams, targetString, pair, countOccurrences(currentContent, targetString), cacheKey);\n}\n\n/**\n * Finalize result with potential new string correction\n */\nasync function finalizeResult(\n  originalParams: EditToolParams,\n  finalOldString: string,\n  finalNewString: string,\n  occurrences: number,\n  newStringPotentiallyEscaped: boolean,\n  client: GeminiClient,\n  abortSignal: AbortSignal,\n  cacheKey: string\n): Promise<CorrectedEditResult> {\n      if (newStringPotentiallyEscaped) {\n        const maybeCorrected = await correctNewStringEscaping(\n          client,\n          finalOldString,\n          finalNewString,\n          abortSignal,\n        );\n    if (typeof maybeCorrected === 'string' && maybeCorrected.length > 0) {\n      finalNewString = maybeCorrected;\n    }\n  }\n\n  return createResult(originalParams, finalOldString, finalNewString, occurrences, cacheKey);\n}\n\n/**\n * Create and cache the final result\n */\nfunction createResult(\n  originalParams: EditToolParams,\n  finalOldString: string,\n  finalNewString: string,\n  occurrences: number,\n  cacheKey: string\n): CorrectedEditResult {\n  // Helper to choose a non-empty string preference order:\n  // 1) finalNewString (result of correction) if non-empty\n  // 2) originalParams.new_string (what was requested) if non-empty\n  // 3) fallback to empty string (explicit)\n  function chooseNonEmpty(candidate: string | undefined, fallback?: string | undefined): string {\n    if (typeof candidate === 'string' && candidate.length > 0) return candidate;\n    if (typeof fallback === 'string' && fallback.length > 0) return fallback;\n    return '';\n  }\n\n  const safeNewString = chooseNonEmpty(finalNewString, originalParams.new_string as string | undefined);\n  const safeOldString = typeof finalOldString === 'string' ? finalOldString : (originalParams.old_string ?? '');\n\n  // Defensive guard: never return or cache an empty old_string because\n  // performing a replacement with an empty target can be destructive\n  // (it may match everywhere or be misinterpreted by callers). If we\n  // detect an empty old_string, return a result with occurrences=0\n  // and do not cache it so callers will avoid applying the replace.\n  if (!safeOldString || safeOldString.length === 0) {\n    try {\n      console.warn(\n        `editCorrector: blocked empty old_string for file ${originalParams.file_path}; returning occurrences=0 to avoid destructive replacements.`,\n      );\n    } catch {\n      /* ignore logging failures */\n    }\n\n    const fallbackResult: CorrectedEditResult = {\n      params: {\n        file_path: originalParams.file_path,\n        old_string: originalParams.old_string ?? '',\n        new_string: safeNewString,\n      },\n      occurrences: 0,\n    };\n\n    // Do not cache intentionally.\n    return fallbackResult;\n  }\n  // If we had to fallback to the original param because the correction\n  // returned empty, log a warning in debug modes to aid troubleshooting.\n  try {\n    if ((finalNewString === undefined || finalNewString === '') && originalParams.new_string) {\n      // Avoid noisy logging in production; rely on consumers to enable debug\n      // mode if they want detailed telemetry. Use console.warn for visibility.\n      console.warn(\n        `editCorrector: correction produced empty new_string for file ${originalParams.file_path}; falling back to original requested new_string.`,\n      );\n    }\n  } catch {\n    /* ignore logging failures */\n  }\n\n  const result: CorrectedEditResult = {\n    params: {\n      file_path: originalParams.file_path,\n  old_string: safeOldString,\n      new_string: safeNewString,\n    },\n    occurrences,\n  };\n\n  // Cache the safe result\n  editCorrectionCache.set(cacheKey, result);\n  return result;\n}\n\n// Utility functions\n\n/**\n * Normalize whitespace for fuzzy matching\n */\nfunction normalizeWhitespace(text: string): string {\n  return text\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n')\n    .replace(/\\t/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\n/**\n * Calculate string similarity using Levenshtein distance\n */\nfunction calculateStringSimilarity(str1: string, str2: string): number {\n  const longer = str1.length > str2.length ? str1 : str2;\n  const shorter = str1.length > str2.length ? str2 : str1;\n  \n  if (longer.length === 0) {\n    return 1.0;\n  }\n  \n  const distance = levenshteinDistance(longer, shorter);\n  return (longer.length - distance) / longer.length;\n}\n\n/**\n * Calculate Levenshtein distance between two strings\n */\nfunction levenshteinDistance(str1: string, str2: string): number {\n  const matrix = Array(str2.length + 1)\n    .fill(null)\n    .map(() => Array(str1.length + 1).fill(null));\n  \n  for (let i = 0; i <= str1.length; i++) {\n    matrix[0][i] = i;\n  }\n  \n  for (let j = 0; j <= str2.length; j++) {\n    matrix[j][0] = j;\n  }\n  \n  for (let j = 1; j <= str2.length; j++) {\n    for (let i = 1; i <= str1.length; i++) {\n      const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n      matrix[j][i] = Math.min(\n        matrix[j][i - 1] + 1, // deletion\n        matrix[j - 1][i] + 1, // insertion\n        matrix[j - 1][i - 1] + indicator // substitution\n      );\n    }\n  }\n  \n  return matrix[str2.length][str1.length];\n}\n\n/**\n * Escape special regex characters\n */\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Unescapes a string that might have been overly escaped by an LLM.\n */\nexport function unescapeStringForGeminiBug(inputString: string): string {\n  return inputString.replace(/\\\\+(n|t|r|'|\"|`|\\\\|\\n)/g, (match, capturedChar) => {\n    switch (capturedChar) {\n      case 'n':\n        return '\\n';\n      case 't':\n        return '\\t';\n      case 'r':\n        return '\\r';\n      case \"'\":\n        return \"'\";\n      case '\"':\n        return '\"';\n      case '`':\n        return '`';\n      case '\\\\':\n        return '\\\\';\n      case '\\n':\n        return '\\n';\n      default:\n        return match;\n    }\n  });\n}\n\n/**\n * Counts non-overlapping occurrences of substr in str.\n */\nexport function countOccurrences(str: string, substr: string): number {\n  if (!substr) return 0;\n  let count = 0;\n  let pos = str.indexOf(substr);\n  while (pos !== -1) {\n    count++;\n    pos = str.indexOf(substr, pos + substr.length);\n  }\n  return count;\n}\n\nexport function resetEditCorrectorCaches() {\n  try {\n    editCorrectionCache.clear();\n  } catch (e) {\n    console.debug('resetEditCorrectorCaches: ignore', e);\n  }\n  try {\n    fileContentCorrectionCache.clear();\n  } catch (e) {\n    console.debug('resetEditCorrectorCaches: ignore', e);\n  }\n}\n\n// Schemas for LLM generateJson calls\nconst OLD_STRING_CORRECTION_SCHEMA = {\n  type: 'object',\n  properties: {\n    corrected_target_snippet: {\n      type: 'string',\n      description:\n        'The corrected version of the target snippet that exactly and uniquely matches a segment within the provided file content.',\n    },\n  },\n  required: ['corrected_target_snippet'],\n};\n\nconst NEW_STRING_CORRECTION_SCHEMA = {\n  type: 'object',\n  properties: {\n    corrected_new_string: {\n      type: 'string',\n      description:\n        'The original_new_string adjusted to be a suitable replacement for the corrected_old_string, while maintaining the original intent of the change.',\n    },\n  },\n  required: ['corrected_new_string'],\n};\n\nconst CORRECT_NEW_STRING_ESCAPING_SCHEMA = {\n  type: 'object',\n  properties: {\n    corrected_new_string_escaping: {\n      type: 'string',\n      description:\n        'The new_string with corrected escaping, ensuring it is a proper replacement for the old_string, especially considering potential over-escaping issues from previous LLM generations.',\n    },\n  },\n  required: ['corrected_new_string_escaping'],\n};\n\nconst CORRECT_STRING_ESCAPING_SCHEMA = {\n  type: 'object',\n  properties: {\n    corrected_string_escaping: {\n      type: 'string',\n      description:\n        'The string with corrected escaping, ensuring it is valid, specially considering potential over-escaping issues from previous LLM generations.',\n    },\n  },\n  required: ['corrected_string_escaping'],\n};\n\n/**\n * Try to correct an old_string that did not match by asking the LLM for the\n * likely segment in the file content that the snippet intended to match.\n */\nasync function correctOldStringMismatch(\n  geminiClient: GeminiClient,\n  fileContent: string,\n  problematicSnippet: string,\n  abortSignal: AbortSignal,\n): Promise<string> {\n  const prompt = `\nContext: A process needs to find an exact literal, unique match for a specific text snippet within a file's content. The provided snippet failed to match exactly. This is most likely because it has been overly escaped.\n\nTask: Analyze the provided file content and the problematic target snippet. Identify the segment in the file content that the snippet was *most likely* intended to match. Output the *exact*, literal text of that segment from the file content. Focus *only* on removing extra escape characters and correcting formatting, whitespace, or minor differences to achieve a PERFECT literal match. The output must be the exact literal text as it appears in the file.\n\nProblematic target snippet:\n\\`\\`\\`\n${problematicSnippet}\n\\`\\`\\`\n\nFile Content:\n\\`\\`\\`\n${fileContent}\n\\`\\`\\`\n\nReturn ONLY the corrected target snippet in the specified JSON format with the key 'corrected_target_snippet'. If no clear, unique match can be found, return an empty string for 'corrected_target_snippet'.\n`.trim();\n\n  const contents = [{ role: 'user', parts: [{ text: prompt }] }];\n  try {\n    const result = (await geminiClient.generateJson(\n      contents,\n      OLD_STRING_CORRECTION_SCHEMA,\n      abortSignal,\n      EditModel,\n      EditConfig,\n    )) as Record<string, unknown> | undefined;\n    if (result) {\n      const corrected = result['corrected_target_snippet'];\n      if (typeof corrected === 'string' && corrected.length > 0) return corrected;\n    }\n    return problematicSnippet;\n  } catch (error) {\n    if (abortSignal.aborted) throw error;\n    console.error('Error during LLM call for old string snippet correction:', error);\n    return problematicSnippet;\n  }\n}\n\nasync function correctNewString(\n  geminiClient: GeminiClient,\n  originalOldString: string,\n  correctedOldString: string,\n  originalNewString: string,\n  abortSignal: AbortSignal,\n): Promise<string> {\n  if (originalOldString === correctedOldString) return originalNewString;\n\n  const prompt = `\nContext: A text replacement operation was planned. The original text to be replaced (original_old_string) was slightly different from the actual text in the file (corrected_old_string). The original_old_string has now been corrected to match the file content.\nWe now need to adjust the replacement text (original_new_string) so that it makes sense as a replacement for the corrected_old_string, while preserving the original intent of the change.\n\noriginal_old_string (what was initially intended to be found):\n\\`\\`\\`\n${originalOldString}\n\\`\\`\\`\n\ncorrected_old_string (what was actually found in the file and will be replaced):\n\\`\\`\\`\n${correctedOldString}\n\\`\\`\\`\n\noriginal_new_string (what was intended to replace original_old_string):\n\\`\\`\\`\n${originalNewString}\n\\`\\`\\`\n\nTask: Based on the differences between original_old_string and corrected_old_string, and the content of original_new_string, generate a corrected_new_string. This corrected_new_string should be what original_new_string would have been if it was designed to replace corrected_old_string directly, while maintaining the spirit of the original transformation.\n\nReturn ONLY the corrected string in the specified JSON format with the key 'corrected_new_string'. If no adjustment is deemed necessary or possible, return the original_new_string.\n  `.trim();\n\n  const contents = [{ role: 'user', parts: [{ text: prompt }] }];\n  try {\n    const result = (await geminiClient.generateJson(\n      contents,\n      NEW_STRING_CORRECTION_SCHEMA,\n      abortSignal,\n      EditModel,\n      EditConfig,\n    )) as Record<string, unknown> | undefined;\n    if (result) {\n      const corrected = result['corrected_new_string'];\n      if (typeof corrected === 'string' && corrected.length > 0) return corrected;\n    }\n    return originalNewString;\n  } catch (error) {\n    if (abortSignal.aborted) throw error;\n    console.error('Error during LLM call for new_string correction:', error);\n    return originalNewString;\n  }\n}\n\nasync function correctNewStringEscaping(\n  geminiClient: GeminiClient,\n  oldString: string,\n  potentiallyProblematicNewString: string | undefined,\n  abortSignal: AbortSignal,\n): Promise<string | undefined> {\n  const prompt = `\nContext: A text replacement operation is planned. The text to be replaced (old_string) has been correctly identified in the file. However, the replacement text (new_string) might have been improperly escaped by a previous LLM generation.\n\nold_string (this is the exact text that will be replaced):\n\\`\\`${oldString}\n\npotentially_problematic_new_string (this is the text that should replace old_string, but MIGHT have bad escaping, or might be entirely correct):\n\\`\\`${potentiallyProblematicNewString ?? ''}\n\nTask: Analyze the potentially_problematic_new_string. If it's syntactically invalid due to incorrect escaping, correct the invalid syntax. Return ONLY the corrected string in the specified JSON format with the key 'corrected_new_string_escaping'. If no escaping correction is needed, return the original potentially_problematic_new_string.\n  `.trim();\n\n  const contents = [{ role: 'user', parts: [{ text: prompt }] }];\n  try {\n    const result = (await geminiClient.generateJson(\n      contents,\n      CORRECT_NEW_STRING_ESCAPING_SCHEMA,\n      abortSignal,\n      EditModel,\n      EditConfig,\n    )) as Record<string, unknown> | undefined;\n    if (result) {\n      const corrected1 = result['corrected_new_string_escaping'];\n      if (typeof corrected1 === 'string' && corrected1.length > 0) return corrected1;\n      const corrected2 = result['corrected_new_string'];\n      if (typeof corrected2 === 'string' && corrected2.length > 0) return corrected2;\n    }\n    return potentiallyProblematicNewString;\n  } catch (error) {\n    if (abortSignal.aborted) throw error;\n    console.error('Error during LLM call for new_string escaping correction:', error);\n    return potentiallyProblematicNewString;\n  }\n}\n\nasync function correctStringEscaping(\n  potentiallyProblematicString: string,\n  client: GeminiClient,\n  abortSignal: AbortSignal,\n): Promise<string> {\n  const prompt = `\nContext: An LLM has just generated potentially_problematic_string and the text might have been improperly escaped.\n\npotentially_problematic_string (this text MIGHT have bad escaping, or might be entirely correct):\n\\`\\`\\`\n${potentiallyProblematicString}\n\\`\\`\\`\n\nTask: Analyze the potentially_problematic_string. If it's syntactically invalid due to incorrect escaping, correct the invalid syntax.\n\nReturn ONLY the corrected string in the specified JSON format with the key 'corrected_string_escaping'. If no escaping correction is needed, return the original potentially_problematic_string.\n  `.trim();\n\n  const contents = [{ role: 'user', parts: [{ text: prompt }] }];\n  try {\n    const result = (await client.generateJson(\n      contents,\n      CORRECT_STRING_ESCAPING_SCHEMA,\n      abortSignal,\n      EditModel,\n      EditConfig,\n    )) as Record<string, unknown> | undefined;\n    if (result) {\n      const corrected = result['corrected_string_escaping'];\n      if (typeof corrected === 'string' && corrected.length > 0) return corrected;\n    }\n    return potentiallyProblematicString;\n  } catch (error) {\n    if (abortSignal.aborted) throw error;\n    console.error('Error during LLM call for string escaping correction:', error);\n    return potentiallyProblematicString;\n  }\n}\n\nfunction trimPairIfPossible(\n  target: string,\n  trimIfTargetTrims: string,\n  currentContent: string,\n  expectedReplacements: number,\n): { targetString: string; pair: string } {\n  const trimmedTargetString = target.trim();\n  if (target.length !== trimmedTargetString.length) {\n    const trimmedTargetOccurrences = countOccurrences(currentContent, trimmedTargetString);\n    if (trimmedTargetOccurrences === expectedReplacements) {\n      const trimmedReactiveString = trimIfTargetTrims.trim();\n      return { targetString: trimmedTargetString, pair: trimmedReactiveString };\n    }\n  }\n  return { targetString: target, pair: trimIfTargetTrims };\n}\n\n/**\n * Ensure file content escaping is corrected when necessary via LLM.\n */\nexport async function ensureCorrectFileContent(\n  content: string,\n  client: GeminiClient,\n  abortSignal: AbortSignal,\n): Promise<string> {\n  const cached = fileContentCorrectionCache.get(content);\n  if (cached) return cached;\n\n  const contentPotentiallyEscaped = unescapeStringForGeminiBug(content) !== content;\n  if (!contentPotentiallyEscaped) {\n    fileContentCorrectionCache.set(content, content);\n    return content;\n  }\n\n  const correctedContent = await correctStringEscaping(content, client, abortSignal);\n  fileContentCorrectionCache.set(content, correctedContent);\n  return correctedContent;\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/editor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/editor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/environmentContext.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/environmentContext.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/errorParsing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/errorParsing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/errorReporting.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/errorReporting.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/fetch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/fileUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/fileUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/crawlCache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/crawlCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/crawler.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/crawler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/fileSearch.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/fileSearch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/ignore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/ignore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/result-cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/filesearch/result-cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/flashFallback.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/generateContentResponseUtilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/generateContentResponseUtilities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/getFolderStructure.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/getFolderStructure.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/getPty.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[137,140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[137,140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport type PtyImplementation = {\n   \n  module: any;\n  name: 'lydell-node-pty' | 'node-pty';\n} | null;\n\nexport interface PtyProcess {\n  readonly pid: number;\n  onData(callback: (data: string) => void): void;\n  onExit(callback: (e: { exitCode: number; signal?: number }) => void): void;\n  kill(signal?: string): void;\n}\n\nexport const getPty = async (): Promise<PtyImplementation> => {\n  try {\n    const lydell = '@lydell/node-pty';\n    const module = await import(lydell);\n    return { module, name: 'lydell-node-pty' };\n  } catch (_e) {\n    try {\n      const nodePty = 'node-pty';\n      const module = await import(nodePty);\n      return { module, name: 'node-pty' };\n    } catch (_e2) {\n      return null;\n    }\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/gitIgnoreParser.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/gitIgnoreParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/gitUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/ignorePatterns.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/ignorePatterns.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/installationManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/installationManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/language-detection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/memoryDiscovery.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/memoryDiscovery.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[796,799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[796,799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[885,888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[885,888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[969,972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[969,972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport { homedir } from 'os';\nimport { bfsFileSearch } from './bfsFileSearch.js';\nimport {\n  GEMINI_CONFIG_DIR,\n  getAllGeminiMdFilenames,\n} from '../tools/memoryTool.js';\nimport { FileDiscoveryService } from '../services/fileDiscoveryService.js';\nimport { processImports } from './memoryImportProcessor.js';\nimport {\n  DEFAULT_MEMORY_FILE_FILTERING_OPTIONS,\n  FileFilteringOptions,\n} from '../config/config.js';\n\n// Simple console logger, similar to the one previously in CLI's config.ts\n// TODO: Integrate with a more robust server-side logger if available/appropriate.\nconst logger = {\n   \n  debug: (...args: any[]) =>\n    console.debug('[DEBUG] [MemoryDiscovery]', ...args),\n   \n  warn: (...args: any[]) => console.warn('[WARN] [MemoryDiscovery]', ...args),\n   \n  error: (...args: any[]) =>\n    console.error('[ERROR] [MemoryDiscovery]', ...args),\n};\n\ninterface GeminiFileContent {\n  filePath: string;\n  content: string | null;\n}\n\nasync function findProjectRoot(startDir: string): Promise<string | null> {\n  let currentDir = path.resolve(startDir);\n  while (true) {\n    const gitPath = path.join(currentDir, '.git');\n    try {\n      const stats = await fs.lstat(gitPath);\n      if (stats.isDirectory()) {\n        return currentDir;\n      }\n    } catch (error: unknown) {\n      // Don't log ENOENT errors as they're expected when .git doesn't exist\n      // Also don't log errors in test environments, which often have mocked fs\n      const isENOENT =\n        typeof error === 'object' &&\n        error !== null &&\n        'code' in error &&\n        (error as { code: string }).code === 'ENOENT';\n\n      // Only log unexpected errors in non-test environments\n      // process.env['NODE_ENV'] === 'test' or VITEST are common test indicators\n      const isTestEnv =\n        process.env['NODE_ENV'] === 'test' || process.env['VITEST'];\n\n      if (!isENOENT && !isTestEnv) {\n        if (typeof error === 'object' && error !== null && 'code' in error) {\n          const fsError = error as { code: string; message: string };\n          logger.warn(\n            `Error checking for .git directory at ${gitPath}: ${fsError.message}`,\n          );\n        } else {\n          logger.warn(\n            `Non-standard error checking for .git directory at ${gitPath}: ${String(error)}`,\n          );\n        }\n      }\n    }\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      return null;\n    }\n    currentDir = parentDir;\n  }\n}\n\nasync function getGeminiMdFilePathsInternal(\n  currentWorkingDirectory: string,\n  includeDirectoriesToReadGemini: readonly string[],\n  userHomePath: string,\n  debugMode: boolean,\n  fileService: FileDiscoveryService,\n  extensionContextFilePaths: string[] = [],\n  fileFilteringOptions: FileFilteringOptions,\n  maxDirs: number,\n): Promise<string[]> {\n  const dirs = new Set<string>([\n    ...includeDirectoriesToReadGemini,\n    currentWorkingDirectory,\n  ]);\n\n  // Process directories in parallel with concurrency limit to prevent EMFILE errors\n  const CONCURRENT_LIMIT = 10;\n  const dirsArray = Array.from(dirs);\n  const pathsArrays: string[][] = [];\n\n  for (let i = 0; i < dirsArray.length; i += CONCURRENT_LIMIT) {\n    const batch = dirsArray.slice(i, i + CONCURRENT_LIMIT);\n    const batchPromises = batch.map((dir) =>\n      getGeminiMdFilePathsInternalForEachDir(\n        dir,\n        userHomePath,\n        debugMode,\n        fileService,\n        extensionContextFilePaths,\n        fileFilteringOptions,\n        maxDirs,\n      ),\n    );\n\n    const batchResults = await Promise.allSettled(batchPromises);\n\n    for (const result of batchResults) {\n      if (result.status === 'fulfilled') {\n        pathsArrays.push(result.value);\n      } else {\n        const error = result.reason;\n        const message = error instanceof Error ? error.message : String(error);\n        logger.error(`Error discovering files in directory: ${message}`);\n        // Continue processing other directories\n      }\n    }\n  }\n\n  const paths = pathsArrays.flat();\n  return Array.from(new Set<string>(paths));\n}\n\nasync function getGeminiMdFilePathsInternalForEachDir(\n  dir: string,\n  userHomePath: string,\n  debugMode: boolean,\n  fileService: FileDiscoveryService,\n  extensionContextFilePaths: string[] = [],\n  fileFilteringOptions: FileFilteringOptions,\n  maxDirs: number,\n): Promise<string[]> {\n  const allPaths = new Set<string>();\n  const geminiMdFilenames = getAllGeminiMdFilenames();\n\n  for (const geminiMdFilename of geminiMdFilenames) {\n    const resolvedHome = path.resolve(userHomePath);\n    const globalMemoryPath = path.join(\n      resolvedHome,\n      GEMINI_CONFIG_DIR,\n      geminiMdFilename,\n    );\n\n    // This part that finds the global file always runs.\n    try {\n      await fs.access(globalMemoryPath, fsSync.constants.R_OK);\n      allPaths.add(globalMemoryPath);\n      if (debugMode)\n        logger.debug(\n          `Found readable global ${geminiMdFilename}: ${globalMemoryPath}`,\n        );\n    } catch {\n      // It's okay if it's not found.\n    }\n\n    // FIX: Only perform the workspace search (upward and downward scans)\n    // if a valid currentWorkingDirectory is provided.\n    if (dir) {\n      const resolvedCwd = path.resolve(dir);\n      if (debugMode)\n        logger.debug(\n          `Searching for ${geminiMdFilename} starting from CWD: ${resolvedCwd}`,\n        );\n\n      const projectRoot = await findProjectRoot(resolvedCwd);\n      if (debugMode)\n        logger.debug(`Determined project root: ${projectRoot ?? 'None'}`);\n\n      const upwardPaths: string[] = [];\n      let currentDir = resolvedCwd;\n      const ultimateStopDir = projectRoot\n        ? path.dirname(projectRoot)\n        : path.dirname(resolvedHome);\n\n      while (currentDir && currentDir !== path.dirname(currentDir)) {\n        if (currentDir === path.join(resolvedHome, GEMINI_CONFIG_DIR)) {\n          break;\n        }\n\n        const potentialPath = path.join(currentDir, geminiMdFilename);\n        try {\n          await fs.access(potentialPath, fsSync.constants.R_OK);\n          if (potentialPath !== globalMemoryPath) {\n            upwardPaths.unshift(potentialPath);\n          }\n        } catch {\n          // Not found, continue.\n        }\n\n        if (currentDir === ultimateStopDir) {\n          break;\n        }\n\n        currentDir = path.dirname(currentDir);\n      }\n      upwardPaths.forEach((p) => allPaths.add(p));\n\n      const mergedOptions = {\n        ...DEFAULT_MEMORY_FILE_FILTERING_OPTIONS,\n        ...fileFilteringOptions,\n      };\n\n      const downwardPaths = await bfsFileSearch(resolvedCwd, {\n        fileName: geminiMdFilename,\n        maxDirs,\n        debug: debugMode,\n        fileService,\n        fileFilteringOptions: mergedOptions,\n      });\n      downwardPaths.sort();\n      for (const dPath of downwardPaths) {\n        allPaths.add(dPath);\n      }\n    }\n  }\n\n  // Add extension context file paths.\n  for (const extensionPath of extensionContextFilePaths) {\n    allPaths.add(extensionPath);\n  }\n\n  const finalPaths = Array.from(allPaths);\n\n  if (debugMode)\n    logger.debug(\n      `Final ordered ${getAllGeminiMdFilenames()} paths to read: ${JSON.stringify(\n        finalPaths,\n      )}`,\n    );\n  return finalPaths;\n}\n\nasync function readGeminiMdFiles(\n  filePaths: string[],\n  debugMode: boolean,\n  importFormat: 'flat' | 'tree' = 'tree',\n): Promise<GeminiFileContent[]> {\n  // Process files in parallel with concurrency limit to prevent EMFILE errors\n  const CONCURRENT_LIMIT = 20; // Higher limit for file reads as they're typically faster\n  const results: GeminiFileContent[] = [];\n\n  for (let i = 0; i < filePaths.length; i += CONCURRENT_LIMIT) {\n    const batch = filePaths.slice(i, i + CONCURRENT_LIMIT);\n    const batchPromises = batch.map(\n      async (filePath): Promise<GeminiFileContent> => {\n        try {\n          const content = await fs.readFile(filePath, 'utf-8');\n\n          // Process imports in the content\n          const processedResult = await processImports(\n            content,\n            path.dirname(filePath),\n            debugMode,\n            undefined,\n            undefined,\n            importFormat,\n          );\n          if (debugMode)\n            logger.debug(\n              `Successfully read and processed imports: ${filePath} (Length: ${processedResult.content.length})`,\n            );\n\n          return { filePath, content: processedResult.content };\n        } catch (error: unknown) {\n          const isTestEnv =\n            process.env['NODE_ENV'] === 'test' || process.env['VITEST'];\n          if (!isTestEnv) {\n            const message =\n              error instanceof Error ? error.message : String(error);\n            logger.warn(\n              `Warning: Could not read ${getAllGeminiMdFilenames()} file at ${filePath}. Error: ${message}`,\n            );\n          }\n          if (debugMode) logger.debug(`Failed to read: ${filePath}`);\n          return { filePath, content: null }; // Still include it with null content\n        }\n      },\n    );\n\n    const batchResults = await Promise.allSettled(batchPromises);\n\n    for (const result of batchResults) {\n      if (result.status === 'fulfilled') {\n        results.push(result.value);\n      } else {\n        // This case shouldn't happen since we catch all errors above,\n        // but handle it for completeness\n        const error = result.reason;\n        const message = error instanceof Error ? error.message : String(error);\n        logger.error(`Unexpected error processing file: ${message}`);\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction concatenateInstructions(\n  instructionContents: GeminiFileContent[],\n  // CWD is needed to resolve relative paths for display markers\n  currentWorkingDirectoryForDisplay: string,\n): string {\n  return instructionContents\n    .filter((item) => typeof item.content === 'string')\n    .map((item) => {\n      const trimmedContent = (item.content as string).trim();\n      if (trimmedContent.length === 0) {\n        return null;\n      }\n      const displayPath = path.isAbsolute(item.filePath)\n        ? path.relative(currentWorkingDirectoryForDisplay, item.filePath)\n        : item.filePath;\n      return `--- Context from: ${displayPath} ---\\n${trimmedContent}\\n--- End of Context from: ${displayPath} ---`;\n    })\n    .filter((block): block is string => block !== null)\n    .join('\\n\\n');\n}\n\n/**\n * Loads hierarchical GEMINI.md files and concatenates their content.\n * This function is intended for use by the server.\n */\nexport async function loadServerHierarchicalMemory(\n  currentWorkingDirectory: string,\n  includeDirectoriesToReadGemini: readonly string[],\n  debugMode: boolean,\n  fileService: FileDiscoveryService,\n  extensionContextFilePaths: string[] = [],\n  importFormat: 'flat' | 'tree' = 'tree',\n  fileFilteringOptions?: FileFilteringOptions,\n  maxDirs: number = 200,\n): Promise<{ memoryContent: string; fileCount: number }> {\n  if (debugMode)\n    logger.debug(\n      `Loading server hierarchical memory for CWD: ${currentWorkingDirectory} (importFormat: ${importFormat})`,\n    );\n\n  // For the server, homedir() refers to the server process's home.\n  // This is consistent with how MemoryTool already finds the global path.\n  const userHomePath = homedir();\n  const filePaths = await getGeminiMdFilePathsInternal(\n    currentWorkingDirectory,\n    includeDirectoriesToReadGemini,\n    userHomePath,\n    debugMode,\n    fileService,\n    extensionContextFilePaths,\n    fileFilteringOptions || DEFAULT_MEMORY_FILE_FILTERING_OPTIONS,\n    maxDirs,\n  );\n  if (filePaths.length === 0) {\n    if (debugMode)\n      logger.debug('No GEMINI.md files found in hierarchy of the workspace.');\n    return { memoryContent: '', fileCount: 0 };\n  }\n  const contentsWithPaths = await readGeminiMdFiles(\n    filePaths,\n    debugMode,\n    importFormat,\n  );\n  // Pass CWD for relative path display in concatenated content\n  const combinedInstructions = concatenateInstructions(\n    contentsWithPaths,\n    currentWorkingDirectory,\n  );\n  if (debugMode)\n    logger.debug(\n      `Combined instructions length: ${combinedInstructions.length}`,\n    );\n  if (debugMode && combinedInstructions.length > 0)\n    logger.debug(\n      `Combined instructions (snippet): ${combinedInstructions.substring(0, 500)}...`,\n    );\n  return {\n    memoryContent: combinedInstructions,\n    fileCount: contentsWithPaths.length,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/memoryImportProcessor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/memoryImportProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[315,318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[315,318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[404,407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[404,407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[488,491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[488,491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { isSubpath } from './paths.js';\nimport { marked } from 'marked';\n\n// Simple console logger for import processing\nconst logger = {\n   \n  debug: (...args: any[]) =>\n    console.debug('[DEBUG] [ImportProcessor]', ...args),\n   \n  warn: (...args: any[]) => console.warn('[WARN] [ImportProcessor]', ...args),\n   \n  error: (...args: any[]) =>\n    console.error('[ERROR] [ImportProcessor]', ...args),\n};\n\n/**\n * Interface for tracking import processing state to prevent circular imports\n */\ninterface ImportState {\n  processedFiles: Set<string>;\n  maxDepth: number;\n  currentDepth: number;\n  currentFile?: string; // Track the current file being processed\n}\n\n/**\n * Interface representing a file in the import tree\n */\nexport interface MemoryFile {\n  path: string;\n  imports?: MemoryFile[]; // Direct imports, in the order they were imported\n}\n\n/**\n * Result of processing imports\n */\nexport interface ProcessImportsResult {\n  content: string;\n  importTree: MemoryFile;\n}\n\n// Helper to find the project root (looks for .git directory)\nasync function findProjectRoot(startDir: string): Promise<string> {\n  let currentDir = path.resolve(startDir);\n  while (true) {\n    const gitPath = path.join(currentDir, '.git');\n    try {\n      const stats = await fs.lstat(gitPath);\n      if (stats.isDirectory()) {\n        return currentDir;\n      }\n    } catch {\n      // .git not found, continue to parent\n    }\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      // Reached filesystem root\n      break;\n    }\n    currentDir = parentDir;\n  }\n  // Fallback to startDir if .git not found\n  return path.resolve(startDir);\n}\n\n// Add a type guard for error objects\nfunction hasMessage(err: unknown): err is { message: string } {\n  return (\n    typeof err === 'object' &&\n    err !== null &&\n    'message' in err &&\n    typeof (err as { message: unknown }).message === 'string'\n  );\n}\n\n// Helper to find all code block and inline code regions using marked\n/**\n * Finds all import statements in content without using regex\n * @returns Array of {start, _end, path} objects for each import found\n */\nfunction findImports(\n  content: string,\n): Array<{ start: number; _end: number; path: string }> {\n  const imports: Array<{ start: number; _end: number; path: string }> = [];\n  let i = 0;\n  const len = content.length;\n\n  while (i < len) {\n    // Find next @ symbol\n    i = content.indexOf('@', i);\n    if (i === -1) break;\n\n    // Check if it's a word boundary (not part of another word)\n    if (i > 0 && !isWhitespace(content[i - 1])) {\n      i++;\n      continue;\n    }\n\n    // Find the end of the import path (whitespace or newline)\n    let j = i + 1;\n    while (\n      j < len &&\n      !isWhitespace(content[j]) &&\n      content[j] !== '\\n' &&\n      content[j] !== '\\r'\n    ) {\n      j++;\n    }\n\n    // Extract the path (everything after @)\n    const importPath = content.slice(i + 1, j);\n\n    // Basic validation (starts with ./ or / or letter)\n    if (\n      importPath.length > 0 &&\n      (importPath[0] === '.' ||\n        importPath[0] === '/' ||\n        isLetter(importPath[0]))\n    ) {\n      imports.push({\n        start: i,\n        _end: j,\n        path: importPath,\n      });\n    }\n\n    i = j + 1;\n  }\n\n  return imports;\n}\n\nfunction isWhitespace(char: string): boolean {\n  return char === ' ' || char === '\\t' || char === '\\n' || char === '\\r';\n}\n\nfunction isLetter(char: string): boolean {\n  const code = char.charCodeAt(0);\n  return (\n    (code >= 65 && code <= 90) || // A-Z\n    (code >= 97 && code <= 122)\n  ); // a-z\n}\n\nfunction findCodeRegions(content: string): Array<[number, number]> {\n  const regions: Array<[number, number]> = [];\n  const tokens = marked.lexer(content);\n\n  // Map from raw content to a queue of its start indices in the original content.\n  const rawContentIndices = new Map<string, number[]>();\n\n  function walk(token: { type: string; raw: string; tokens?: unknown[] }) {\n    if (token.type === 'code' || token.type === 'codespan') {\n      if (!rawContentIndices.has(token.raw)) {\n        const indices: number[] = [];\n        let lastIndex = -1;\n        while ((lastIndex = content.indexOf(token.raw, lastIndex + 1)) !== -1) {\n          indices.push(lastIndex);\n        }\n        rawContentIndices.set(token.raw, indices);\n      }\n\n      const indices = rawContentIndices.get(token.raw);\n      if (indices && indices.length > 0) {\n        // Assume tokens are processed in order of appearance.\n        // Dequeue the next available index for this raw content.\n        const idx = indices.shift()!;\n        regions.push([idx, idx + token.raw.length]);\n      }\n    }\n\n    if ('tokens' in token && token.tokens) {\n      for (const child of token.tokens) {\n        walk(child as { type: string; raw: string; tokens?: unknown[] });\n      }\n    }\n  }\n\n  for (const token of tokens) {\n    walk(token);\n  }\n\n  return regions;\n}\n\n/**\n * Processes import statements in GEMINI.md content\n * Supports @path/to/file syntax for importing content from other files\n * @param content - The content to process for imports\n * @param basePath - The directory path where the current file is located\n * @param debugMode - Whether to enable debug logging\n * @param importState - State tracking for circular import prevention\n * @param projectRoot - The project root directory for allowed directories\n * @param importFormat - The format of the import tree\n * @returns Processed content with imports resolved and import tree\n */\nexport async function processImports(\n  content: string,\n  basePath: string,\n  debugMode: boolean = false,\n  importState: ImportState = {\n    processedFiles: new Set(),\n    maxDepth: 5,\n    currentDepth: 0,\n  },\n  projectRoot?: string,\n  importFormat: 'flat' | 'tree' = 'tree',\n): Promise<ProcessImportsResult> {\n  if (!projectRoot) {\n    projectRoot = await findProjectRoot(basePath);\n  }\n\n  if (importState.currentDepth >= importState.maxDepth) {\n    if (debugMode) {\n      logger.warn(\n        `Maximum import depth (${importState.maxDepth}) reached. Stopping import processing.`,\n      );\n    }\n    return {\n      content,\n      importTree: { path: importState.currentFile || 'unknown' },\n    };\n  }\n\n  // --- FLAT FORMAT LOGIC ---\n  if (importFormat === 'flat') {\n    // Use a queue to process files in order of first encounter, and a set to avoid duplicates\n    const flatFiles: Array<{ path: string; content: string }> = [];\n    // Track processed files across the entire operation\n    const processedFiles = new Set<string>();\n\n    // Helper to recursively process imports\n    async function processFlat(\n      fileContent: string,\n      fileBasePath: string,\n      filePath: string,\n      depth: number,\n    ) {\n      // Normalize the file path to ensure consistent comparison\n      const normalizedPath = path.normalize(filePath);\n\n      // Skip if already processed\n      if (processedFiles.has(normalizedPath)) return;\n\n      // Mark as processed before processing to prevent infinite recursion\n      processedFiles.add(normalizedPath);\n\n      // Add this file to the flat list\n      flatFiles.push({ path: normalizedPath, content: fileContent });\n\n      // Find imports in this file\n      const codeRegions = findCodeRegions(fileContent);\n      const imports = findImports(fileContent);\n\n      // Process imports in reverse order to handle indices correctly\n      for (let i = imports.length - 1; i >= 0; i--) {\n        const { start, path: importPath } = imports[i];\n\n        // Skip if inside a code region\n        if (\n          codeRegions.some(\n            ([regionStart, regionEnd]) =>\n              start >= regionStart && start < regionEnd,\n          )\n        ) {\n          continue;\n        }\n\n        // Validate import path\n        if (\n          !validateImportPath(importPath, fileBasePath, [projectRoot || ''])\n        ) {\n          continue;\n        }\n\n        const fullPath = path.resolve(fileBasePath, importPath);\n        const normalizedFullPath = path.normalize(fullPath);\n\n        // Skip if already processed\n        if (processedFiles.has(normalizedFullPath)) continue;\n\n        try {\n          await fs.access(fullPath);\n          const importedContent = await fs.readFile(fullPath, 'utf-8');\n\n          // Process the imported file\n          await processFlat(\n            importedContent,\n            path.dirname(fullPath),\n            normalizedFullPath,\n            depth + 1,\n          );\n        } catch (error) {\n          if (debugMode) {\n            logger.warn(\n              `Failed to import ${fullPath}: ${hasMessage(error) ? error.message : 'Unknown error'}`,\n            );\n          }\n          // Continue with other imports even if one fails\n        }\n      }\n    }\n\n    // Start with the root file (current file)\n    const rootPath = path.normalize(\n      importState.currentFile || path.resolve(basePath),\n    );\n    await processFlat(content, basePath, rootPath, 0);\n\n    // Concatenate all unique files in order, Claude-style\n    const flatContent = flatFiles\n      .map(\n        (f) =>\n          `--- File: ${f.path} ---\\n${f.content.trim()}\\n--- End of File: ${f.path} ---`,\n      )\n      .join('\\n\\n');\n\n    return {\n      content: flatContent,\n      importTree: { path: rootPath }, // Tree not meaningful in flat mode\n    };\n  }\n\n  // --- TREE FORMAT LOGIC (existing) ---\n  const codeRegions = findCodeRegions(content);\n  let result = '';\n  let lastIndex = 0;\n  const imports: MemoryFile[] = [];\n  const importsList = findImports(content);\n\n  for (const { start, _end, path: importPath } of importsList) {\n    // Add content before this import\n    result += content.substring(lastIndex, start);\n    lastIndex = _end;\n\n    // Skip if inside a code region\n    if (codeRegions.some(([s, e]) => start >= s && start < e)) {\n      result += `@${importPath}`;\n      continue;\n    }\n    // Validate import path to prevent path traversal attacks\n    if (!validateImportPath(importPath, basePath, [projectRoot || ''])) {\n      result += `<!-- Import failed: ${importPath} - Path traversal attempt -->`;\n      continue;\n    }\n    const fullPath = path.resolve(basePath, importPath);\n    if (importState.processedFiles.has(fullPath)) {\n      result += `<!-- File already processed: ${importPath} -->`;\n      continue;\n    }\n    try {\n      await fs.access(fullPath);\n      const fileContent = await fs.readFile(fullPath, 'utf-8');\n      // Mark this file as processed for this import chain\n      const newImportState: ImportState = {\n        ...importState,\n        processedFiles: new Set(importState.processedFiles),\n        currentDepth: importState.currentDepth + 1,\n        currentFile: fullPath,\n      };\n      newImportState.processedFiles.add(fullPath);\n      const imported = await processImports(\n        fileContent,\n        path.dirname(fullPath),\n        debugMode,\n        newImportState,\n        projectRoot,\n        importFormat,\n      );\n      result += `<!-- Imported from: ${importPath} -->\\n${imported.content}\\n<!-- End of import from: ${importPath} -->`;\n      imports.push(imported.importTree);\n    } catch (err: unknown) {\n      let message = 'Unknown error';\n      if (hasMessage(err)) {\n        message = err.message;\n      } else if (typeof err === 'string') {\n        message = err;\n      }\n      logger.error(`Failed to import ${importPath}: ${message}`);\n      result += `<!-- Import failed: ${importPath} - ${message} -->`;\n    }\n  }\n  // Add any remaining content after the last match\n  result += content.substring(lastIndex);\n\n  return {\n    content: result,\n    importTree: {\n      path: importState.currentFile || 'unknown',\n      imports: imports.length > 0 ? imports : undefined,\n    },\n  };\n}\n\nexport function validateImportPath(\n  importPath: string,\n  basePath: string,\n  allowedDirectories: string[],\n): boolean {\n  // Reject URLs\n  if (/^(file|https?):\\/\\//.test(importPath)) {\n    return false;\n  }\n\n  const resolvedPath = path.resolve(basePath, importPath);\n\n  return allowedDirectories.some((allowedDir) =>\n    isSubpath(allowedDir, resolvedPath),\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/messageInspectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/nextSpeakerChecker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/nextSpeakerChecker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/partUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/partUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/paths.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/paths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/quotaErrorDetection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/retry.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":117,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3674,3677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3674,3677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4371,4374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4371,4374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n \nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { retryWithBackoff, HttpError } from './retry.js';\nimport { setSimulate429 } from './testUtils.js';\n\n// Helper to create a mock function that fails a certain number of times\nconst createFailingFunction = (\n  failures: number,\n  successValue: string = 'success',\n) => {\n  let attempts = 0;\n  return vi.fn(async () => {\n    attempts++;\n    if (attempts <= failures) {\n      // Simulate a retryable error\n      const error: HttpError = new Error(`Simulated error attempt ${attempts}`);\n      error.status = 500; // Simulate a server error\n      throw error;\n    }\n    return successValue;\n  });\n};\n\n// Custom error for testing non-retryable conditions\nclass NonRetryableError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NonRetryableError';\n  }\n}\n\ndescribe('retryWithBackoff', () => {\n  beforeEach(() => {\n    vi.useFakeTimers();\n    // Disable 429 simulation for tests\n    setSimulate429(false);\n    // Suppress unhandled promise rejection warnings for tests that expect errors\n    console.warn = vi.fn();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n    vi.useRealTimers();\n  });\n\n  it('should return the result on the first attempt if successful', async () => {\n    const mockFn = createFailingFunction(0);\n    const result = await retryWithBackoff(mockFn);\n    expect(result).toBe('success');\n    expect(mockFn).toHaveBeenCalledTimes(1);\n  });\n\n  it('should retry and succeed if failures are within maxAttempts', async () => {\n    const mockFn = createFailingFunction(2);\n    const promise = retryWithBackoff(mockFn, {\n      maxAttempts: 3,\n      initialDelayMs: 10,\n    });\n\n    await vi.runAllTimersAsync(); // Ensure all delays and retries complete\n\n    const result = await promise;\n    expect(result).toBe('success');\n    expect(mockFn).toHaveBeenCalledTimes(3);\n  });\n\n  it('should throw an error if all attempts fail', async () => {\n    const mockFn = createFailingFunction(3);\n\n    // 1. Start the retryable operation, which returns a promise.\n    const promise = retryWithBackoff(mockFn, {\n      maxAttempts: 3,\n      initialDelayMs: 10,\n    });\n\n    // 2. IMPORTANT: Attach the rejection expectation to the promise *immediately*.\n    //    This ensures a 'catch' handler is present before the promise can reject.\n    //    The result is a new promise that resolves when the assertion is met.\n    const assertionPromise = expect(promise).rejects.toThrow(\n      'Simulated error attempt 3',\n    );\n\n    // 3. Now, advance the timers. This will trigger the retries and the\n    //    eventual rejection. The handler attached in step 2 will catch it.\n    await vi.runAllTimersAsync();\n\n    // 4. Await the assertion promise itself to ensure the test was successful.\n    await assertionPromise;\n\n    // 5. Finally, assert the number of calls.\n    expect(mockFn).toHaveBeenCalledTimes(3);\n  });\n\n  it('should not retry if shouldRetry returns false', async () => {\n    const mockFn = vi.fn(async () => {\n      throw new NonRetryableError('Non-retryable error');\n    });\n    const shouldRetry = (error: Error) => !(error instanceof NonRetryableError);\n\n    const promise = retryWithBackoff(mockFn, {\n      shouldRetry,\n      initialDelayMs: 10,\n    });\n\n    await expect(promise).rejects.toThrow('Non-retryable error');\n    expect(mockFn).toHaveBeenCalledTimes(1);\n  });\n\n  it('should use default shouldRetry if not provided, retrying on 429', async () => {\n    const mockFn = vi.fn(async () => {\n      const error = new Error('Too Many Requests') as any;\n      error.status = 429;\n      throw error;\n    });\n\n    const promise = retryWithBackoff(mockFn, {\n      maxAttempts: 2,\n      initialDelayMs: 10,\n    });\n\n    // Attach the rejection expectation *before* running timers\n    const assertionPromise =\n      expect(promise).rejects.toThrow('Too Many Requests');\n\n    // Run timers to trigger retries and eventual rejection\n    await vi.runAllTimersAsync();\n\n    // Await the assertion\n    await assertionPromise;\n\n    expect(mockFn).toHaveBeenCalledTimes(2);\n  });\n\n  it('should use default shouldRetry if not provided, not retrying on 400', async () => {\n    const mockFn = vi.fn(async () => {\n      const error = new Error('Bad Request') as any;\n      error.status = 400;\n      throw error;\n    });\n\n    const promise = retryWithBackoff(mockFn, {\n      maxAttempts: 2,\n      initialDelayMs: 10,\n    });\n    await expect(promise).rejects.toThrow('Bad Request');\n    expect(mockFn).toHaveBeenCalledTimes(1);\n  });\n\n  it('should respect maxDelayMs', async () => {\n    const mockFn = createFailingFunction(3);\n    const setTimeoutSpy = vi.spyOn(global, 'setTimeout');\n\n    const promise = retryWithBackoff(mockFn, {\n      maxAttempts: 4,\n      initialDelayMs: 100,\n      maxDelayMs: 250, // Max delay is less than 100 * 2 * 2 = 400\n    });\n\n    await vi.advanceTimersByTimeAsync(1000); // Advance well past all delays\n    await promise;\n\n    const delays = setTimeoutSpy.mock.calls.map((call) => call[1] as number);\n\n    // Delays should be around initial, initial*2, maxDelay (due to cap)\n    // Jitter makes exact assertion hard, so we check ranges / caps\n    expect(delays.length).toBe(3);\n    expect(delays[0]).toBeGreaterThanOrEqual(100 * 0.7);\n    expect(delays[0]).toBeLessThanOrEqual(100 * 1.3);\n    expect(delays[1]).toBeGreaterThanOrEqual(200 * 0.7);\n    expect(delays[1]).toBeLessThanOrEqual(200 * 1.3);\n    // The third delay should be capped by maxDelayMs (250ms), accounting for jitter\n    expect(delays[2]).toBeGreaterThanOrEqual(250 * 0.7);\n    expect(delays[2]).toBeLessThanOrEqual(250 * 1.3);\n  });\n\n  it('should handle jitter correctly, ensuring varied delays', async () => {\n    let mockFn = createFailingFunction(5);\n    const setTimeoutSpy = vi.spyOn(global, 'setTimeout');\n\n    // Run retryWithBackoff multiple times to observe jitter\n    const runRetry = () =>\n      retryWithBackoff(mockFn, {\n        maxAttempts: 2, // Only one retry, so one delay\n        initialDelayMs: 100,\n        maxDelayMs: 1000,\n      });\n\n    // We expect rejections as mockFn fails 5 times\n    const promise1 = runRetry();\n    // Attach the rejection expectation *before* running timers\n    const assertionPromise1 = expect(promise1).rejects.toThrow();\n    await vi.runAllTimersAsync(); // Advance for the delay in the first runRetry\n    await assertionPromise1;\n\n    const firstDelaySet = setTimeoutSpy.mock.calls.map(\n      (call) => call[1] as number,\n    );\n    setTimeoutSpy.mockClear(); // Clear calls for the next run\n\n    // Reset mockFn to reset its internal attempt counter for the next run\n    mockFn = createFailingFunction(5); // Re-initialize with 5 failures\n\n    const promise2 = runRetry();\n    // Attach the rejection expectation *before* running timers\n    const assertionPromise2 = expect(promise2).rejects.toThrow();\n    await vi.runAllTimersAsync(); // Advance for the delay in the second runRetry\n    await assertionPromise2;\n\n    const secondDelaySet = setTimeoutSpy.mock.calls.map(\n      (call) => call[1] as number,\n    );\n\n    // Check that the delays are not exactly the same due to jitter\n    // This is a probabilistic test, but with +/-30% jitter, it's highly likely they differ.\n    if (firstDelaySet.length > 0 && secondDelaySet.length > 0) {\n      // Check the first delay of each set\n      expect(firstDelaySet[0]).not.toBe(secondDelaySet[0]);\n    } else {\n      // If somehow no delays were captured (e.g. test setup issue), fail explicitly\n      throw new Error('Delays were not captured for jitter test');\n    }\n\n    // Ensure delays are within the expected jitter range [70, 130] for initialDelayMs = 100\n    [...firstDelaySet, ...secondDelaySet].forEach((d) => {\n      expect(d).toBeGreaterThanOrEqual(100 * 0.7);\n      expect(d).toBeLessThanOrEqual(100 * 1.3);\n    });\n  });\n\n  describe('Flash model fallback for OAuth users', () => {\n    it('should trigger fallback for OAuth personal users after persistent 429 errors', async () => {\n      const fallbackCallback = vi.fn().mockResolvedValue('gemini-2.5-flash');\n\n      let fallbackOccurred = false;\n      const mockFn = vi.fn().mockImplementation(async () => {\n        if (!fallbackOccurred) {\n          const error: HttpError = new Error('Rate limit exceeded');\n          error.status = 429;\n          throw error;\n        }\n        return 'success';\n      });\n\n      const promise = retryWithBackoff(mockFn, {\n        maxAttempts: 3,\n        initialDelayMs: 100,\n        onPersistent429: async (authType?: string) => {\n          fallbackOccurred = true;\n          return await fallbackCallback(authType);\n        },\n        authType: 'oauth-personal',\n      });\n\n      // Advance all timers to complete retries\n      await vi.runAllTimersAsync();\n\n      // Should succeed after fallback\n      await expect(promise).resolves.toBe('success');\n\n      // Verify callback was called with correct auth type\n      expect(fallbackCallback).toHaveBeenCalledWith('oauth-personal');\n\n      // Should retry again after fallback\n      expect(mockFn).toHaveBeenCalledTimes(3); // 2 initial attempts + 1 after fallback\n    });\n\n    it('should NOT trigger fallback for API key users', async () => {\n      const fallbackCallback = vi.fn();\n\n      const mockFn = vi.fn(async () => {\n        const error: HttpError = new Error('Rate limit exceeded');\n        error.status = 429;\n        throw error;\n      });\n\n      const promise = retryWithBackoff(mockFn, {\n        maxAttempts: 3,\n        initialDelayMs: 100,\n        onPersistent429: fallbackCallback,\n        authType: 'gemini-api-key',\n      });\n\n      // Handle the promise properly to avoid unhandled rejections\n      const resultPromise = promise.catch((error) => error);\n      await vi.runAllTimersAsync();\n      const result = await resultPromise;\n\n      // Should fail after all retries without fallback\n      expect(result).toBeInstanceOf(Error);\n      expect(result.message).toBe('Rate limit exceeded');\n\n      // Callback should not be called for API key users\n      expect(fallbackCallback).not.toHaveBeenCalled();\n    });\n\n    it('should reset attempt counter and continue after successful fallback', async () => {\n      let fallbackCalled = false;\n      const fallbackCallback = vi.fn().mockImplementation(async () => {\n        fallbackCalled = true;\n        return 'gemini-2.5-flash';\n      });\n\n      const mockFn = vi.fn().mockImplementation(async () => {\n        if (!fallbackCalled) {\n          const error: HttpError = new Error('Rate limit exceeded');\n          error.status = 429;\n          throw error;\n        }\n        return 'success';\n      });\n\n      const promise = retryWithBackoff(mockFn, {\n        maxAttempts: 3,\n        initialDelayMs: 100,\n        onPersistent429: fallbackCallback,\n        authType: 'oauth-personal',\n      });\n\n      await vi.runAllTimersAsync();\n\n      await expect(promise).resolves.toBe('success');\n      expect(fallbackCallback).toHaveBeenCalledOnce();\n    });\n\n    it('should continue with original error if fallback is rejected', async () => {\n      const fallbackCallback = vi.fn().mockResolvedValue(null); // User rejected fallback\n\n      const mockFn = vi.fn(async () => {\n        const error: HttpError = new Error('Rate limit exceeded');\n        error.status = 429;\n        throw error;\n      });\n\n      const promise = retryWithBackoff(mockFn, {\n        maxAttempts: 3,\n        initialDelayMs: 100,\n        onPersistent429: fallbackCallback,\n        authType: 'oauth-personal',\n      });\n\n      // Handle the promise properly to avoid unhandled rejections\n      const resultPromise = promise.catch((error) => error);\n      await vi.runAllTimersAsync();\n      const result = await resultPromise;\n\n      // Should fail with original error when fallback is rejected\n      expect(result).toBeInstanceOf(Error);\n      expect(result.message).toBe('Rate limit exceeded');\n      expect(fallbackCallback).toHaveBeenCalledWith(\n        'oauth-personal',\n        expect.any(Error),\n      );\n    });\n\n    it('should handle mixed error types (only count consecutive 429s)', async () => {\n      const fallbackCallback = vi.fn().mockResolvedValue('gemini-2.5-flash');\n      let attempts = 0;\n      let fallbackOccurred = false;\n\n      const mockFn = vi.fn().mockImplementation(async () => {\n        attempts++;\n        if (fallbackOccurred) {\n          return 'success';\n        }\n        if (attempts === 1) {\n          // First attempt: 500 error (resets consecutive count)\n          const error: HttpError = new Error('Server error');\n          error.status = 500;\n          throw error;\n        } else {\n          // Remaining attempts: 429 errors\n          const error: HttpError = new Error('Rate limit exceeded');\n          error.status = 429;\n          throw error;\n        }\n      });\n\n      const promise = retryWithBackoff(mockFn, {\n        maxAttempts: 5,\n        initialDelayMs: 100,\n        onPersistent429: async (authType?: string) => {\n          fallbackOccurred = true;\n          return await fallbackCallback(authType);\n        },\n        authType: 'oauth-personal',\n      });\n\n      await vi.runAllTimersAsync();\n\n      await expect(promise).resolves.toBe('success');\n\n      // Should trigger fallback after 2 consecutive 429s (attempts 2-3)\n      expect(fallbackCallback).toHaveBeenCalledWith('oauth-personal');\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/retry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/safeJsonStringify.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[553,556],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[553,556],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[851,854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[851,854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1433,1436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1433,1436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1698,1701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1698,1701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { describe, it, expect } from 'vitest';\nimport { safeJsonStringify } from './safeJsonStringify.js';\n\ndescribe('safeJsonStringify', () => {\n  it('should stringify normal objects without issues', () => {\n    const obj = { name: 'test', value: 42 };\n    const result = safeJsonStringify(obj);\n    expect(result).toBe('{\"name\":\"test\",\"value\":42}');\n  });\n\n  it('should handle circular references by replacing them with [Circular]', () => {\n     \n    const obj: any = { name: 'test' };\n    obj.circular = obj; // Create circular reference\n\n    const result = safeJsonStringify(obj);\n    expect(result).toBe('{\"name\":\"test\",\"circular\":\"[Circular]\"}');\n  });\n\n  it('should handle complex circular structures like HttpsProxyAgent', () => {\n     \n    const agent: any = {\n      sockets: {},\n      options: { host: 'example.com' },\n    };\n    agent.sockets['example.com'] = [{ agent }];\n\n    const result = safeJsonStringify(agent);\n    expect(result).toContain('[Circular]');\n    expect(result).toContain('example.com');\n  });\n\n  it('should respect the space parameter for formatting', () => {\n    const obj = { name: 'test', value: 42 };\n    const result = safeJsonStringify(obj, 2);\n    expect(result).toBe('{\\n  \"name\": \"test\",\\n  \"value\": 42\\n}');\n  });\n\n  it('should handle circular references with formatting', () => {\n     \n    const obj: any = { name: 'test' };\n    obj.circular = obj;\n\n    const result = safeJsonStringify(obj, 2);\n    expect(result).toBe('{\\n  \"name\": \"test\",\\n  \"circular\": \"[Circular]\"\\n}');\n  });\n\n  it('should handle arrays with circular references', () => {\n     \n    const arr: any[] = [{ id: 1 }];\n    arr[0].parent = arr; // Create circular reference\n\n    const result = safeJsonStringify(arr);\n    expect(result).toBe('[{\"id\":1,\"parent\":\"[Circular]\"}]');\n  });\n\n  it('should handle null and undefined values', () => {\n    expect(safeJsonStringify(null)).toBe('null');\n    expect(safeJsonStringify(undefined)).toBe(undefined);\n  });\n\n  it('should handle primitive values', () => {\n    expect(safeJsonStringify('test')).toBe('\"test\"');\n    expect(safeJsonStringify(42)).toBe('42');\n    expect(safeJsonStringify(true)).toBe('true');\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/safeJsonStringify.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/schemaValidator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[226,229],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[226,229],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport AjvPkg from 'ajv';\n// Ajv's ESM/CJS interop: use 'any' for compatibility as recommended by Ajv docs\n \nconst AjvClass = (AjvPkg as any).default || AjvPkg;\nconst ajValidator = new AjvClass();\n\n/**\n * Simple utility to validate objects against JSON Schemas\n */\nexport class SchemaValidator {\n  /**\n   * Returns null if the data confroms to the schema described by schema (or if schema\n   *  is null). Otherwise, returns a string describing the error.\n   */\n  static validate(schema: unknown | undefined, data: unknown): string | null {\n    if (!schema) {\n      return null;\n    }\n    if (typeof data !== 'object' || data === null) {\n      return 'Value of params must be an object';\n    }\n    const validate = ajValidator.compile(schema);\n    const valid = validate(data);\n    if (!valid && validate.errors) {\n      return ajValidator.errorsText(validate.errors, { dataVar: 'params' });\n    }\n    return null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/secure-browser-launcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/secure-browser-launcher.ts","messages":[],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":39,"column":7,"nodeType":"Literal","messageId":"unexpected","endLine":39,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/shell-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/shell-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/summarizer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/summarizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/systemEncoding.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/systemEncoding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/testUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/textUtils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/textUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/userAccountManager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/userAccountManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/workspaceContext.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/src/utils/workspaceContext.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/core/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/test-utils/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/test-utils/src/file-system-test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/test-utils/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/diff-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/extension.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/extension.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/ide-server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/ide-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/open-files-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/open-files-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/packages/vscode-ide-companion/src/utils/logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/scripts/tests/test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/scripts/tests/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/media/seikarii/Nvme/gemini-cli/test-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]